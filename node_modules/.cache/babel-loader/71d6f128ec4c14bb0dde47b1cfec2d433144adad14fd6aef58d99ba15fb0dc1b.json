{"ast":null,"code":"import _objectSpread from \"D:/diarry me/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nconst e = \"undefined\" != typeof globalThis ? globalThis : \"undefined\" != typeof self ? self : \"undefined\" != typeof window ? window : global,\n  t = Object.keys,\n  n = Array.isArray;\nfunction r(e, n) {\n  return \"object\" != typeof n || t(n).forEach(function (t) {\n    e[t] = n[t];\n  }), e;\n}\n\"undefined\" == typeof Promise || e.Promise || (e.Promise = Promise);\nconst s = Object.getPrototypeOf,\n  i = {}.hasOwnProperty;\nfunction o(e, t) {\n  return i.call(e, t);\n}\nfunction a(e, n) {\n  \"function\" == typeof n && (n = n(s(e))), (\"undefined\" == typeof Reflect ? t : Reflect.ownKeys)(n).forEach(t => {\n    l(e, t, n[t]);\n  });\n}\nconst u = Object.defineProperty;\nfunction l(e, t, n, s) {\n  u(e, t, r(n && o(n, \"get\") && \"function\" == typeof n.get ? {\n    get: n.get,\n    set: n.set,\n    configurable: !0\n  } : {\n    value: n,\n    configurable: !0,\n    writable: !0\n  }, s));\n}\nfunction c(e) {\n  return {\n    from: function (t) {\n      return e.prototype = Object.create(t.prototype), l(e.prototype, \"constructor\", e), {\n        extend: a.bind(null, e.prototype)\n      };\n    }\n  };\n}\nconst h = Object.getOwnPropertyDescriptor;\nfunction d(e, t) {\n  let n;\n  return h(e, t) || (n = s(e)) && d(n, t);\n}\nconst f = [].slice;\nfunction p(e, t, n) {\n  return f.call(e, t, n);\n}\nfunction y(e, t) {\n  return t(e);\n}\nfunction m(e) {\n  if (!e) throw new Error(\"Assertion Failed\");\n}\nfunction v(t) {\n  e.setImmediate ? setImmediate(t) : setTimeout(t, 0);\n}\nfunction g(e, t) {\n  return e.reduce((e, n, r) => {\n    var s = t(n, r);\n    return s && (e[s[0]] = s[1]), e;\n  }, {});\n}\nfunction b(e, t) {\n  if (\"string\" == typeof t && o(e, t)) return e[t];\n  if (!t) return e;\n  if (\"string\" != typeof t) {\n    for (var n = [], r = 0, s = t.length; r < s; ++r) {\n      var i = b(e, t[r]);\n      n.push(i);\n    }\n    return n;\n  }\n  var a = t.indexOf(\".\");\n  if (-1 !== a) {\n    var u = e[t.substr(0, a)];\n    return null == u ? void 0 : b(u, t.substr(a + 1));\n  }\n}\nfunction _(e, t, r) {\n  if (e && void 0 !== t && (!(\"isFrozen\" in Object) || !Object.isFrozen(e))) if (\"string\" != typeof t && \"length\" in t) {\n    m(\"string\" != typeof r && \"length\" in r);\n    for (var s = 0, i = t.length; s < i; ++s) _(e, t[s], r[s]);\n  } else {\n    var a = t.indexOf(\".\");\n    if (-1 !== a) {\n      var u = t.substr(0, a),\n        l = t.substr(a + 1);\n      if (\"\" === l) void 0 === r ? n(e) && !isNaN(parseInt(u)) ? e.splice(u, 1) : delete e[u] : e[u] = r;else {\n        var c = e[u];\n        c && o(e, u) || (c = e[u] = {}), _(c, l, r);\n      }\n    } else void 0 === r ? n(e) && !isNaN(parseInt(t)) ? e.splice(t, 1) : delete e[t] : e[t] = r;\n  }\n}\nfunction w(e) {\n  var t = {};\n  for (var n in e) o(e, n) && (t[n] = e[n]);\n  return t;\n}\nconst x = [].concat;\nfunction k(e) {\n  return x.apply([], e);\n}\nconst E = \"BigUint64Array,BigInt64Array,Array,Boolean,String,Date,RegExp,Blob,File,FileList,FileSystemFileHandle,FileSystemDirectoryHandle,ArrayBuffer,DataView,Uint8ClampedArray,ImageBitmap,ImageData,Map,Set,CryptoKey\".split(\",\").concat(k([8, 16, 32, 64].map(e => [\"Int\", \"Uint\", \"Float\"].map(t => t + e + \"Array\")))).filter(t => e[t]),\n  P = E.map(t => e[t]);\ng(E, e => [e, !0]);\nlet K = null;\nfunction O(e) {\n  K = \"undefined\" != typeof WeakMap && new WeakMap();\n  const t = S(e);\n  return K = null, t;\n}\nfunction S(e) {\n  if (!e || \"object\" != typeof e) return e;\n  let t = K && K.get(e);\n  if (t) return t;\n  if (n(e)) {\n    t = [], K && K.set(e, t);\n    for (var r = 0, i = e.length; r < i; ++r) t.push(S(e[r]));\n  } else if (P.indexOf(e.constructor) >= 0) t = e;else {\n    const n = s(e);\n    for (var a in t = n === Object.prototype ? {} : Object.create(n), K && K.set(e, t), e) o(e, a) && (t[a] = S(e[a]));\n  }\n  return t;\n}\nconst {\n  toString: A\n} = {};\nfunction C(e) {\n  return A.call(e).slice(8, -1);\n}\nconst j = \"undefined\" != typeof Symbol ? Symbol.iterator : \"@@iterator\",\n  D = \"symbol\" == typeof j ? function (e) {\n    var t;\n    return null != e && (t = e[j]) && t.apply(e);\n  } : function () {\n    return null;\n  },\n  I = {};\nfunction B(e) {\n  var t, r, s, i;\n  if (1 === arguments.length) {\n    if (n(e)) return e.slice();\n    if (this === I && \"string\" == typeof e) return [e];\n    if (i = D(e)) {\n      for (r = []; !(s = i.next()).done;) r.push(s.value);\n      return r;\n    }\n    if (null == e) return [e];\n    if (\"number\" == typeof (t = e.length)) {\n      for (r = new Array(t); t--;) r[t] = e[t];\n      return r;\n    }\n    return [e];\n  }\n  for (t = arguments.length, r = new Array(t); t--;) r[t] = arguments[t];\n  return r;\n}\nconst T = \"undefined\" != typeof Symbol ? e => \"AsyncFunction\" === e[Symbol.toStringTag] : () => !1;\nvar R = \"undefined\" != typeof location && /^(http|https):\\/\\/(localhost|127\\.0\\.0\\.1)/.test(location.href);\nfunction F(e, t) {\n  R = e, M = t;\n}\nvar M = () => !0;\nconst N = !new Error(\"\").stack;\nfunction q() {\n  if (N) try {\n    throw q.arguments, new Error();\n  } catch (e) {\n    return e;\n  }\n  return new Error();\n}\nfunction $(e, t) {\n  var n = e.stack;\n  return n ? (t = t || 0, 0 === n.indexOf(e.name) && (t += (e.name + e.message).split(\"\\n\").length), n.split(\"\\n\").slice(t).filter(M).map(e => \"\\n\" + e).join(\"\")) : \"\";\n}\nvar U = [\"Unknown\", \"Constraint\", \"Data\", \"TransactionInactive\", \"ReadOnly\", \"Version\", \"NotFound\", \"InvalidState\", \"InvalidAccess\", \"Abort\", \"Timeout\", \"QuotaExceeded\", \"Syntax\", \"DataClone\"],\n  L = [\"Modify\", \"Bulk\", \"OpenFailed\", \"VersionChange\", \"Schema\", \"Upgrade\", \"InvalidTable\", \"MissingAPI\", \"NoSuchDatabase\", \"InvalidArgument\", \"SubTransaction\", \"Unsupported\", \"Internal\", \"DatabaseClosed\", \"PrematureCommit\", \"ForeignAwait\"].concat(U),\n  V = {\n    VersionChanged: \"Database version changed by other database connection\",\n    DatabaseClosed: \"Database has been closed\",\n    Abort: \"Transaction aborted\",\n    TransactionInactive: \"Transaction has already completed or failed\",\n    MissingAPI: \"IndexedDB API missing. Please visit https://tinyurl.com/y2uuvskb\"\n  };\nfunction W(e, t) {\n  this._e = q(), this.name = e, this.message = t;\n}\nfunction Y(e, t) {\n  return e + \". Errors: \" + Object.keys(t).map(e => t[e].toString()).filter((e, t, n) => n.indexOf(e) === t).join(\"\\n\");\n}\nfunction z(e, t, n, r) {\n  this._e = q(), this.failures = t, this.failedKeys = r, this.successCount = n, this.message = Y(e, t);\n}\nfunction G(e, t) {\n  this._e = q(), this.name = \"BulkError\", this.failures = Object.keys(t).map(e => t[e]), this.failuresByPos = t, this.message = Y(e, t);\n}\nc(W).from(Error).extend({\n  stack: {\n    get: function () {\n      return this._stack || (this._stack = this.name + \": \" + this.message + $(this._e, 2));\n    }\n  },\n  toString: function () {\n    return this.name + \": \" + this.message;\n  }\n}), c(z).from(W), c(G).from(W);\nvar H = L.reduce((e, t) => (e[t] = t + \"Error\", e), {});\nconst Q = W;\nvar X = L.reduce((e, t) => {\n  var n = t + \"Error\";\n  function r(e, r) {\n    this._e = q(), this.name = n, e ? \"string\" == typeof e ? (this.message = \"\".concat(e).concat(r ? \"\\n \" + r : \"\"), this.inner = r || null) : \"object\" == typeof e && (this.message = \"\".concat(e.name, \" \").concat(e.message), this.inner = e) : (this.message = V[t] || n, this.inner = null);\n  }\n  return c(r).from(Q), e[t] = r, e;\n}, {});\nX.Syntax = SyntaxError, X.Type = TypeError, X.Range = RangeError;\nvar J = U.reduce((e, t) => (e[t + \"Error\"] = X[t], e), {});\nvar Z = L.reduce((e, t) => (-1 === [\"Syntax\", \"Type\", \"Range\"].indexOf(t) && (e[t + \"Error\"] = X[t]), e), {});\nfunction ee() {}\nfunction te(e) {\n  return e;\n}\nfunction ne(e, t) {\n  return null == e || e === te ? t : function (n) {\n    return t(e(n));\n  };\n}\nfunction re(e, t) {\n  return function () {\n    e.apply(this, arguments), t.apply(this, arguments);\n  };\n}\nfunction se(e, t) {\n  return e === ee ? t : function () {\n    var n = e.apply(this, arguments);\n    void 0 !== n && (arguments[0] = n);\n    var r = this.onsuccess,\n      s = this.onerror;\n    this.onsuccess = null, this.onerror = null;\n    var i = t.apply(this, arguments);\n    return r && (this.onsuccess = this.onsuccess ? re(r, this.onsuccess) : r), s && (this.onerror = this.onerror ? re(s, this.onerror) : s), void 0 !== i ? i : n;\n  };\n}\nfunction ie(e, t) {\n  return e === ee ? t : function () {\n    e.apply(this, arguments);\n    var n = this.onsuccess,\n      r = this.onerror;\n    this.onsuccess = this.onerror = null, t.apply(this, arguments), n && (this.onsuccess = this.onsuccess ? re(n, this.onsuccess) : n), r && (this.onerror = this.onerror ? re(r, this.onerror) : r);\n  };\n}\nfunction oe(e, t) {\n  return e === ee ? t : function (n) {\n    var s = e.apply(this, arguments);\n    r(n, s);\n    var i = this.onsuccess,\n      o = this.onerror;\n    this.onsuccess = null, this.onerror = null;\n    var a = t.apply(this, arguments);\n    return i && (this.onsuccess = this.onsuccess ? re(i, this.onsuccess) : i), o && (this.onerror = this.onerror ? re(o, this.onerror) : o), void 0 === s ? void 0 === a ? void 0 : a : r(s, a);\n  };\n}\nfunction ae(e, t) {\n  return e === ee ? t : function () {\n    return !1 !== t.apply(this, arguments) && e.apply(this, arguments);\n  };\n}\nfunction ue(e, t) {\n  return e === ee ? t : function () {\n    var n = e.apply(this, arguments);\n    if (n && \"function\" == typeof n.then) {\n      for (var r = this, s = arguments.length, i = new Array(s); s--;) i[s] = arguments[s];\n      return n.then(function () {\n        return t.apply(r, i);\n      });\n    }\n    return t.apply(this, arguments);\n  };\n}\nZ.ModifyError = z, Z.DexieError = W, Z.BulkError = G;\nvar le = {};\nconst ce = 100,\n  [he, de, fe] = \"undefined\" == typeof Promise ? [] : (() => {\n    let e = Promise.resolve();\n    if (\"undefined\" == typeof crypto || !crypto.subtle) return [e, s(e), e];\n    const t = crypto.subtle.digest(\"SHA-512\", new Uint8Array([0]));\n    return [t, s(t), e];\n  })(),\n  pe = de && de.then,\n  ye = he && he.constructor,\n  me = !!fe;\nvar ve = !1,\n  ge = fe ? () => {\n    fe.then($e);\n  } : e.setImmediate ? setImmediate.bind(null, $e) : e.MutationObserver ? () => {\n    var e = document.createElement(\"div\");\n    new MutationObserver(() => {\n      $e(), e = null;\n    }).observe(e, {\n      attributes: !0\n    }), e.setAttribute(\"i\", \"1\");\n  } : () => {\n    setTimeout($e, 0);\n  },\n  be = function (e, t) {\n    Se.push([e, t]), we && (ge(), we = !1);\n  },\n  _e = !0,\n  we = !0,\n  xe = [],\n  ke = [],\n  Ee = null,\n  Pe = te,\n  Ke = {\n    id: \"global\",\n    global: !0,\n    ref: 0,\n    unhandleds: [],\n    onunhandled: dt,\n    pgp: !1,\n    env: {},\n    finalize: function () {\n      this.unhandleds.forEach(e => {\n        try {\n          dt(e[0], e[1]);\n        } catch (e) {}\n      });\n    }\n  },\n  Oe = Ke,\n  Se = [],\n  Ae = 0,\n  Ce = [];\nfunction je(e) {\n  if (\"object\" != typeof this) throw new TypeError(\"Promises must be constructed via new\");\n  this._listeners = [], this.onuncatched = ee, this._lib = !1;\n  var t = this._PSD = Oe;\n  if (R && (this._stackHolder = q(), this._prev = null, this._numPrev = 0), \"function\" != typeof e) {\n    if (e !== le) throw new TypeError(\"Not a function\");\n    return this._state = arguments[1], this._value = arguments[2], void (!1 === this._state && Te(this, this._value));\n  }\n  this._state = null, this._value = null, ++t.ref, Be(this, e);\n}\nconst De = {\n  get: function () {\n    var e = Oe,\n      t = Xe;\n    function n(n, r) {\n      var s = !e.global && (e !== Oe || t !== Xe);\n      const i = s && !tt();\n      var o = new je((t, o) => {\n        Fe(this, new Ie(lt(n, e, s, i), lt(r, e, s, i), t, o, e));\n      });\n      return R && qe(o, this), o;\n    }\n    return n.prototype = le, n;\n  },\n  set: function (e) {\n    l(this, \"then\", e && e.prototype === le ? De : {\n      get: function () {\n        return e;\n      },\n      set: De.set\n    });\n  }\n};\nfunction Ie(e, t, n, r, s) {\n  this.onFulfilled = \"function\" == typeof e ? e : null, this.onRejected = \"function\" == typeof t ? t : null, this.resolve = n, this.reject = r, this.psd = s;\n}\nfunction Be(e, t) {\n  try {\n    t(t => {\n      if (null === e._state) {\n        if (t === e) throw new TypeError(\"A promise cannot be resolved with itself.\");\n        var n = e._lib && Ue();\n        t && \"function\" == typeof t.then ? Be(e, (e, n) => {\n          t instanceof je ? t._then(e, n) : t.then(e, n);\n        }) : (e._state = !0, e._value = t, Re(e)), n && Le();\n      }\n    }, Te.bind(null, e));\n  } catch (t) {\n    Te(e, t);\n  }\n}\nfunction Te(e, t) {\n  if (ke.push(t), null === e._state) {\n    var n = e._lib && Ue();\n    t = Pe(t), e._state = !1, e._value = t, R && null !== t && \"object\" == typeof t && !t._promise && function (e, t, n) {\n      try {\n        e.apply(null, n);\n      } catch (e) {\n        t && t(e);\n      }\n    }(() => {\n      var n = d(t, \"stack\");\n      t._promise = e, l(t, \"stack\", {\n        get: () => ve ? n && (n.get ? n.get.apply(t) : n.value) : e.stack\n      });\n    }), function (e) {\n      xe.some(t => t._value === e._value) || xe.push(e);\n    }(e), Re(e), n && Le();\n  }\n}\nfunction Re(e) {\n  var t = e._listeners;\n  e._listeners = [];\n  for (var n = 0, r = t.length; n < r; ++n) Fe(e, t[n]);\n  var s = e._PSD;\n  --s.ref || s.finalize(), 0 === Ae && (++Ae, be(() => {\n    0 == --Ae && Ve();\n  }, []));\n}\nfunction Fe(e, t) {\n  if (null !== e._state) {\n    var n = e._state ? t.onFulfilled : t.onRejected;\n    if (null === n) return (e._state ? t.resolve : t.reject)(e._value);\n    ++t.psd.ref, ++Ae, be(Me, [n, e, t]);\n  } else e._listeners.push(t);\n}\nfunction Me(e, t, n) {\n  try {\n    Ee = t;\n    var r,\n      s = t._value;\n    t._state ? r = e(s) : (ke.length && (ke = []), r = e(s), -1 === ke.indexOf(s) && function (e) {\n      var t = xe.length;\n      for (; t;) if (xe[--t]._value === e._value) return void xe.splice(t, 1);\n    }(t)), n.resolve(r);\n  } catch (e) {\n    n.reject(e);\n  } finally {\n    Ee = null, 0 == --Ae && Ve(), --n.psd.ref || n.psd.finalize();\n  }\n}\nfunction Ne(e, t, n) {\n  if (t.length === n) return t;\n  var r = \"\";\n  if (!1 === e._state) {\n    var s,\n      i,\n      o = e._value;\n    null != o ? (s = o.name || \"Error\", i = o.message || o, r = $(o, 0)) : (s = o, i = \"\"), t.push(s + (i ? \": \" + i : \"\") + r);\n  }\n  return R && ((r = $(e._stackHolder, 2)) && -1 === t.indexOf(r) && t.push(r), e._prev && Ne(e._prev, t, n)), t;\n}\nfunction qe(e, t) {\n  var n = t ? t._numPrev + 1 : 0;\n  n < 100 && (e._prev = t, e._numPrev = n);\n}\nfunction $e() {\n  Ue() && Le();\n}\nfunction Ue() {\n  var e = _e;\n  return _e = !1, we = !1, e;\n}\nfunction Le() {\n  var e, t, n;\n  do {\n    for (; Se.length > 0;) for (e = Se, Se = [], n = e.length, t = 0; t < n; ++t) {\n      var r = e[t];\n      r[0].apply(null, r[1]);\n    }\n  } while (Se.length > 0);\n  _e = !0, we = !0;\n}\nfunction Ve() {\n  var e = xe;\n  xe = [], e.forEach(e => {\n    e._PSD.onunhandled.call(null, e._value, e);\n  });\n  for (var t = Ce.slice(0), n = t.length; n;) t[--n]();\n}\nfunction We(e) {\n  return new je(le, !1, e);\n}\nfunction Ye(e, t) {\n  var n = Oe;\n  return function () {\n    var r = Ue(),\n      s = Oe;\n    try {\n      return it(n, !0), e.apply(this, arguments);\n    } catch (e) {\n      t && t(e);\n    } finally {\n      it(s, !1), r && Le();\n    }\n  };\n}\na(je.prototype, {\n  then: De,\n  _then: function (e, t) {\n    Fe(this, new Ie(null, null, e, t, Oe));\n  },\n  catch: function (e) {\n    if (1 === arguments.length) return this.then(null, e);\n    var t = arguments[0],\n      n = arguments[1];\n    return \"function\" == typeof t ? this.then(null, e => e instanceof t ? n(e) : We(e)) : this.then(null, e => e && e.name === t ? n(e) : We(e));\n  },\n  finally: function (e) {\n    return this.then(t => (e(), t), t => (e(), We(t)));\n  },\n  stack: {\n    get: function () {\n      if (this._stack) return this._stack;\n      try {\n        ve = !0;\n        var e = Ne(this, [], 20).join(\"\\nFrom previous: \");\n        return null !== this._state && (this._stack = e), e;\n      } finally {\n        ve = !1;\n      }\n    }\n  },\n  timeout: function (e, t) {\n    return e < 1 / 0 ? new je((n, r) => {\n      var s = setTimeout(() => r(new X.Timeout(t)), e);\n      this.then(n, r).finally(clearTimeout.bind(null, s));\n    }) : this;\n  }\n}), \"undefined\" != typeof Symbol && Symbol.toStringTag && l(je.prototype, Symbol.toStringTag, \"Dexie.Promise\"), Ke.env = ot(), a(je, {\n  all: function () {\n    var e = B.apply(null, arguments).map(nt);\n    return new je(function (t, n) {\n      0 === e.length && t([]);\n      var r = e.length;\n      e.forEach((s, i) => je.resolve(s).then(n => {\n        e[i] = n, --r || t(e);\n      }, n));\n    });\n  },\n  resolve: e => {\n    if (e instanceof je) return e;\n    if (e && \"function\" == typeof e.then) return new je((t, n) => {\n      e.then(t, n);\n    });\n    var t = new je(le, !0, e);\n    return qe(t, Ee), t;\n  },\n  reject: We,\n  race: function () {\n    var e = B.apply(null, arguments).map(nt);\n    return new je((t, n) => {\n      e.map(e => je.resolve(e).then(t, n));\n    });\n  },\n  PSD: {\n    get: () => Oe,\n    set: e => Oe = e\n  },\n  totalEchoes: {\n    get: () => Xe\n  },\n  newPSD: Ze,\n  usePSD: at,\n  scheduler: {\n    get: () => be,\n    set: e => {\n      be = e;\n    }\n  },\n  rejectionMapper: {\n    get: () => Pe,\n    set: e => {\n      Pe = e;\n    }\n  },\n  follow: (e, t) => new je((n, r) => Ze((t, n) => {\n    var r = Oe;\n    r.unhandleds = [], r.onunhandled = n, r.finalize = re(function () {\n      !function (e) {\n        function t() {\n          e(), Ce.splice(Ce.indexOf(t), 1);\n        }\n        Ce.push(t), ++Ae, be(() => {\n          0 == --Ae && Ve();\n        }, []);\n      }(() => {\n        0 === this.unhandleds.length ? t() : n(this.unhandleds[0]);\n      });\n    }, r.finalize), e();\n  }, t, n, r))\n}), ye && (ye.allSettled && l(je, \"allSettled\", function () {\n  const e = B.apply(null, arguments).map(nt);\n  return new je(t => {\n    0 === e.length && t([]);\n    let n = e.length;\n    const r = new Array(n);\n    e.forEach((e, s) => je.resolve(e).then(e => r[s] = {\n      status: \"fulfilled\",\n      value: e\n    }, e => r[s] = {\n      status: \"rejected\",\n      reason: e\n    }).then(() => --n || t(r)));\n  });\n}), ye.any && \"undefined\" != typeof AggregateError && l(je, \"any\", function () {\n  const e = B.apply(null, arguments).map(nt);\n  return new je((t, n) => {\n    0 === e.length && n(new AggregateError([]));\n    let r = e.length;\n    const s = new Array(r);\n    e.forEach((e, i) => je.resolve(e).then(e => t(e), e => {\n      s[i] = e, --r || n(new AggregateError(s));\n    }));\n  });\n}));\nconst ze = {\n  awaits: 0,\n  echoes: 0,\n  id: 0\n};\nvar Ge = 0,\n  He = [],\n  Qe = 0,\n  Xe = 0,\n  Je = 0;\nfunction Ze(e, t, n, s) {\n  var i = Oe,\n    o = Object.create(i);\n  o.parent = i, o.ref = 0, o.global = !1, o.id = ++Je;\n  var a = Ke.env;\n  o.env = me ? {\n    Promise: je,\n    PromiseProp: {\n      value: je,\n      configurable: !0,\n      writable: !0\n    },\n    all: je.all,\n    race: je.race,\n    allSettled: je.allSettled,\n    any: je.any,\n    resolve: je.resolve,\n    reject: je.reject,\n    nthen: ct(a.nthen, o),\n    gthen: ct(a.gthen, o)\n  } : {}, t && r(o, t), ++i.ref, o.finalize = function () {\n    --this.parent.ref || this.parent.finalize();\n  };\n  var u = at(o, e, n, s);\n  return 0 === o.ref && o.finalize(), u;\n}\nfunction et() {\n  return ze.id || (ze.id = ++Ge), ++ze.awaits, ze.echoes += ce, ze.id;\n}\nfunction tt() {\n  return !!ze.awaits && (0 == --ze.awaits && (ze.id = 0), ze.echoes = ze.awaits * ce, !0);\n}\nfunction nt(e) {\n  return ze.echoes && e && e.constructor === ye ? (et(), e.then(e => (tt(), e), e => (tt(), ft(e)))) : e;\n}\nfunction rt(e) {\n  ++Xe, ze.echoes && 0 != --ze.echoes || (ze.echoes = ze.id = 0), He.push(Oe), it(e, !0);\n}\nfunction st() {\n  var e = He[He.length - 1];\n  He.pop(), it(e, !1);\n}\nfunction it(t, n) {\n  var r = Oe;\n  if ((n ? !ze.echoes || Qe++ && t === Oe : !Qe || --Qe && t === Oe) || ut(n ? rt.bind(null, t) : st), t !== Oe && (Oe = t, r === Ke && (Ke.env = ot()), me)) {\n    var s = Ke.env.Promise,\n      i = t.env;\n    de.then = i.nthen, s.prototype.then = i.gthen, (r.global || t.global) && (Object.defineProperty(e, \"Promise\", i.PromiseProp), s.all = i.all, s.race = i.race, s.resolve = i.resolve, s.reject = i.reject, i.allSettled && (s.allSettled = i.allSettled), i.any && (s.any = i.any));\n  }\n}\nfunction ot() {\n  var t = e.Promise;\n  return me ? {\n    Promise: t,\n    PromiseProp: Object.getOwnPropertyDescriptor(e, \"Promise\"),\n    all: t.all,\n    race: t.race,\n    allSettled: t.allSettled,\n    any: t.any,\n    resolve: t.resolve,\n    reject: t.reject,\n    nthen: de.then,\n    gthen: t.prototype.then\n  } : {};\n}\nfunction at(e, t, n, r, s) {\n  var i = Oe;\n  try {\n    return it(e, !0), t(n, r, s);\n  } finally {\n    it(i, !1);\n  }\n}\nfunction ut(e) {\n  pe.call(he, e);\n}\nfunction lt(e, t, n, r) {\n  return \"function\" != typeof e ? e : function () {\n    var s = Oe;\n    n && et(), it(t, !0);\n    try {\n      return e.apply(this, arguments);\n    } finally {\n      it(s, !1), r && ut(tt);\n    }\n  };\n}\nfunction ct(e, t) {\n  return function (n, r) {\n    return e.call(this, lt(n, t), lt(r, t));\n  };\n}\n-1 === (\"\" + pe).indexOf(\"[native code]\") && (et = tt = ee);\nconst ht = \"unhandledrejection\";\nfunction dt(t, n) {\n  var s;\n  try {\n    s = n.onuncatched(t);\n  } catch (e) {}\n  if (!1 !== s) try {\n    var i,\n      o = {\n        promise: n,\n        reason: t\n      };\n    if (e.document && document.createEvent ? ((i = document.createEvent(\"Event\")).initEvent(ht, !0, !0), r(i, o)) : e.CustomEvent && r(i = new CustomEvent(ht, {\n      detail: o\n    }), o), i && e.dispatchEvent && (dispatchEvent(i), !e.PromiseRejectionEvent && e.onunhandledrejection)) try {\n      e.onunhandledrejection(i);\n    } catch (e) {}\n    R && i && !i.defaultPrevented && console.warn(\"Unhandled rejection: \".concat(t.stack || t));\n  } catch (e) {}\n}\nvar ft = je.reject;\nfunction pt(e, t, n, r) {\n  if (e.idbdb && (e._state.openComplete || Oe.letThrough || e._vip)) {\n    var s = e._createTransaction(t, n, e._dbSchema);\n    try {\n      s.create(), e._state.PR1398_maxLoop = 3;\n    } catch (s) {\n      return s.name === H.InvalidState && e.isOpen() && --e._state.PR1398_maxLoop > 0 ? (console.warn(\"Dexie: Need to reopen db\"), e._close(), e.open().then(() => pt(e, t, n, r))) : ft(s);\n    }\n    return s._promise(t, (e, t) => Ze(() => (Oe.trans = s, r(e, t, s)))).then(e => s._completion.then(() => e));\n  }\n  if (e._state.openComplete) return ft(new X.DatabaseClosed(e._state.dbOpenError));\n  if (!e._state.isBeingOpened) {\n    if (!e._options.autoOpen) return ft(new X.DatabaseClosed());\n    e.open().catch(ee);\n  }\n  return e._state.dbReadyPromise.then(() => pt(e, t, n, r));\n}\nconst yt = \"3.2.7\",\n  mt = String.fromCharCode(65535),\n  vt = -1 / 0,\n  gt = \"Invalid key provided. Keys must be of type string, number, Date or Array<string | number | Date>.\",\n  bt = \"String expected.\",\n  _t = [],\n  wt = \"undefined\" != typeof navigator && /(MSIE|Trident|Edge)/.test(navigator.userAgent),\n  xt = wt,\n  kt = wt,\n  Et = e => !/(dexie\\.js|dexie\\.min\\.js)/.test(e),\n  Pt = \"__dbnames\",\n  Kt = \"readonly\",\n  Ot = \"readwrite\";\nfunction St(e, t) {\n  return e ? t ? function () {\n    return e.apply(this, arguments) && t.apply(this, arguments);\n  } : e : t;\n}\nconst At = {\n  type: 3,\n  lower: -1 / 0,\n  lowerOpen: !1,\n  upper: [[]],\n  upperOpen: !1\n};\nfunction Ct(e) {\n  return \"string\" != typeof e || /\\./.test(e) ? e => e : t => (void 0 === t[e] && e in t && delete (t = O(t))[e], t);\n}\nclass jt {\n  _trans(e, t, n) {\n    const r = this._tx || Oe.trans,\n      s = this.name;\n    function i(e, n, r) {\n      if (!r.schema[s]) throw new X.NotFound(\"Table \" + s + \" not part of transaction\");\n      return t(r.idbtrans, r);\n    }\n    const o = Ue();\n    try {\n      return r && r.db === this.db ? r === Oe.trans ? r._promise(e, i, n) : Ze(() => r._promise(e, i, n), {\n        trans: r,\n        transless: Oe.transless || Oe\n      }) : pt(this.db, e, [this.name], i);\n    } finally {\n      o && Le();\n    }\n  }\n  get(e, t) {\n    return e && e.constructor === Object ? this.where(e).first(t) : this._trans(\"readonly\", t => this.core.get({\n      trans: t,\n      key: e\n    }).then(e => this.hook.reading.fire(e))).then(t);\n  }\n  where(e) {\n    if (\"string\" == typeof e) return new this.db.WhereClause(this, e);\n    if (n(e)) return new this.db.WhereClause(this, \"[\".concat(e.join(\"+\"), \"]\"));\n    const r = t(e);\n    if (1 === r.length) return this.where(r[0]).equals(e[r[0]]);\n    const s = this.schema.indexes.concat(this.schema.primKey).filter(e => {\n      if (e.compound && r.every(t => e.keyPath.indexOf(t) >= 0)) {\n        for (let t = 0; t < r.length; ++t) if (-1 === r.indexOf(e.keyPath[t])) return !1;\n        return !0;\n      }\n      return !1;\n    }).sort((e, t) => e.keyPath.length - t.keyPath.length)[0];\n    if (s && this.db._maxKey !== mt) {\n      const t = s.keyPath.slice(0, r.length);\n      return this.where(t).equals(t.map(t => e[t]));\n    }\n    !s && R && console.warn(\"The query \".concat(JSON.stringify(e), \" on \").concat(this.name, \" would benefit of a compound index [\").concat(r.join(\"+\"), \"]\"));\n    const {\n        idxByName: i\n      } = this.schema,\n      o = this.db._deps.indexedDB;\n    function a(e, t) {\n      try {\n        return 0 === o.cmp(e, t);\n      } catch (e) {\n        return !1;\n      }\n    }\n    const [u, l] = r.reduce((_ref, s) => {\n      let [t, r] = _ref;\n      const o = i[s],\n        u = e[s];\n      return [t || o, t || !o ? St(r, o && o.multi ? e => {\n        const t = b(e, s);\n        return n(t) && t.some(e => a(u, e));\n      } : e => a(u, b(e, s))) : r];\n    }, [null, null]);\n    return u ? this.where(u.name).equals(e[u.keyPath]).filter(l) : s ? this.filter(l) : this.where(r).equals(\"\");\n  }\n  filter(e) {\n    return this.toCollection().and(e);\n  }\n  count(e) {\n    return this.toCollection().count(e);\n  }\n  offset(e) {\n    return this.toCollection().offset(e);\n  }\n  limit(e) {\n    return this.toCollection().limit(e);\n  }\n  each(e) {\n    return this.toCollection().each(e);\n  }\n  toArray(e) {\n    return this.toCollection().toArray(e);\n  }\n  toCollection() {\n    return new this.db.Collection(new this.db.WhereClause(this));\n  }\n  orderBy(e) {\n    return new this.db.Collection(new this.db.WhereClause(this, n(e) ? \"[\".concat(e.join(\"+\"), \"]\") : e));\n  }\n  reverse() {\n    return this.toCollection().reverse();\n  }\n  mapToClass(e) {\n    this.schema.mappedClass = e;\n    const t = t => {\n      if (!t) return t;\n      const n = Object.create(e.prototype);\n      for (var r in t) if (o(t, r)) try {\n        n[r] = t[r];\n      } catch (e) {}\n      return n;\n    };\n    return this.schema.readHook && this.hook.reading.unsubscribe(this.schema.readHook), this.schema.readHook = t, this.hook(\"reading\", t), e;\n  }\n  defineClass() {\n    return this.mapToClass(function (e) {\n      r(this, e);\n    });\n  }\n  add(e, t) {\n    const {\n      auto: n,\n      keyPath: r\n    } = this.schema.primKey;\n    let s = e;\n    return r && n && (s = Ct(r)(e)), this._trans(\"readwrite\", e => this.core.mutate({\n      trans: e,\n      type: \"add\",\n      keys: null != t ? [t] : null,\n      values: [s]\n    })).then(e => e.numFailures ? je.reject(e.failures[0]) : e.lastResult).then(t => {\n      if (r) try {\n        _(e, r, t);\n      } catch (e) {}\n      return t;\n    });\n  }\n  update(e, r) {\n    if (\"object\" != typeof e || n(e)) return this.where(\":id\").equals(e).modify(r);\n    {\n      const n = b(e, this.schema.primKey.keyPath);\n      if (void 0 === n) return ft(new X.InvalidArgument(\"Given object does not contain its primary key\"));\n      try {\n        \"function\" != typeof r ? t(r).forEach(t => {\n          _(e, t, r[t]);\n        }) : r(e, {\n          value: e,\n          primKey: n\n        });\n      } catch (e) {}\n      return this.where(\":id\").equals(n).modify(r);\n    }\n  }\n  put(e, t) {\n    const {\n      auto: n,\n      keyPath: r\n    } = this.schema.primKey;\n    let s = e;\n    return r && n && (s = Ct(r)(e)), this._trans(\"readwrite\", e => this.core.mutate({\n      trans: e,\n      type: \"put\",\n      values: [s],\n      keys: null != t ? [t] : null\n    })).then(e => e.numFailures ? je.reject(e.failures[0]) : e.lastResult).then(t => {\n      if (r) try {\n        _(e, r, t);\n      } catch (e) {}\n      return t;\n    });\n  }\n  delete(e) {\n    return this._trans(\"readwrite\", t => this.core.mutate({\n      trans: t,\n      type: \"delete\",\n      keys: [e]\n    })).then(e => e.numFailures ? je.reject(e.failures[0]) : void 0);\n  }\n  clear() {\n    return this._trans(\"readwrite\", e => this.core.mutate({\n      trans: e,\n      type: \"deleteRange\",\n      range: At\n    })).then(e => e.numFailures ? je.reject(e.failures[0]) : void 0);\n  }\n  bulkGet(e) {\n    return this._trans(\"readonly\", t => this.core.getMany({\n      keys: e,\n      trans: t\n    }).then(e => e.map(e => this.hook.reading.fire(e))));\n  }\n  bulkAdd(e, t, n) {\n    const r = Array.isArray(t) ? t : void 0,\n      s = (n = n || (r ? void 0 : t)) ? n.allKeys : void 0;\n    return this._trans(\"readwrite\", t => {\n      const {\n        auto: n,\n        keyPath: i\n      } = this.schema.primKey;\n      if (i && r) throw new X.InvalidArgument(\"bulkAdd(): keys argument invalid on tables with inbound keys\");\n      if (r && r.length !== e.length) throw new X.InvalidArgument(\"Arguments objects and keys must have the same length\");\n      const o = e.length;\n      let a = i && n ? e.map(Ct(i)) : e;\n      return this.core.mutate({\n        trans: t,\n        type: \"add\",\n        keys: r,\n        values: a,\n        wantResults: s\n      }).then(_ref2 => {\n        let {\n          numFailures: e,\n          results: t,\n          lastResult: n,\n          failures: r\n        } = _ref2;\n        if (0 === e) return s ? t : n;\n        throw new G(\"\".concat(this.name, \".bulkAdd(): \").concat(e, \" of \").concat(o, \" operations failed\"), r);\n      });\n    });\n  }\n  bulkPut(e, t, n) {\n    const r = Array.isArray(t) ? t : void 0,\n      s = (n = n || (r ? void 0 : t)) ? n.allKeys : void 0;\n    return this._trans(\"readwrite\", t => {\n      const {\n        auto: n,\n        keyPath: i\n      } = this.schema.primKey;\n      if (i && r) throw new X.InvalidArgument(\"bulkPut(): keys argument invalid on tables with inbound keys\");\n      if (r && r.length !== e.length) throw new X.InvalidArgument(\"Arguments objects and keys must have the same length\");\n      const o = e.length;\n      let a = i && n ? e.map(Ct(i)) : e;\n      return this.core.mutate({\n        trans: t,\n        type: \"put\",\n        keys: r,\n        values: a,\n        wantResults: s\n      }).then(_ref3 => {\n        let {\n          numFailures: e,\n          results: t,\n          lastResult: n,\n          failures: r\n        } = _ref3;\n        if (0 === e) return s ? t : n;\n        throw new G(\"\".concat(this.name, \".bulkPut(): \").concat(e, \" of \").concat(o, \" operations failed\"), r);\n      });\n    });\n  }\n  bulkDelete(e) {\n    const t = e.length;\n    return this._trans(\"readwrite\", t => this.core.mutate({\n      trans: t,\n      type: \"delete\",\n      keys: e\n    })).then(_ref4 => {\n      let {\n        numFailures: e,\n        lastResult: n,\n        failures: r\n      } = _ref4;\n      if (0 === e) return n;\n      throw new G(\"\".concat(this.name, \".bulkDelete(): \").concat(e, \" of \").concat(t, \" operations failed\"), r);\n    });\n  }\n}\nfunction Dt(e) {\n  var r = {},\n    s = function (t, n) {\n      if (n) {\n        for (var s = arguments.length, i = new Array(s - 1); --s;) i[s - 1] = arguments[s];\n        return r[t].subscribe.apply(null, i), e;\n      }\n      if (\"string\" == typeof t) return r[t];\n    };\n  s.addEventType = a;\n  for (var i = 1, o = arguments.length; i < o; ++i) a(arguments[i]);\n  return s;\n  function a(e, i, o) {\n    if (\"object\" != typeof e) {\n      var u;\n      i || (i = ae), o || (o = ee);\n      var l = {\n        subscribers: [],\n        fire: o,\n        subscribe: function (e) {\n          -1 === l.subscribers.indexOf(e) && (l.subscribers.push(e), l.fire = i(l.fire, e));\n        },\n        unsubscribe: function (e) {\n          l.subscribers = l.subscribers.filter(function (t) {\n            return t !== e;\n          }), l.fire = l.subscribers.reduce(i, o);\n        }\n      };\n      return r[e] = s[e] = l, l;\n    }\n    t(u = e).forEach(function (e) {\n      var t = u[e];\n      if (n(t)) a(e, u[e][0], u[e][1]);else {\n        if (\"asap\" !== t) throw new X.InvalidArgument(\"Invalid event config\");\n        var r = a(e, te, function () {\n          for (var e = arguments.length, t = new Array(e); e--;) t[e] = arguments[e];\n          r.subscribers.forEach(function (e) {\n            v(function () {\n              e.apply(null, t);\n            });\n          });\n        });\n      }\n    });\n  }\n}\nfunction It(e, t) {\n  return c(t).from({\n    prototype: e\n  }), t;\n}\nfunction Bt(e, t) {\n  return !(e.filter || e.algorithm || e.or) && (t ? e.justLimit : !e.replayFilter);\n}\nfunction Tt(e, t) {\n  e.filter = St(e.filter, t);\n}\nfunction Rt(e, t, n) {\n  var r = e.replayFilter;\n  e.replayFilter = r ? () => St(r(), t()) : t, e.justLimit = n && !r;\n}\nfunction Ft(e, t) {\n  if (e.isPrimKey) return t.primaryKey;\n  const n = t.getIndexByKeyPath(e.index);\n  if (!n) throw new X.Schema(\"KeyPath \" + e.index + \" on object store \" + t.name + \" is not indexed\");\n  return n;\n}\nfunction Mt(e, t, n) {\n  const r = Ft(e, t.schema);\n  return t.openCursor({\n    trans: n,\n    values: !e.keysOnly,\n    reverse: \"prev\" === e.dir,\n    unique: !!e.unique,\n    query: {\n      index: r,\n      range: e.range\n    }\n  });\n}\nfunction Nt(e, t, n, r) {\n  const s = e.replayFilter ? St(e.filter, e.replayFilter()) : e.filter;\n  if (e.or) {\n    const i = {},\n      a = (e, n, r) => {\n        if (!s || s(n, r, e => n.stop(e), e => n.fail(e))) {\n          var a = n.primaryKey,\n            u = \"\" + a;\n          \"[object ArrayBuffer]\" === u && (u = \"\" + new Uint8Array(a)), o(i, u) || (i[u] = !0, t(e, n, r));\n        }\n      };\n    return Promise.all([e.or._iterate(a, n), qt(Mt(e, r, n), e.algorithm, a, !e.keysOnly && e.valueMapper)]);\n  }\n  return qt(Mt(e, r, n), St(e.algorithm, s), t, !e.keysOnly && e.valueMapper);\n}\nfunction qt(e, t, n, r) {\n  var s = Ye(r ? (e, t, s) => n(r(e), t, s) : n);\n  return e.then(e => {\n    if (e) return e.start(() => {\n      var n = () => e.continue();\n      t && !t(e, e => n = e, t => {\n        e.stop(t), n = ee;\n      }, t => {\n        e.fail(t), n = ee;\n      }) || s(e.value, e, e => n = e), n();\n    });\n  });\n}\nfunction $t(e, t) {\n  try {\n    const n = Ut(e),\n      r = Ut(t);\n    if (n !== r) return \"Array\" === n ? 1 : \"Array\" === r ? -1 : \"binary\" === n ? 1 : \"binary\" === r ? -1 : \"string\" === n ? 1 : \"string\" === r ? -1 : \"Date\" === n ? 1 : \"Date\" !== r ? NaN : -1;\n    switch (n) {\n      case \"number\":\n      case \"Date\":\n      case \"string\":\n        return e > t ? 1 : e < t ? -1 : 0;\n      case \"binary\":\n        return function (e, t) {\n          const n = e.length,\n            r = t.length,\n            s = n < r ? n : r;\n          for (let n = 0; n < s; ++n) if (e[n] !== t[n]) return e[n] < t[n] ? -1 : 1;\n          return n === r ? 0 : n < r ? -1 : 1;\n        }(Lt(e), Lt(t));\n      case \"Array\":\n        return function (e, t) {\n          const n = e.length,\n            r = t.length,\n            s = n < r ? n : r;\n          for (let n = 0; n < s; ++n) {\n            const r = $t(e[n], t[n]);\n            if (0 !== r) return r;\n          }\n          return n === r ? 0 : n < r ? -1 : 1;\n        }(e, t);\n    }\n  } catch (e) {}\n  return NaN;\n}\nfunction Ut(e) {\n  const t = typeof e;\n  if (\"object\" !== t) return t;\n  if (ArrayBuffer.isView(e)) return \"binary\";\n  const n = C(e);\n  return \"ArrayBuffer\" === n ? \"binary\" : n;\n}\nfunction Lt(e) {\n  return e instanceof Uint8Array ? e : ArrayBuffer.isView(e) ? new Uint8Array(e.buffer, e.byteOffset, e.byteLength) : new Uint8Array(e);\n}\nclass Vt {\n  _read(e, t) {\n    var n = this._ctx;\n    return n.error ? n.table._trans(null, ft.bind(null, n.error)) : n.table._trans(\"readonly\", e).then(t);\n  }\n  _write(e) {\n    var t = this._ctx;\n    return t.error ? t.table._trans(null, ft.bind(null, t.error)) : t.table._trans(\"readwrite\", e, \"locked\");\n  }\n  _addAlgorithm(e) {\n    var t = this._ctx;\n    t.algorithm = St(t.algorithm, e);\n  }\n  _iterate(e, t) {\n    return Nt(this._ctx, e, t, this._ctx.table.core);\n  }\n  clone(e) {\n    var t = Object.create(this.constructor.prototype),\n      n = Object.create(this._ctx);\n    return e && r(n, e), t._ctx = n, t;\n  }\n  raw() {\n    return this._ctx.valueMapper = null, this;\n  }\n  each(e) {\n    var t = this._ctx;\n    return this._read(n => Nt(t, e, n, t.table.core));\n  }\n  count(e) {\n    return this._read(e => {\n      const t = this._ctx,\n        n = t.table.core;\n      if (Bt(t, !0)) return n.count({\n        trans: e,\n        query: {\n          index: Ft(t, n.schema),\n          range: t.range\n        }\n      }).then(e => Math.min(e, t.limit));\n      var r = 0;\n      return Nt(t, () => (++r, !1), e, n).then(() => r);\n    }).then(e);\n  }\n  sortBy(e, t) {\n    const n = e.split(\".\").reverse(),\n      r = n[0],\n      s = n.length - 1;\n    function i(e, t) {\n      return t ? i(e[n[t]], t - 1) : e[r];\n    }\n    var o = \"next\" === this._ctx.dir ? 1 : -1;\n    function a(e, t) {\n      var n = i(e, s),\n        r = i(t, s);\n      return n < r ? -o : n > r ? o : 0;\n    }\n    return this.toArray(function (e) {\n      return e.sort(a);\n    }).then(t);\n  }\n  toArray(e) {\n    return this._read(e => {\n      var t = this._ctx;\n      if (\"next\" === t.dir && Bt(t, !0) && t.limit > 0) {\n        const {\n            valueMapper: n\n          } = t,\n          r = Ft(t, t.table.core.schema);\n        return t.table.core.query({\n          trans: e,\n          limit: t.limit,\n          values: !0,\n          query: {\n            index: r,\n            range: t.range\n          }\n        }).then(_ref5 => {\n          let {\n            result: e\n          } = _ref5;\n          return n ? e.map(n) : e;\n        });\n      }\n      {\n        const n = [];\n        return Nt(t, e => n.push(e), e, t.table.core).then(() => n);\n      }\n    }, e);\n  }\n  offset(e) {\n    var t = this._ctx;\n    return e <= 0 || (t.offset += e, Bt(t) ? Rt(t, () => {\n      var t = e;\n      return (e, n) => 0 === t || (1 === t ? (--t, !1) : (n(() => {\n        e.advance(t), t = 0;\n      }), !1));\n    }) : Rt(t, () => {\n      var t = e;\n      return () => --t < 0;\n    })), this;\n  }\n  limit(e) {\n    return this._ctx.limit = Math.min(this._ctx.limit, e), Rt(this._ctx, () => {\n      var t = e;\n      return function (e, n, r) {\n        return --t <= 0 && n(r), t >= 0;\n      };\n    }, !0), this;\n  }\n  until(e, t) {\n    return Tt(this._ctx, function (n, r, s) {\n      return !e(n.value) || (r(s), t);\n    }), this;\n  }\n  first(e) {\n    return this.limit(1).toArray(function (e) {\n      return e[0];\n    }).then(e);\n  }\n  last(e) {\n    return this.reverse().first(e);\n  }\n  filter(e) {\n    var t, n;\n    return Tt(this._ctx, function (t) {\n      return e(t.value);\n    }), t = this._ctx, n = e, t.isMatch = St(t.isMatch, n), this;\n  }\n  and(e) {\n    return this.filter(e);\n  }\n  or(e) {\n    return new this.db.WhereClause(this._ctx.table, e, this);\n  }\n  reverse() {\n    return this._ctx.dir = \"prev\" === this._ctx.dir ? \"next\" : \"prev\", this._ondirectionchange && this._ondirectionchange(this._ctx.dir), this;\n  }\n  desc() {\n    return this.reverse();\n  }\n  eachKey(e) {\n    var t = this._ctx;\n    return t.keysOnly = !t.isMatch, this.each(function (t, n) {\n      e(n.key, n);\n    });\n  }\n  eachUniqueKey(e) {\n    return this._ctx.unique = \"unique\", this.eachKey(e);\n  }\n  eachPrimaryKey(e) {\n    var t = this._ctx;\n    return t.keysOnly = !t.isMatch, this.each(function (t, n) {\n      e(n.primaryKey, n);\n    });\n  }\n  keys(e) {\n    var t = this._ctx;\n    t.keysOnly = !t.isMatch;\n    var n = [];\n    return this.each(function (e, t) {\n      n.push(t.key);\n    }).then(function () {\n      return n;\n    }).then(e);\n  }\n  primaryKeys(e) {\n    var t = this._ctx;\n    if (\"next\" === t.dir && Bt(t, !0) && t.limit > 0) return this._read(e => {\n      var n = Ft(t, t.table.core.schema);\n      return t.table.core.query({\n        trans: e,\n        values: !1,\n        limit: t.limit,\n        query: {\n          index: n,\n          range: t.range\n        }\n      });\n    }).then(_ref6 => {\n      let {\n        result: e\n      } = _ref6;\n      return e;\n    }).then(e);\n    t.keysOnly = !t.isMatch;\n    var n = [];\n    return this.each(function (e, t) {\n      n.push(t.primaryKey);\n    }).then(function () {\n      return n;\n    }).then(e);\n  }\n  uniqueKeys(e) {\n    return this._ctx.unique = \"unique\", this.keys(e);\n  }\n  firstKey(e) {\n    return this.limit(1).keys(function (e) {\n      return e[0];\n    }).then(e);\n  }\n  lastKey(e) {\n    return this.reverse().firstKey(e);\n  }\n  distinct() {\n    var e = this._ctx,\n      t = e.index && e.table.schema.idxByName[e.index];\n    if (!t || !t.multi) return this;\n    var n = {};\n    return Tt(this._ctx, function (e) {\n      var t = e.primaryKey.toString(),\n        r = o(n, t);\n      return n[t] = !0, !r;\n    }), this;\n  }\n  modify(e) {\n    var n = this._ctx;\n    return this._write(r => {\n      var s;\n      if (\"function\" == typeof e) s = e;else {\n        var i = t(e),\n          o = i.length;\n        s = function (t) {\n          for (var n = !1, r = 0; r < o; ++r) {\n            var s = i[r],\n              a = e[s];\n            b(t, s) !== a && (_(t, s, a), n = !0);\n          }\n          return n;\n        };\n      }\n      const a = n.table.core,\n        {\n          outbound: u,\n          extractKey: l\n        } = a.schema.primaryKey,\n        c = this.db._options.modifyChunkSize || 200,\n        h = [];\n      let d = 0;\n      const f = [],\n        p = (e, n) => {\n          const {\n            failures: r,\n            numFailures: s\n          } = n;\n          d += e - s;\n          for (let e of t(r)) h.push(r[e]);\n        };\n      return this.clone().primaryKeys().then(t => {\n        const i = o => {\n          const h = Math.min(c, t.length - o);\n          return a.getMany({\n            trans: r,\n            keys: t.slice(o, o + h),\n            cache: \"immutable\"\n          }).then(d => {\n            const f = [],\n              y = [],\n              m = u ? [] : null,\n              v = [];\n            for (let e = 0; e < h; ++e) {\n              const n = d[e],\n                r = {\n                  value: O(n),\n                  primKey: t[o + e]\n                };\n              !1 !== s.call(r, r.value, r) && (null == r.value ? v.push(t[o + e]) : u || 0 === $t(l(n), l(r.value)) ? (y.push(r.value), u && m.push(t[o + e])) : (v.push(t[o + e]), f.push(r.value)));\n            }\n            const g = Bt(n) && n.limit === 1 / 0 && (\"function\" != typeof e || e === Wt) && {\n              index: n.index,\n              range: n.range\n            };\n            return Promise.resolve(f.length > 0 && a.mutate({\n              trans: r,\n              type: \"add\",\n              values: f\n            }).then(e => {\n              for (let t in e.failures) v.splice(parseInt(t), 1);\n              p(f.length, e);\n            })).then(() => (y.length > 0 || g && \"object\" == typeof e) && a.mutate({\n              trans: r,\n              type: \"put\",\n              keys: m,\n              values: y,\n              criteria: g,\n              changeSpec: \"function\" != typeof e && e\n            }).then(e => p(y.length, e))).then(() => (v.length > 0 || g && e === Wt) && a.mutate({\n              trans: r,\n              type: \"delete\",\n              keys: v,\n              criteria: g\n            }).then(e => p(v.length, e))).then(() => t.length > o + h && i(o + c));\n          });\n        };\n        return i(0).then(() => {\n          if (h.length > 0) throw new z(\"Error modifying one or more objects\", h, d, f);\n          return t.length;\n        });\n      });\n    });\n  }\n  delete() {\n    var e = this._ctx,\n      t = e.range;\n    return Bt(e) && (e.isPrimKey && !kt || 3 === t.type) ? this._write(n => {\n      const {\n          primaryKey: r\n        } = e.table.core.schema,\n        s = t;\n      return e.table.core.count({\n        trans: n,\n        query: {\n          index: r,\n          range: s\n        }\n      }).then(t => e.table.core.mutate({\n        trans: n,\n        type: \"deleteRange\",\n        range: s\n      }).then(_ref7 => {\n        let {\n          failures: e,\n          lastResult: n,\n          results: r,\n          numFailures: s\n        } = _ref7;\n        if (s) throw new z(\"Could not delete some values\", Object.keys(e).map(t => e[t]), t - s);\n        return t - s;\n      }));\n    }) : this.modify(Wt);\n  }\n}\nconst Wt = (e, t) => t.value = null;\nfunction Yt(e, t) {\n  return e < t ? -1 : e === t ? 0 : 1;\n}\nfunction zt(e, t) {\n  return e > t ? -1 : e === t ? 0 : 1;\n}\nfunction Gt(e, t, n) {\n  var r = e instanceof en ? new e.Collection(e) : e;\n  return r._ctx.error = n ? new n(t) : new TypeError(t), r;\n}\nfunction Ht(e) {\n  return new e.Collection(e, () => Zt(\"\")).limit(0);\n}\nfunction Qt(e, t, n, r, s, i) {\n  for (var o = Math.min(e.length, r.length), a = -1, u = 0; u < o; ++u) {\n    var l = t[u];\n    if (l !== r[u]) return s(e[u], n[u]) < 0 ? e.substr(0, u) + n[u] + n.substr(u + 1) : s(e[u], r[u]) < 0 ? e.substr(0, u) + r[u] + n.substr(u + 1) : a >= 0 ? e.substr(0, a) + t[a] + n.substr(a + 1) : null;\n    s(e[u], l) < 0 && (a = u);\n  }\n  return o < r.length && \"next\" === i ? e + n.substr(e.length) : o < e.length && \"prev\" === i ? e.substr(0, n.length) : a < 0 ? null : e.substr(0, a) + r[a] + n.substr(a + 1);\n}\nfunction Xt(e, t, n, r) {\n  var s,\n    i,\n    o,\n    a,\n    u,\n    l,\n    c,\n    h = n.length;\n  if (!n.every(e => \"string\" == typeof e)) return Gt(e, bt);\n  function d(e) {\n    s = function (e) {\n      return \"next\" === e ? e => e.toUpperCase() : e => e.toLowerCase();\n    }(e), i = function (e) {\n      return \"next\" === e ? e => e.toLowerCase() : e => e.toUpperCase();\n    }(e), o = \"next\" === e ? Yt : zt;\n    var t = n.map(function (e) {\n      return {\n        lower: i(e),\n        upper: s(e)\n      };\n    }).sort(function (e, t) {\n      return o(e.lower, t.lower);\n    });\n    a = t.map(function (e) {\n      return e.upper;\n    }), u = t.map(function (e) {\n      return e.lower;\n    }), l = e, c = \"next\" === e ? \"\" : r;\n  }\n  d(\"next\");\n  var f = new e.Collection(e, () => Jt(a[0], u[h - 1] + r));\n  f._ondirectionchange = function (e) {\n    d(e);\n  };\n  var p = 0;\n  return f._addAlgorithm(function (e, n, r) {\n    var s = e.key;\n    if (\"string\" != typeof s) return !1;\n    var d = i(s);\n    if (t(d, u, p)) return !0;\n    for (var f = null, y = p; y < h; ++y) {\n      var m = Qt(s, d, a[y], u[y], o, l);\n      null === m && null === f ? p = y + 1 : (null === f || o(f, m) > 0) && (f = m);\n    }\n    return n(null !== f ? function () {\n      e.continue(f + c);\n    } : r), !1;\n  }), f;\n}\nfunction Jt(e, t, n, r) {\n  return {\n    type: 2,\n    lower: e,\n    upper: t,\n    lowerOpen: n,\n    upperOpen: r\n  };\n}\nfunction Zt(e) {\n  return {\n    type: 1,\n    lower: e,\n    upper: e\n  };\n}\nclass en {\n  get Collection() {\n    return this._ctx.table.db.Collection;\n  }\n  between(e, t, n, r) {\n    n = !1 !== n, r = !0 === r;\n    try {\n      return this._cmp(e, t) > 0 || 0 === this._cmp(e, t) && (n || r) && (!n || !r) ? Ht(this) : new this.Collection(this, () => Jt(e, t, !n, !r));\n    } catch (e) {\n      return Gt(this, gt);\n    }\n  }\n  equals(e) {\n    return null == e ? Gt(this, gt) : new this.Collection(this, () => Zt(e));\n  }\n  above(e) {\n    return null == e ? Gt(this, gt) : new this.Collection(this, () => Jt(e, void 0, !0));\n  }\n  aboveOrEqual(e) {\n    return null == e ? Gt(this, gt) : new this.Collection(this, () => Jt(e, void 0, !1));\n  }\n  below(e) {\n    return null == e ? Gt(this, gt) : new this.Collection(this, () => Jt(void 0, e, !1, !0));\n  }\n  belowOrEqual(e) {\n    return null == e ? Gt(this, gt) : new this.Collection(this, () => Jt(void 0, e));\n  }\n  startsWith(e) {\n    return \"string\" != typeof e ? Gt(this, bt) : this.between(e, e + mt, !0, !0);\n  }\n  startsWithIgnoreCase(e) {\n    return \"\" === e ? this.startsWith(e) : Xt(this, (e, t) => 0 === e.indexOf(t[0]), [e], mt);\n  }\n  equalsIgnoreCase(e) {\n    return Xt(this, (e, t) => e === t[0], [e], \"\");\n  }\n  anyOfIgnoreCase() {\n    var e = B.apply(I, arguments);\n    return 0 === e.length ? Ht(this) : Xt(this, (e, t) => -1 !== t.indexOf(e), e, \"\");\n  }\n  startsWithAnyOfIgnoreCase() {\n    var e = B.apply(I, arguments);\n    return 0 === e.length ? Ht(this) : Xt(this, (e, t) => t.some(t => 0 === e.indexOf(t)), e, mt);\n  }\n  anyOf() {\n    const e = B.apply(I, arguments);\n    let t = this._cmp;\n    try {\n      e.sort(t);\n    } catch (e) {\n      return Gt(this, gt);\n    }\n    if (0 === e.length) return Ht(this);\n    const n = new this.Collection(this, () => Jt(e[0], e[e.length - 1]));\n    n._ondirectionchange = n => {\n      t = \"next\" === n ? this._ascending : this._descending, e.sort(t);\n    };\n    let r = 0;\n    return n._addAlgorithm((n, s, i) => {\n      const o = n.key;\n      for (; t(o, e[r]) > 0;) if (++r, r === e.length) return s(i), !1;\n      return 0 === t(o, e[r]) || (s(() => {\n        n.continue(e[r]);\n      }), !1);\n    }), n;\n  }\n  notEqual(e) {\n    return this.inAnyRange([[vt, e], [e, this.db._maxKey]], {\n      includeLowers: !1,\n      includeUppers: !1\n    });\n  }\n  noneOf() {\n    const e = B.apply(I, arguments);\n    if (0 === e.length) return new this.Collection(this);\n    try {\n      e.sort(this._ascending);\n    } catch (e) {\n      return Gt(this, gt);\n    }\n    const t = e.reduce((e, t) => e ? e.concat([[e[e.length - 1][1], t]]) : [[vt, t]], null);\n    return t.push([e[e.length - 1], this.db._maxKey]), this.inAnyRange(t, {\n      includeLowers: !1,\n      includeUppers: !1\n    });\n  }\n  inAnyRange(e, t) {\n    const n = this._cmp,\n      r = this._ascending,\n      s = this._descending,\n      i = this._min,\n      o = this._max;\n    if (0 === e.length) return Ht(this);\n    if (!e.every(e => void 0 !== e[0] && void 0 !== e[1] && r(e[0], e[1]) <= 0)) return Gt(this, \"First argument to inAnyRange() must be an Array of two-value Arrays [lower,upper] where upper must not be lower than lower\", X.InvalidArgument);\n    const a = !t || !1 !== t.includeLowers,\n      u = t && !0 === t.includeUppers;\n    let l,\n      c = r;\n    function h(e, t) {\n      return c(e[0], t[0]);\n    }\n    try {\n      l = e.reduce(function (e, t) {\n        let r = 0,\n          s = e.length;\n        for (; r < s; ++r) {\n          const s = e[r];\n          if (n(t[0], s[1]) < 0 && n(t[1], s[0]) > 0) {\n            s[0] = i(s[0], t[0]), s[1] = o(s[1], t[1]);\n            break;\n          }\n        }\n        return r === s && e.push(t), e;\n      }, []), l.sort(h);\n    } catch (e) {\n      return Gt(this, gt);\n    }\n    let d = 0;\n    const f = u ? e => r(e, l[d][1]) > 0 : e => r(e, l[d][1]) >= 0,\n      p = a ? e => s(e, l[d][0]) > 0 : e => s(e, l[d][0]) >= 0;\n    let y = f;\n    const m = new this.Collection(this, () => Jt(l[0][0], l[l.length - 1][1], !a, !u));\n    return m._ondirectionchange = e => {\n      \"next\" === e ? (y = f, c = r) : (y = p, c = s), l.sort(h);\n    }, m._addAlgorithm((e, t, n) => {\n      for (var s = e.key; y(s);) if (++d, d === l.length) return t(n), !1;\n      return !!function (e) {\n        return !f(e) && !p(e);\n      }(s) || (0 === this._cmp(s, l[d][1]) || 0 === this._cmp(s, l[d][0]) || t(() => {\n        c === r ? e.continue(l[d][0]) : e.continue(l[d][1]);\n      }), !1);\n    }), m;\n  }\n  startsWithAnyOf() {\n    const e = B.apply(I, arguments);\n    return e.every(e => \"string\" == typeof e) ? 0 === e.length ? Ht(this) : this.inAnyRange(e.map(e => [e, e + mt])) : Gt(this, \"startsWithAnyOf() only works with strings\");\n  }\n}\nfunction tn(e) {\n  return Ye(function (t) {\n    return nn(t), e(t.target.error), !1;\n  });\n}\nfunction nn(e) {\n  e.stopPropagation && e.stopPropagation(), e.preventDefault && e.preventDefault();\n}\nconst rn = \"storagemutated\",\n  sn = \"x-storagemutated-1\",\n  on = Dt(null, rn);\nclass an {\n  _lock() {\n    return m(!Oe.global), ++this._reculock, 1 !== this._reculock || Oe.global || (Oe.lockOwnerFor = this), this;\n  }\n  _unlock() {\n    if (m(!Oe.global), 0 == --this._reculock) for (Oe.global || (Oe.lockOwnerFor = null); this._blockedFuncs.length > 0 && !this._locked();) {\n      var e = this._blockedFuncs.shift();\n      try {\n        at(e[1], e[0]);\n      } catch (e) {}\n    }\n    return this;\n  }\n  _locked() {\n    return this._reculock && Oe.lockOwnerFor !== this;\n  }\n  create(e) {\n    if (!this.mode) return this;\n    const t = this.db.idbdb,\n      n = this.db._state.dbOpenError;\n    if (m(!this.idbtrans), !e && !t) switch (n && n.name) {\n      case \"DatabaseClosedError\":\n        throw new X.DatabaseClosed(n);\n      case \"MissingAPIError\":\n        throw new X.MissingAPI(n.message, n);\n      default:\n        throw new X.OpenFailed(n);\n    }\n    if (!this.active) throw new X.TransactionInactive();\n    return m(null === this._completion._state), (e = this.idbtrans = e || (this.db.core ? this.db.core.transaction(this.storeNames, this.mode, {\n      durability: this.chromeTransactionDurability\n    }) : t.transaction(this.storeNames, this.mode, {\n      durability: this.chromeTransactionDurability\n    }))).onerror = Ye(t => {\n      nn(t), this._reject(e.error);\n    }), e.onabort = Ye(t => {\n      nn(t), this.active && this._reject(new X.Abort(e.error)), this.active = !1, this.on(\"abort\").fire(t);\n    }), e.oncomplete = Ye(() => {\n      this.active = !1, this._resolve(), \"mutatedParts\" in e && on.storagemutated.fire(e.mutatedParts);\n    }), this;\n  }\n  _promise(e, t, n) {\n    if (\"readwrite\" === e && \"readwrite\" !== this.mode) return ft(new X.ReadOnly(\"Transaction is readonly\"));\n    if (!this.active) return ft(new X.TransactionInactive());\n    if (this._locked()) return new je((r, s) => {\n      this._blockedFuncs.push([() => {\n        this._promise(e, t, n).then(r, s);\n      }, Oe]);\n    });\n    if (n) return Ze(() => {\n      var e = new je((e, n) => {\n        this._lock();\n        const r = t(e, n, this);\n        r && r.then && r.then(e, n);\n      });\n      return e.finally(() => this._unlock()), e._lib = !0, e;\n    });\n    var r = new je((e, n) => {\n      var r = t(e, n, this);\n      r && r.then && r.then(e, n);\n    });\n    return r._lib = !0, r;\n  }\n  _root() {\n    return this.parent ? this.parent._root() : this;\n  }\n  waitFor(e) {\n    var t = this._root();\n    const n = je.resolve(e);\n    if (t._waitingFor) t._waitingFor = t._waitingFor.then(() => n);else {\n      t._waitingFor = n, t._waitingQueue = [];\n      var r = t.idbtrans.objectStore(t.storeNames[0]);\n      !function e() {\n        for (++t._spinCount; t._waitingQueue.length;) t._waitingQueue.shift()();\n        t._waitingFor && (r.get(-1 / 0).onsuccess = e);\n      }();\n    }\n    var s = t._waitingFor;\n    return new je((e, r) => {\n      n.then(n => t._waitingQueue.push(Ye(e.bind(null, n))), e => t._waitingQueue.push(Ye(r.bind(null, e)))).finally(() => {\n        t._waitingFor === s && (t._waitingFor = null);\n      });\n    });\n  }\n  abort() {\n    this.active && (this.active = !1, this.idbtrans && this.idbtrans.abort(), this._reject(new X.Abort()));\n  }\n  table(e) {\n    const t = this._memoizedTables || (this._memoizedTables = {});\n    if (o(t, e)) return t[e];\n    const n = this.schema[e];\n    if (!n) throw new X.NotFound(\"Table \" + e + \" not part of transaction\");\n    const r = new this.db.Table(e, n, this);\n    return r.core = this.db.core.table(e), t[e] = r, r;\n  }\n}\nfunction un(e, t, n, r, s, i, o) {\n  return {\n    name: e,\n    keyPath: t,\n    unique: n,\n    multi: r,\n    auto: s,\n    compound: i,\n    src: (n && !o ? \"&\" : \"\") + (r ? \"*\" : \"\") + (s ? \"++\" : \"\") + ln(t)\n  };\n}\nfunction ln(e) {\n  return \"string\" == typeof e ? e : e ? \"[\" + [].join.call(e, \"+\") + \"]\" : \"\";\n}\nfunction cn(e, t, n) {\n  return {\n    name: e,\n    primKey: t,\n    indexes: n,\n    mappedClass: null,\n    idxByName: g(n, e => [e.name, e])\n  };\n}\nlet hn = e => {\n  try {\n    return e.only([[]]), hn = () => [[]], [[]];\n  } catch (e) {\n    return hn = () => mt, mt;\n  }\n};\nfunction dn(e) {\n  return null == e ? () => {} : \"string\" == typeof e ? function (e) {\n    const t = e.split(\".\");\n    return 1 === t.length ? t => t[e] : t => b(t, e);\n  }(e) : t => b(t, e);\n}\nfunction fn(e) {\n  return [].slice.call(e);\n}\nlet pn = 0;\nfunction yn(e) {\n  return null == e ? \":id\" : \"string\" == typeof e ? e : \"[\".concat(e.join(\"+\"), \"]\");\n}\nfunction mn(e, t, r) {\n  function s(e) {\n    if (3 === e.type) return null;\n    if (4 === e.type) throw new Error(\"Cannot convert never type to IDBKeyRange\");\n    const {\n      lower: n,\n      upper: r,\n      lowerOpen: s,\n      upperOpen: i\n    } = e;\n    return void 0 === n ? void 0 === r ? null : t.upperBound(r, !!i) : void 0 === r ? t.lowerBound(n, !!s) : t.bound(n, r, !!s, !!i);\n  }\n  const {\n      schema: i,\n      hasGetAll: o\n    } = function (e, t) {\n      const r = fn(e.objectStoreNames);\n      return {\n        schema: {\n          name: e.name,\n          tables: r.map(e => t.objectStore(e)).map(e => {\n            const {\n                keyPath: t,\n                autoIncrement: r\n              } = e,\n              s = n(t),\n              i = null == t,\n              o = {},\n              a = {\n                name: e.name,\n                primaryKey: {\n                  name: null,\n                  isPrimaryKey: !0,\n                  outbound: i,\n                  compound: s,\n                  keyPath: t,\n                  autoIncrement: r,\n                  unique: !0,\n                  extractKey: dn(t)\n                },\n                indexes: fn(e.indexNames).map(t => e.index(t)).map(e => {\n                  const {\n                      name: t,\n                      unique: r,\n                      multiEntry: s,\n                      keyPath: i\n                    } = e,\n                    a = {\n                      name: t,\n                      compound: n(i),\n                      keyPath: i,\n                      unique: r,\n                      multiEntry: s,\n                      extractKey: dn(i)\n                    };\n                  return o[yn(i)] = a, a;\n                }),\n                getIndexByKeyPath: e => o[yn(e)]\n              };\n            return o[\":id\"] = a.primaryKey, null != t && (o[yn(t)] = a.primaryKey), a;\n          })\n        },\n        hasGetAll: r.length > 0 && \"getAll\" in t.objectStore(r[0]) && !(\"undefined\" != typeof navigator && /Safari/.test(navigator.userAgent) && !/(Chrome\\/|Edge\\/)/.test(navigator.userAgent) && [].concat(navigator.userAgent.match(/Safari\\/(\\d*)/))[1] < 604)\n      };\n    }(e, r),\n    a = i.tables.map(e => function (e) {\n      const t = e.name;\n      return {\n        name: t,\n        schema: e,\n        mutate: function (_ref8) {\n          let {\n            trans: e,\n            type: n,\n            keys: r,\n            values: i,\n            range: o\n          } = _ref8;\n          return new Promise((a, u) => {\n            a = Ye(a);\n            const l = e.objectStore(t),\n              c = null == l.keyPath,\n              h = \"put\" === n || \"add\" === n;\n            if (!h && \"delete\" !== n && \"deleteRange\" !== n) throw new Error(\"Invalid operation type: \" + n);\n            const {\n              length: d\n            } = r || i || {\n              length: 1\n            };\n            if (r && i && r.length !== i.length) throw new Error(\"Given keys array must have same length as given values array.\");\n            if (0 === d) return a({\n              numFailures: 0,\n              failures: {},\n              results: [],\n              lastResult: void 0\n            });\n            let f;\n            const p = [],\n              y = [];\n            let m = 0;\n            const v = e => {\n              ++m, nn(e);\n            };\n            if (\"deleteRange\" === n) {\n              if (4 === o.type) return a({\n                numFailures: m,\n                failures: y,\n                results: [],\n                lastResult: void 0\n              });\n              3 === o.type ? p.push(f = l.clear()) : p.push(f = l.delete(s(o)));\n            } else {\n              const [e, t] = h ? c ? [i, r] : [i, null] : [r, null];\n              if (h) for (let r = 0; r < d; ++r) p.push(f = t && void 0 !== t[r] ? l[n](e[r], t[r]) : l[n](e[r])), f.onerror = v;else for (let t = 0; t < d; ++t) p.push(f = l[n](e[t])), f.onerror = v;\n            }\n            const g = e => {\n              const t = e.target.result;\n              p.forEach((e, t) => null != e.error && (y[t] = e.error)), a({\n                numFailures: m,\n                failures: y,\n                results: \"delete\" === n ? r : p.map(e => e.result),\n                lastResult: t\n              });\n            };\n            f.onerror = e => {\n              v(e), g(e);\n            }, f.onsuccess = g;\n          });\n        },\n        getMany: _ref9 => {\n          let {\n            trans: e,\n            keys: n\n          } = _ref9;\n          return new Promise((r, s) => {\n            r = Ye(r);\n            const i = e.objectStore(t),\n              o = n.length,\n              a = new Array(o);\n            let u,\n              l = 0,\n              c = 0;\n            const h = e => {\n                const t = e.target;\n                a[t._pos] = t.result, ++c === l && r(a);\n              },\n              d = tn(s);\n            for (let e = 0; e < o; ++e) null != n[e] && (u = i.get(n[e]), u._pos = e, u.onsuccess = h, u.onerror = d, ++l);\n            0 === l && r(a);\n          });\n        },\n        get: _ref0 => {\n          let {\n            trans: e,\n            key: n\n          } = _ref0;\n          return new Promise((r, s) => {\n            r = Ye(r);\n            const i = e.objectStore(t).get(n);\n            i.onsuccess = e => r(e.target.result), i.onerror = tn(s);\n          });\n        },\n        query: function (e) {\n          return n => new Promise((r, i) => {\n            r = Ye(r);\n            const {\n                trans: o,\n                values: a,\n                limit: u,\n                query: l\n              } = n,\n              c = u === 1 / 0 ? void 0 : u,\n              {\n                index: h,\n                range: d\n              } = l,\n              f = o.objectStore(t),\n              p = h.isPrimaryKey ? f : f.index(h.name),\n              y = s(d);\n            if (0 === u) return r({\n              result: []\n            });\n            if (e) {\n              const e = a ? p.getAll(y, c) : p.getAllKeys(y, c);\n              e.onsuccess = e => r({\n                result: e.target.result\n              }), e.onerror = tn(i);\n            } else {\n              let e = 0;\n              const t = a || !(\"openKeyCursor\" in p) ? p.openCursor(y) : p.openKeyCursor(y),\n                n = [];\n              t.onsuccess = s => {\n                const i = t.result;\n                return i ? (n.push(a ? i.value : i.primaryKey), ++e === u ? r({\n                  result: n\n                }) : void i.continue()) : r({\n                  result: n\n                });\n              }, t.onerror = tn(i);\n            }\n          });\n        }(o),\n        openCursor: function (_ref1) {\n          let {\n            trans: e,\n            values: n,\n            query: r,\n            reverse: i,\n            unique: o\n          } = _ref1;\n          return new Promise((a, u) => {\n            a = Ye(a);\n            const {\n                index: l,\n                range: c\n              } = r,\n              h = e.objectStore(t),\n              d = l.isPrimaryKey ? h : h.index(l.name),\n              f = i ? o ? \"prevunique\" : \"prev\" : o ? \"nextunique\" : \"next\",\n              p = n || !(\"openKeyCursor\" in d) ? d.openCursor(s(c), f) : d.openKeyCursor(s(c), f);\n            p.onerror = tn(u), p.onsuccess = Ye(t => {\n              const n = p.result;\n              if (!n) return void a(null);\n              n.___id = ++pn, n.done = !1;\n              const r = n.continue.bind(n);\n              let s = n.continuePrimaryKey;\n              s && (s = s.bind(n));\n              const i = n.advance.bind(n),\n                o = () => {\n                  throw new Error(\"Cursor not stopped\");\n                };\n              n.trans = e, n.stop = n.continue = n.continuePrimaryKey = n.advance = () => {\n                throw new Error(\"Cursor not started\");\n              }, n.fail = Ye(u), n.next = function () {\n                let e = 1;\n                return this.start(() => e-- ? this.continue() : this.stop()).then(() => this);\n              }, n.start = e => {\n                const t = new Promise((e, t) => {\n                    e = Ye(e), p.onerror = tn(t), n.fail = t, n.stop = t => {\n                      n.stop = n.continue = n.continuePrimaryKey = n.advance = o, e(t);\n                    };\n                  }),\n                  a = () => {\n                    if (p.result) try {\n                      e();\n                    } catch (e) {\n                      n.fail(e);\n                    } else n.done = !0, n.start = () => {\n                      throw new Error(\"Cursor behind last entry\");\n                    }, n.stop();\n                  };\n                return p.onsuccess = Ye(e => {\n                  p.onsuccess = a, a();\n                }), n.continue = r, n.continuePrimaryKey = s, n.advance = i, a(), t;\n              }, a(n);\n            }, u);\n          });\n        },\n        count(_ref10) {\n          let {\n            query: e,\n            trans: n\n          } = _ref10;\n          const {\n            index: r,\n            range: i\n          } = e;\n          return new Promise((e, o) => {\n            const a = n.objectStore(t),\n              u = r.isPrimaryKey ? a : a.index(r.name),\n              l = s(i),\n              c = l ? u.count(l) : u.count();\n            c.onsuccess = Ye(t => e(t.target.result)), c.onerror = tn(o);\n          });\n        }\n      };\n    }(e)),\n    u = {};\n  return a.forEach(e => u[e.name] = e), {\n    stack: \"dbcore\",\n    transaction: e.transaction.bind(e),\n    table(e) {\n      if (!u[e]) throw new Error(\"Table '\".concat(e, \"' not found\"));\n      return u[e];\n    },\n    MIN_KEY: -1 / 0,\n    MAX_KEY: hn(t),\n    schema: i\n  };\n}\nfunction vn(_ref11, t) {\n  let {\n    _novip: e\n  } = _ref11;\n  const n = t.db,\n    r = function (e, t, _ref12, s) {\n      let {\n        IDBKeyRange: n,\n        indexedDB: r\n      } = _ref12;\n      const i = function (e, t) {\n        return t.reduce((e, _ref13) => {\n          let {\n            create: t\n          } = _ref13;\n          return _objectSpread(_objectSpread({}, e), t(e));\n        }, e);\n      }(mn(t, n, s), e.dbcore);\n      return {\n        dbcore: i\n      };\n    }(e._middlewares, n, e._deps, t);\n  e.core = r.dbcore, e.tables.forEach(t => {\n    const n = t.name;\n    e.core.schema.tables.some(e => e.name === n) && (t.core = e.core.table(n), e[n] instanceof e.Table && (e[n].core = t.core));\n  });\n}\nfunction gn(_ref14, t, n, r) {\n  let {\n    _novip: e\n  } = _ref14;\n  n.forEach(n => {\n    const s = r[n];\n    t.forEach(t => {\n      const r = d(t, n);\n      (!r || \"value\" in r && void 0 === r.value) && (t === e.Transaction.prototype || t instanceof e.Transaction ? l(t, n, {\n        get() {\n          return this.table(n);\n        },\n        set(e) {\n          u(this, n, {\n            value: e,\n            writable: !0,\n            configurable: !0,\n            enumerable: !0\n          });\n        }\n      }) : t[n] = new e.Table(n, s));\n    });\n  });\n}\nfunction bn(_ref15, t) {\n  let {\n    _novip: e\n  } = _ref15;\n  t.forEach(t => {\n    for (let n in t) t[n] instanceof e.Table && delete t[n];\n  });\n}\nfunction _n(e, t) {\n  return e._cfg.version - t._cfg.version;\n}\nfunction wn(e, n, r, s) {\n  const i = e._dbSchema,\n    o = e._createTransaction(\"readwrite\", e._storeNames, i);\n  o.create(r), o._completion.catch(s);\n  const a = o._reject.bind(o),\n    u = Oe.transless || Oe;\n  Ze(() => {\n    Oe.trans = o, Oe.transless = u, 0 === n ? (t(i).forEach(e => {\n      kn(r, e, i[e].primKey, i[e].indexes);\n    }), vn(e, r), je.follow(() => e.on.populate.fire(o)).catch(a)) : function (_ref16, n, r, s) {\n      let {\n        _novip: e\n      } = _ref16;\n      const i = [],\n        o = e._versions;\n      let a = e._dbSchema = Pn(e, e.idbdb, s),\n        u = !1;\n      const l = o.filter(e => e._cfg.version >= n);\n      function c() {\n        return i.length ? je.resolve(i.shift()(r.idbtrans)).then(c) : je.resolve();\n      }\n      return l.forEach(o => {\n        i.push(() => {\n          const i = a,\n            l = o._cfg.dbschema;\n          Kn(e, i, s), Kn(e, l, s), a = e._dbSchema = l;\n          const c = xn(i, l);\n          c.add.forEach(e => {\n            kn(s, e[0], e[1].primKey, e[1].indexes);\n          }), c.change.forEach(e => {\n            if (e.recreate) throw new X.Upgrade(\"Not yet support for changing primary key\");\n            {\n              const t = s.objectStore(e.name);\n              e.add.forEach(e => En(t, e)), e.change.forEach(e => {\n                t.deleteIndex(e.name), En(t, e);\n              }), e.del.forEach(e => t.deleteIndex(e));\n            }\n          });\n          const h = o._cfg.contentUpgrade;\n          if (h && o._cfg.version > n) {\n            vn(e, s), r._memoizedTables = {}, u = !0;\n            let n = w(l);\n            c.del.forEach(e => {\n              n[e] = i[e];\n            }), bn(e, [e.Transaction.prototype]), gn(e, [e.Transaction.prototype], t(n), n), r.schema = n;\n            const o = T(h);\n            let a;\n            o && et();\n            const d = je.follow(() => {\n              if (a = h(r), a && o) {\n                var e = tt.bind(null, null);\n                a.then(e, e);\n              }\n            });\n            return a && \"function\" == typeof a.then ? je.resolve(a) : d.then(() => a);\n          }\n        }), i.push(t => {\n          if (!u || !xt) {\n            !function (e, t) {\n              [].slice.call(t.db.objectStoreNames).forEach(n => null == e[n] && t.db.deleteObjectStore(n));\n            }(o._cfg.dbschema, t);\n          }\n          bn(e, [e.Transaction.prototype]), gn(e, [e.Transaction.prototype], e._storeNames, e._dbSchema), r.schema = e._dbSchema;\n        });\n      }), c().then(() => {\n        var e, n;\n        n = s, t(e = a).forEach(t => {\n          n.db.objectStoreNames.contains(t) || kn(n, t, e[t].primKey, e[t].indexes);\n        });\n      });\n    }(e, n, o, r).catch(a);\n  });\n}\nfunction xn(e, t) {\n  const n = {\n    del: [],\n    add: [],\n    change: []\n  };\n  let r;\n  for (r in e) t[r] || n.del.push(r);\n  for (r in t) {\n    const s = e[r],\n      i = t[r];\n    if (s) {\n      const e = {\n        name: r,\n        def: i,\n        recreate: !1,\n        del: [],\n        add: [],\n        change: []\n      };\n      if (\"\" + (s.primKey.keyPath || \"\") != \"\" + (i.primKey.keyPath || \"\") || s.primKey.auto !== i.primKey.auto && !wt) e.recreate = !0, n.change.push(e);else {\n        const t = s.idxByName,\n          r = i.idxByName;\n        let o;\n        for (o in t) r[o] || e.del.push(o);\n        for (o in r) {\n          const n = t[o],\n            s = r[o];\n          n ? n.src !== s.src && e.change.push(s) : e.add.push(s);\n        }\n        (e.del.length > 0 || e.add.length > 0 || e.change.length > 0) && n.change.push(e);\n      }\n    } else n.add.push([r, i]);\n  }\n  return n;\n}\nfunction kn(e, t, n, r) {\n  const s = e.db.createObjectStore(t, n.keyPath ? {\n    keyPath: n.keyPath,\n    autoIncrement: n.auto\n  } : {\n    autoIncrement: n.auto\n  });\n  return r.forEach(e => En(s, e)), s;\n}\nfunction En(e, t) {\n  e.createIndex(t.name, t.keyPath, {\n    unique: t.unique,\n    multiEntry: t.multi\n  });\n}\nfunction Pn(e, t, n) {\n  const r = {};\n  return p(t.objectStoreNames, 0).forEach(e => {\n    const t = n.objectStore(e);\n    let s = t.keyPath;\n    const i = un(ln(s), s || \"\", !1, !1, !!t.autoIncrement, s && \"string\" != typeof s, !0),\n      o = [];\n    for (let e = 0; e < t.indexNames.length; ++e) {\n      const n = t.index(t.indexNames[e]);\n      s = n.keyPath;\n      var a = un(n.name, s, !!n.unique, !!n.multiEntry, !1, s && \"string\" != typeof s, !1);\n      o.push(a);\n    }\n    r[e] = cn(e, i, o);\n  }), r;\n}\nfunction Kn(_ref17, n, r) {\n  let {\n    _novip: t\n  } = _ref17;\n  const s = r.db.objectStoreNames;\n  for (let e = 0; e < s.length; ++e) {\n    const i = s[e],\n      o = r.objectStore(i);\n    t._hasGetAll = \"getAll\" in o;\n    for (let e = 0; e < o.indexNames.length; ++e) {\n      const t = o.indexNames[e],\n        r = o.index(t).keyPath,\n        s = \"string\" == typeof r ? r : \"[\" + p(r).join(\"+\") + \"]\";\n      if (n[i]) {\n        const e = n[i].idxByName[s];\n        e && (e.name = t, delete n[i].idxByName[s], n[i].idxByName[t] = e);\n      }\n    }\n  }\n  \"undefined\" != typeof navigator && /Safari/.test(navigator.userAgent) && !/(Chrome\\/|Edge\\/)/.test(navigator.userAgent) && e.WorkerGlobalScope && e instanceof e.WorkerGlobalScope && [].concat(navigator.userAgent.match(/Safari\\/(\\d*)/))[1] < 604 && (t._hasGetAll = !1);\n}\nclass On {\n  _parseStoresSpec(e, r) {\n    t(e).forEach(t => {\n      if (null !== e[t]) {\n        var s = e[t].split(\",\").map((e, t) => {\n            const r = (e = e.trim()).replace(/([&*]|\\+\\+)/g, \"\"),\n              s = /^\\[/.test(r) ? r.match(/^\\[(.*)\\]$/)[1].split(\"+\") : r;\n            return un(r, s || null, /\\&/.test(e), /\\*/.test(e), /\\+\\+/.test(e), n(s), 0 === t);\n          }),\n          i = s.shift();\n        if (i.multi) throw new X.Schema(\"Primary key cannot be multi-valued\");\n        s.forEach(e => {\n          if (e.auto) throw new X.Schema(\"Only primary key can be marked as autoIncrement (++)\");\n          if (!e.keyPath) throw new X.Schema(\"Index must have a name and cannot be an empty string\");\n        }), r[t] = cn(t, i, s);\n      }\n    });\n  }\n  stores(e) {\n    const n = this.db;\n    this._cfg.storesSource = this._cfg.storesSource ? r(this._cfg.storesSource, e) : e;\n    const s = n._versions,\n      i = {};\n    let o = {};\n    return s.forEach(e => {\n      r(i, e._cfg.storesSource), o = e._cfg.dbschema = {}, e._parseStoresSpec(i, o);\n    }), n._dbSchema = o, bn(n, [n._allTables, n, n.Transaction.prototype]), gn(n, [n._allTables, n, n.Transaction.prototype, this._cfg.tables], t(o), o), n._storeNames = t(o), this;\n  }\n  upgrade(e) {\n    return this._cfg.contentUpgrade = ue(this._cfg.contentUpgrade || ee, e), this;\n  }\n}\nfunction Sn(e, t) {\n  let n = e._dbNamesDB;\n  return n || (n = e._dbNamesDB = new Xn(Pt, {\n    addons: [],\n    indexedDB: e,\n    IDBKeyRange: t\n  }), n.version(1).stores({\n    dbnames: \"name\"\n  })), n.table(\"dbnames\");\n}\nfunction An(e) {\n  return e && \"function\" == typeof e.databases;\n}\nfunction Cn(e) {\n  return Ze(function () {\n    return Oe.letThrough = !0, e();\n  });\n}\nfunction jn() {\n  var e;\n  return !navigator.userAgentData && /Safari\\//.test(navigator.userAgent) && !/Chrom(e|ium)\\//.test(navigator.userAgent) && indexedDB.databases ? new Promise(function (t) {\n    var n = function () {\n      return indexedDB.databases().finally(t);\n    };\n    e = setInterval(n, 100), n();\n  }).finally(function () {\n    return clearInterval(e);\n  }) : Promise.resolve();\n}\nfunction Dn(e) {\n  const n = e._state,\n    {\n      indexedDB: r\n    } = e._deps;\n  if (n.isBeingOpened || e.idbdb) return n.dbReadyPromise.then(() => n.dbOpenError ? ft(n.dbOpenError) : e);\n  R && (n.openCanceller._stackHolder = q()), n.isBeingOpened = !0, n.dbOpenError = null, n.openComplete = !1;\n  const s = n.openCanceller;\n  function i() {\n    if (n.openCanceller !== s) throw new X.DatabaseClosed(\"db.open() was cancelled\");\n  }\n  let o = n.dbReadyResolve,\n    a = null,\n    u = !1;\n  const l = () => new je((s, o) => {\n    if (i(), !r) throw new X.MissingAPI();\n    const l = e.name,\n      c = n.autoSchema ? r.open(l) : r.open(l, Math.round(10 * e.verno));\n    if (!c) throw new X.MissingAPI();\n    c.onerror = tn(o), c.onblocked = Ye(e._fireOnBlocked), c.onupgradeneeded = Ye(t => {\n      if (a = c.transaction, n.autoSchema && !e._options.allowEmptyDB) {\n        c.onerror = nn, a.abort(), c.result.close();\n        const e = r.deleteDatabase(l);\n        e.onsuccess = e.onerror = Ye(() => {\n          o(new X.NoSuchDatabase(\"Database \".concat(l, \" doesnt exist\")));\n        });\n      } else {\n        a.onerror = tn(o);\n        var s = t.oldVersion > Math.pow(2, 62) ? 0 : t.oldVersion;\n        u = s < 1, e._novip.idbdb = c.result, wn(e, s / 10, a, o);\n      }\n    }, o), c.onsuccess = Ye(() => {\n      a = null;\n      const r = e._novip.idbdb = c.result,\n        i = p(r.objectStoreNames);\n      if (i.length > 0) try {\n        const s = r.transaction(1 === (o = i).length ? o[0] : o, \"readonly\");\n        n.autoSchema ? function (_ref18, n, r) {\n          let {\n            _novip: e\n          } = _ref18;\n          e.verno = n.version / 10;\n          const s = e._dbSchema = Pn(0, n, r);\n          e._storeNames = p(n.objectStoreNames, 0), gn(e, [e._allTables], t(s), s);\n        }(e, r, s) : (Kn(e, e._dbSchema, s), function (e, t) {\n          const n = xn(Pn(0, e.idbdb, t), e._dbSchema);\n          return !(n.add.length || n.change.some(e => e.add.length || e.change.length));\n        }(e, s) || console.warn(\"Dexie SchemaDiff: Schema was extended without increasing the number passed to db.version(). Some queries may fail.\")), vn(e, s);\n      } catch (e) {}\n      var o;\n      _t.push(e), r.onversionchange = Ye(t => {\n        n.vcFired = !0, e.on(\"versionchange\").fire(t);\n      }), r.onclose = Ye(t => {\n        e.on(\"close\").fire(t);\n      }), u && function (_ref19, n) {\n        let {\n          indexedDB: e,\n          IDBKeyRange: t\n        } = _ref19;\n        !An(e) && n !== Pt && Sn(e, t).put({\n          name: n\n        }).catch(ee);\n      }(e._deps, l), s();\n    }, o);\n  }).catch(e => e && \"UnknownError\" === e.name && n.PR1398_maxLoop > 0 ? (n.PR1398_maxLoop--, console.warn(\"Dexie: Workaround for Chrome UnknownError on open()\"), l()) : je.reject(e));\n  return je.race([s, (\"undefined\" == typeof navigator ? je.resolve() : jn()).then(l)]).then(() => (i(), n.onReadyBeingFired = [], je.resolve(Cn(() => e.on.ready.fire(e.vip))).then(function t() {\n    if (n.onReadyBeingFired.length > 0) {\n      let r = n.onReadyBeingFired.reduce(ue, ee);\n      return n.onReadyBeingFired = [], je.resolve(Cn(() => r(e.vip))).then(t);\n    }\n  }))).finally(() => {\n    n.onReadyBeingFired = null, n.isBeingOpened = !1;\n  }).then(() => e).catch(t => {\n    n.dbOpenError = t;\n    try {\n      a && a.abort();\n    } catch (e) {}\n    return s === n.openCanceller && e._close(), ft(t);\n  }).finally(() => {\n    n.openComplete = !0, o();\n  });\n}\nfunction In(e) {\n  var t = t => e.next(t),\n    r = i(t),\n    s = i(t => e.throw(t));\n  function i(e) {\n    return t => {\n      var i = e(t),\n        o = i.value;\n      return i.done ? o : o && \"function\" == typeof o.then ? o.then(r, s) : n(o) ? Promise.all(o).then(r, s) : r(o);\n    };\n  }\n  return i(t)();\n}\nfunction Bn(e, t, n) {\n  var r = arguments.length;\n  if (r < 2) throw new X.InvalidArgument(\"Too few arguments\");\n  for (var s = new Array(r - 1); --r;) s[r - 1] = arguments[r];\n  return n = s.pop(), [e, k(s), n];\n}\nfunction Tn(e, t, n, r, s) {\n  return je.resolve().then(() => {\n    const i = Oe.transless || Oe,\n      o = e._createTransaction(t, n, e._dbSchema, r),\n      a = {\n        trans: o,\n        transless: i\n      };\n    if (r) o.idbtrans = r.idbtrans;else try {\n      o.create(), e._state.PR1398_maxLoop = 3;\n    } catch (r) {\n      return r.name === H.InvalidState && e.isOpen() && --e._state.PR1398_maxLoop > 0 ? (console.warn(\"Dexie: Need to reopen db\"), e._close(), e.open().then(() => Tn(e, t, n, null, s))) : ft(r);\n    }\n    const u = T(s);\n    let l;\n    u && et();\n    const c = je.follow(() => {\n      if (l = s.call(o, o), l) if (u) {\n        var e = tt.bind(null, null);\n        l.then(e, e);\n      } else \"function\" == typeof l.next && \"function\" == typeof l.throw && (l = In(l));\n    }, a);\n    return (l && \"function\" == typeof l.then ? je.resolve(l).then(e => o.active ? e : ft(new X.PrematureCommit(\"Transaction committed too early. See http://bit.ly/2kdckMn\"))) : c.then(() => l)).then(e => (r && o._resolve(), o._completion.then(() => e))).catch(e => (o._reject(e), ft(e)));\n  });\n}\nfunction Rn(e, t, r) {\n  const s = n(e) ? e.slice() : [e];\n  for (let e = 0; e < r; ++e) s.push(t);\n  return s;\n}\nconst Fn = {\n  stack: \"dbcore\",\n  name: \"VirtualIndexMiddleware\",\n  level: 1,\n  create: function (e) {\n    return _objectSpread(_objectSpread({}, e), {}, {\n      table(t) {\n        const n = e.table(t),\n          {\n            schema: r\n          } = n,\n          s = {},\n          i = [];\n        function o(e, t, n) {\n          const r = yn(e),\n            a = s[r] = s[r] || [],\n            u = null == e ? 0 : \"string\" == typeof e ? 1 : e.length,\n            l = t > 0,\n            c = _objectSpread(_objectSpread({}, n), {}, {\n              isVirtual: l,\n              keyTail: t,\n              keyLength: u,\n              extractKey: dn(e),\n              unique: !l && n.unique\n            });\n          if (a.push(c), c.isPrimaryKey || i.push(c), u > 1) {\n            o(2 === u ? e[0] : e.slice(0, u - 1), t + 1, n);\n          }\n          return a.sort((e, t) => e.keyTail - t.keyTail), c;\n        }\n        const a = o(r.primaryKey.keyPath, 0, r.primaryKey);\n        s[\":id\"] = [a];\n        for (const e of r.indexes) o(e.keyPath, 0, e);\n        function u(t) {\n          const n = t.query.index;\n          return n.isVirtual ? _objectSpread(_objectSpread({}, t), {}, {\n            query: {\n              index: n,\n              range: (r = t.query.range, s = n.keyTail, {\n                type: 1 === r.type ? 2 : r.type,\n                lower: Rn(r.lower, r.lowerOpen ? e.MAX_KEY : e.MIN_KEY, s),\n                lowerOpen: !0,\n                upper: Rn(r.upper, r.upperOpen ? e.MIN_KEY : e.MAX_KEY, s),\n                upperOpen: !0\n              })\n            }\n          }) : t;\n          var r, s;\n        }\n        const l = _objectSpread(_objectSpread({}, n), {}, {\n          schema: _objectSpread(_objectSpread({}, r), {}, {\n            primaryKey: a,\n            indexes: i,\n            getIndexByKeyPath: function (e) {\n              const t = s[yn(e)];\n              return t && t[0];\n            }\n          }),\n          count: e => n.count(u(e)),\n          query: e => n.query(u(e)),\n          openCursor(t) {\n            const {\n              keyTail: r,\n              isVirtual: s,\n              keyLength: i\n            } = t.query.index;\n            if (!s) return n.openCursor(t);\n            return n.openCursor(u(t)).then(n => n && function (n) {\n              const s = Object.create(n, {\n                continue: {\n                  value: function (s) {\n                    null != s ? n.continue(Rn(s, t.reverse ? e.MAX_KEY : e.MIN_KEY, r)) : t.unique ? n.continue(n.key.slice(0, i).concat(t.reverse ? e.MIN_KEY : e.MAX_KEY, r)) : n.continue();\n                  }\n                },\n                continuePrimaryKey: {\n                  value(t, s) {\n                    n.continuePrimaryKey(Rn(t, e.MAX_KEY, r), s);\n                  }\n                },\n                primaryKey: {\n                  get: () => n.primaryKey\n                },\n                key: {\n                  get() {\n                    const e = n.key;\n                    return 1 === i ? e[0] : e.slice(0, i);\n                  }\n                },\n                value: {\n                  get: () => n.value\n                }\n              });\n              return s;\n            }(n));\n          }\n        });\n        return l;\n      }\n    });\n  }\n};\nfunction Mn(e, n, r, s) {\n  return r = r || {}, s = s || \"\", t(e).forEach(t => {\n    if (o(n, t)) {\n      var i = e[t],\n        a = n[t];\n      if (\"object\" == typeof i && \"object\" == typeof a && i && a) {\n        const e = C(i);\n        e !== C(a) ? r[s + t] = n[t] : \"Object\" === e ? Mn(i, a, r, s + t + \".\") : i !== a && (r[s + t] = n[t]);\n      } else i !== a && (r[s + t] = n[t]);\n    } else r[s + t] = void 0;\n  }), t(n).forEach(t => {\n    o(e, t) || (r[s + t] = n[t]);\n  }), r;\n}\nconst Nn = {\n  stack: \"dbcore\",\n  name: \"HooksMiddleware\",\n  level: 2,\n  create: e => _objectSpread(_objectSpread({}, e), {}, {\n    table(t) {\n      const n = e.table(t),\n        {\n          primaryKey: r\n        } = n.schema,\n        s = _objectSpread(_objectSpread({}, n), {}, {\n          mutate(e) {\n            const s = Oe.trans,\n              {\n                deleting: i,\n                creating: a,\n                updating: u\n              } = s.table(t).hook;\n            switch (e.type) {\n              case \"add\":\n                if (a.fire === ee) break;\n                return s._promise(\"readwrite\", () => l(e), !0);\n              case \"put\":\n                if (a.fire === ee && u.fire === ee) break;\n                return s._promise(\"readwrite\", () => l(e), !0);\n              case \"delete\":\n                if (i.fire === ee) break;\n                return s._promise(\"readwrite\", () => l(e), !0);\n              case \"deleteRange\":\n                if (i.fire === ee) break;\n                return s._promise(\"readwrite\", () => function (e) {\n                  return c(e.trans, e.range, 1e4);\n                }(e), !0);\n            }\n            return n.mutate(e);\n            function l(e) {\n              const t = Oe.trans,\n                s = e.keys || function (e, t) {\n                  return \"delete\" === t.type ? t.keys : t.keys || t.values.map(e.extractKey);\n                }(r, e);\n              if (!s) throw new Error(\"Keys missing\");\n              return \"delete\" !== (e = \"add\" === e.type || \"put\" === e.type ? _objectSpread(_objectSpread({}, e), {}, {\n                keys: s\n              }) : _objectSpread({}, e)).type && (e.values = [...e.values]), e.keys && (e.keys = [...e.keys]), function (e, t, n) {\n                return \"add\" === t.type ? Promise.resolve([]) : e.getMany({\n                  trans: t.trans,\n                  keys: n,\n                  cache: \"immutable\"\n                });\n              }(n, e, s).then(l => {\n                const c = s.map((n, s) => {\n                  const c = l[s],\n                    h = {\n                      onerror: null,\n                      onsuccess: null\n                    };\n                  if (\"delete\" === e.type) i.fire.call(h, n, c, t);else if (\"add\" === e.type || void 0 === c) {\n                    const i = a.fire.call(h, n, e.values[s], t);\n                    null == n && null != i && (n = i, e.keys[s] = n, r.outbound || _(e.values[s], r.keyPath, n));\n                  } else {\n                    const r = Mn(c, e.values[s]),\n                      i = u.fire.call(h, r, n, c, t);\n                    if (i) {\n                      const t = e.values[s];\n                      Object.keys(i).forEach(e => {\n                        o(t, e) ? t[e] = i[e] : _(t, e, i[e]);\n                      });\n                    }\n                  }\n                  return h;\n                });\n                return n.mutate(e).then(_ref20 => {\n                  let {\n                    failures: t,\n                    results: n,\n                    numFailures: r,\n                    lastResult: i\n                  } = _ref20;\n                  for (let r = 0; r < s.length; ++r) {\n                    const i = n ? n[r] : s[r],\n                      o = c[r];\n                    null == i ? o.onerror && o.onerror(t[r]) : o.onsuccess && o.onsuccess(\"put\" === e.type && l[r] ? e.values[r] : i);\n                  }\n                  return {\n                    failures: t,\n                    results: n,\n                    numFailures: r,\n                    lastResult: i\n                  };\n                }).catch(e => (c.forEach(t => t.onerror && t.onerror(e)), Promise.reject(e)));\n              });\n            }\n            function c(e, t, s) {\n              return n.query({\n                trans: e,\n                values: !1,\n                query: {\n                  index: r,\n                  range: t\n                },\n                limit: s\n              }).then(_ref21 => {\n                let {\n                  result: n\n                } = _ref21;\n                return l({\n                  type: \"delete\",\n                  keys: n,\n                  trans: e\n                }).then(r => r.numFailures > 0 ? Promise.reject(r.failures[0]) : n.length < s ? {\n                  failures: [],\n                  numFailures: 0,\n                  lastResult: void 0\n                } : c(e, _objectSpread(_objectSpread({}, t), {}, {\n                  lower: n[n.length - 1],\n                  lowerOpen: !0\n                }), s));\n              });\n            }\n          }\n        });\n      return s;\n    }\n  })\n};\nfunction qn(e, t, n) {\n  try {\n    if (!t) return null;\n    if (t.keys.length < e.length) return null;\n    const r = [];\n    for (let s = 0, i = 0; s < t.keys.length && i < e.length; ++s) 0 === $t(t.keys[s], e[i]) && (r.push(n ? O(t.values[s]) : t.values[s]), ++i);\n    return r.length === e.length ? r : null;\n  } catch (e) {\n    return null;\n  }\n}\nconst $n = {\n  stack: \"dbcore\",\n  level: -1,\n  create: e => ({\n    table: t => {\n      const n = e.table(t);\n      return _objectSpread(_objectSpread({}, n), {}, {\n        getMany: e => {\n          if (!e.cache) return n.getMany(e);\n          const t = qn(e.keys, e.trans._cache, \"clone\" === e.cache);\n          return t ? je.resolve(t) : n.getMany(e).then(t => (e.trans._cache = {\n            keys: e.keys,\n            values: \"clone\" === e.cache ? O(t) : t\n          }, t));\n        },\n        mutate: e => (\"add\" !== e.type && (e.trans._cache = null), n.mutate(e))\n      });\n    }\n  })\n};\nfunction Un(e) {\n  return !(\"from\" in e);\n}\nconst Ln = function (e, t) {\n  if (!this) {\n    const t = new Ln();\n    return e && \"d\" in e && r(t, e), t;\n  }\n  r(this, arguments.length ? {\n    d: 1,\n    from: e,\n    to: arguments.length > 1 ? t : e\n  } : {\n    d: 0\n  });\n};\nfunction Vn(e, t, n) {\n  const s = $t(t, n);\n  if (isNaN(s)) return;\n  if (s > 0) throw RangeError();\n  if (Un(e)) return r(e, {\n    from: t,\n    to: n,\n    d: 1\n  });\n  const i = e.l,\n    o = e.r;\n  if ($t(n, e.from) < 0) return i ? Vn(i, t, n) : e.l = {\n    from: t,\n    to: n,\n    d: 1,\n    l: null,\n    r: null\n  }, Gn(e);\n  if ($t(t, e.to) > 0) return o ? Vn(o, t, n) : e.r = {\n    from: t,\n    to: n,\n    d: 1,\n    l: null,\n    r: null\n  }, Gn(e);\n  $t(t, e.from) < 0 && (e.from = t, e.l = null, e.d = o ? o.d + 1 : 1), $t(n, e.to) > 0 && (e.to = n, e.r = null, e.d = e.l ? e.l.d + 1 : 1);\n  const a = !e.r;\n  i && !e.l && Wn(e, i), o && a && Wn(e, o);\n}\nfunction Wn(e, t) {\n  Un(t) || function e(t, _ref22) {\n    let {\n      from: n,\n      to: r,\n      l: s,\n      r: i\n    } = _ref22;\n    Vn(t, n, r), s && e(t, s), i && e(t, i);\n  }(e, t);\n}\nfunction Yn(e, t) {\n  const n = zn(t);\n  let r = n.next();\n  if (r.done) return !1;\n  let s = r.value;\n  const i = zn(e);\n  let o = i.next(s.from),\n    a = o.value;\n  for (; !r.done && !o.done;) {\n    if ($t(a.from, s.to) <= 0 && $t(a.to, s.from) >= 0) return !0;\n    $t(s.from, a.from) < 0 ? s = (r = n.next(a.from)).value : a = (o = i.next(s.from)).value;\n  }\n  return !1;\n}\nfunction zn(e) {\n  let t = Un(e) ? null : {\n    s: 0,\n    n: e\n  };\n  return {\n    next(e) {\n      const n = arguments.length > 0;\n      for (; t;) switch (t.s) {\n        case 0:\n          if (t.s = 1, n) for (; t.n.l && $t(e, t.n.from) < 0;) t = {\n            up: t,\n            n: t.n.l,\n            s: 1\n          };else for (; t.n.l;) t = {\n            up: t,\n            n: t.n.l,\n            s: 1\n          };\n        case 1:\n          if (t.s = 2, !n || $t(e, t.n.to) <= 0) return {\n            value: t.n,\n            done: !1\n          };\n        case 2:\n          if (t.n.r) {\n            t.s = 3, t = {\n              up: t,\n              n: t.n.r,\n              s: 0\n            };\n            continue;\n          }\n        case 3:\n          t = t.up;\n      }\n      return {\n        done: !0\n      };\n    }\n  };\n}\nfunction Gn(e) {\n  var t, n;\n  const r = ((null === (t = e.r) || void 0 === t ? void 0 : t.d) || 0) - ((null === (n = e.l) || void 0 === n ? void 0 : n.d) || 0),\n    s = r > 1 ? \"r\" : r < -1 ? \"l\" : \"\";\n  if (s) {\n    const t = \"r\" === s ? \"l\" : \"r\",\n      n = _objectSpread({}, e),\n      r = e[s];\n    e.from = r.from, e.to = r.to, e[s] = r[s], n[s] = r[t], e[t] = n, n.d = Hn(n);\n  }\n  e.d = Hn(e);\n}\nfunction Hn(_ref23) {\n  let {\n    r: e,\n    l: t\n  } = _ref23;\n  return (e ? t ? Math.max(e.d, t.d) : e.d : t ? t.d : 0) + 1;\n}\na(Ln.prototype, {\n  add(e) {\n    return Wn(this, e), this;\n  },\n  addKey(e) {\n    return Vn(this, e, e), this;\n  },\n  addKeys(e) {\n    return e.forEach(e => Vn(this, e, e)), this;\n  },\n  [j]() {\n    return zn(this);\n  }\n});\nconst Qn = {\n  stack: \"dbcore\",\n  level: 0,\n  create: e => {\n    const r = e.schema.name,\n      s = new Ln(e.MIN_KEY, e.MAX_KEY);\n    return _objectSpread(_objectSpread({}, e), {}, {\n      table: i => {\n        const o = e.table(i),\n          {\n            schema: a\n          } = o,\n          {\n            primaryKey: u\n          } = a,\n          {\n            extractKey: l,\n            outbound: c\n          } = u,\n          h = _objectSpread(_objectSpread({}, o), {}, {\n            mutate: e => {\n              const t = e.trans,\n                u = t.mutatedParts || (t.mutatedParts = {}),\n                l = e => {\n                  const t = \"idb://\".concat(r, \"/\").concat(i, \"/\").concat(e);\n                  return u[t] || (u[t] = new Ln());\n                },\n                c = l(\"\"),\n                h = l(\":dels\"),\n                {\n                  type: d\n                } = e;\n              let [f, p] = \"deleteRange\" === e.type ? [e.range] : \"delete\" === e.type ? [e.keys] : e.values.length < 50 ? [[], e.values] : [];\n              const y = e.trans._cache;\n              return o.mutate(e).then(e => {\n                if (n(f)) {\n                  \"delete\" !== d && (f = e.results), c.addKeys(f);\n                  const t = qn(f, y);\n                  t || \"add\" === d || h.addKeys(f), (t || p) && function (e, t, r, s) {\n                    function i(t) {\n                      const i = e(t.name || \"\");\n                      function o(e) {\n                        return null != e ? t.extractKey(e) : null;\n                      }\n                      const a = e => t.multiEntry && n(e) ? e.forEach(e => i.addKey(e)) : i.addKey(e);\n                      (r || s).forEach((e, t) => {\n                        const n = r && o(r[t]),\n                          i = s && o(s[t]);\n                        0 !== $t(n, i) && (null != n && a(n), null != i && a(i));\n                      });\n                    }\n                    t.indexes.forEach(i);\n                  }(l, a, t, p);\n                } else if (f) {\n                  const e = {\n                    from: f.lower,\n                    to: f.upper\n                  };\n                  h.add(e), c.add(e);\n                } else c.add(s), h.add(s), a.indexes.forEach(e => l(e.name).add(s));\n                return e;\n              });\n            }\n          }),\n          d = _ref24 => {\n            let {\n              query: {\n                index: t,\n                range: n\n              }\n            } = _ref24;\n            var r, s;\n            return [t, new Ln(null !== (r = n.lower) && void 0 !== r ? r : e.MIN_KEY, null !== (s = n.upper) && void 0 !== s ? s : e.MAX_KEY)];\n          },\n          f = {\n            get: e => [u, new Ln(e.key)],\n            getMany: e => [u, new Ln().addKeys(e.keys)],\n            count: d,\n            query: d,\n            openCursor: d\n          };\n        return t(f).forEach(e => {\n          h[e] = function (t) {\n            const {\n              subscr: n\n            } = Oe;\n            if (n) {\n              const a = e => {\n                  const t = \"idb://\".concat(r, \"/\").concat(i, \"/\").concat(e);\n                  return n[t] || (n[t] = new Ln());\n                },\n                u = a(\"\"),\n                h = a(\":dels\"),\n                [d, p] = f[e](t);\n              if (a(d.name || \"\").add(p), !d.isPrimaryKey) {\n                if (\"count\" !== e) {\n                  const n = \"query\" === e && c && t.values && o.query(_objectSpread(_objectSpread({}, t), {}, {\n                    values: !1\n                  }));\n                  return o[e].apply(this, arguments).then(r => {\n                    if (\"query\" === e) {\n                      if (c && t.values) return n.then(_ref25 => {\n                        let {\n                          result: e\n                        } = _ref25;\n                        return u.addKeys(e), r;\n                      });\n                      const e = t.values ? r.result.map(l) : r.result;\n                      t.values ? u.addKeys(e) : h.addKeys(e);\n                    } else if (\"openCursor\" === e) {\n                      const e = r,\n                        n = t.values;\n                      return e && Object.create(e, {\n                        key: {\n                          get: () => (h.addKey(e.primaryKey), e.key)\n                        },\n                        primaryKey: {\n                          get() {\n                            const t = e.primaryKey;\n                            return h.addKey(t), t;\n                          }\n                        },\n                        value: {\n                          get: () => (n && u.addKey(e.primaryKey), e.value)\n                        }\n                      });\n                    }\n                    return r;\n                  });\n                }\n                h.add(s);\n              }\n            }\n            return o[e].apply(this, arguments);\n          };\n        }), h;\n      }\n    });\n  }\n};\nclass Xn {\n  constructor(e, t) {\n    this._middlewares = {}, this.verno = 0;\n    const n = Xn.dependencies;\n    this._options = t = _objectSpread({\n      addons: Xn.addons,\n      autoOpen: !0,\n      indexedDB: n.indexedDB,\n      IDBKeyRange: n.IDBKeyRange\n    }, t), this._deps = {\n      indexedDB: t.indexedDB,\n      IDBKeyRange: t.IDBKeyRange\n    };\n    const {\n      addons: r\n    } = t;\n    this._dbSchema = {}, this._versions = [], this._storeNames = [], this._allTables = {}, this.idbdb = null, this._novip = this;\n    const s = {\n      dbOpenError: null,\n      isBeingOpened: !1,\n      onReadyBeingFired: null,\n      openComplete: !1,\n      dbReadyResolve: ee,\n      dbReadyPromise: null,\n      cancelOpen: ee,\n      openCanceller: null,\n      autoSchema: !0,\n      PR1398_maxLoop: 3\n    };\n    var i;\n    s.dbReadyPromise = new je(e => {\n      s.dbReadyResolve = e;\n    }), s.openCanceller = new je((e, t) => {\n      s.cancelOpen = t;\n    }), this._state = s, this.name = e, this.on = Dt(this, \"populate\", \"blocked\", \"versionchange\", \"close\", {\n      ready: [ue, ee]\n    }), this.on.ready.subscribe = y(this.on.ready.subscribe, e => (t, n) => {\n      Xn.vip(() => {\n        const r = this._state;\n        if (r.openComplete) r.dbOpenError || je.resolve().then(t), n && e(t);else if (r.onReadyBeingFired) r.onReadyBeingFired.push(t), n && e(t);else {\n          e(t);\n          const r = this;\n          n || e(function e() {\n            r.on.ready.unsubscribe(t), r.on.ready.unsubscribe(e);\n          });\n        }\n      });\n    }), this.Collection = (i = this, It(Vt.prototype, function (e, t) {\n      this.db = i;\n      let n = At,\n        r = null;\n      if (t) try {\n        n = t();\n      } catch (e) {\n        r = e;\n      }\n      const s = e._ctx,\n        o = s.table,\n        a = o.hook.reading.fire;\n      this._ctx = {\n        table: o,\n        index: s.index,\n        isPrimKey: !s.index || o.schema.primKey.keyPath && s.index === o.schema.primKey.name,\n        range: n,\n        keysOnly: !1,\n        dir: \"next\",\n        unique: \"\",\n        algorithm: null,\n        filter: null,\n        replayFilter: null,\n        justLimit: !0,\n        isMatch: null,\n        offset: 0,\n        limit: 1 / 0,\n        error: r,\n        or: s.or,\n        valueMapper: a !== te ? a : null\n      };\n    })), this.Table = function (e) {\n      return It(jt.prototype, function (t, n, r) {\n        this.db = e, this._tx = r, this.name = t, this.schema = n, this.hook = e._allTables[t] ? e._allTables[t].hook : Dt(null, {\n          creating: [se, ee],\n          reading: [ne, te],\n          updating: [oe, ee],\n          deleting: [ie, ee]\n        });\n      });\n    }(this), this.Transaction = function (e) {\n      return It(an.prototype, function (t, n, r, s, i) {\n        this.db = e, this.mode = t, this.storeNames = n, this.schema = r, this.chromeTransactionDurability = s, this.idbtrans = null, this.on = Dt(this, \"complete\", \"error\", \"abort\"), this.parent = i || null, this.active = !0, this._reculock = 0, this._blockedFuncs = [], this._resolve = null, this._reject = null, this._waitingFor = null, this._waitingQueue = null, this._spinCount = 0, this._completion = new je((e, t) => {\n          this._resolve = e, this._reject = t;\n        }), this._completion.then(() => {\n          this.active = !1, this.on.complete.fire();\n        }, e => {\n          var t = this.active;\n          return this.active = !1, this.on.error.fire(e), this.parent ? this.parent._reject(e) : t && this.idbtrans && this.idbtrans.abort(), ft(e);\n        });\n      });\n    }(this), this.Version = function (e) {\n      return It(On.prototype, function (t) {\n        this.db = e, this._cfg = {\n          version: t,\n          storesSource: null,\n          dbschema: {},\n          tables: {},\n          contentUpgrade: null\n        };\n      });\n    }(this), this.WhereClause = function (e) {\n      return It(en.prototype, function (t, n, r) {\n        this.db = e, this._ctx = {\n          table: t,\n          index: \":id\" === n ? null : n,\n          or: r\n        };\n        const s = e._deps.indexedDB;\n        if (!s) throw new X.MissingAPI();\n        this._cmp = this._ascending = s.cmp.bind(s), this._descending = (e, t) => s.cmp(t, e), this._max = (e, t) => s.cmp(e, t) > 0 ? e : t, this._min = (e, t) => s.cmp(e, t) < 0 ? e : t, this._IDBKeyRange = e._deps.IDBKeyRange;\n      });\n    }(this), this.on(\"versionchange\", e => {\n      e.newVersion > 0 ? console.warn(\"Another connection wants to upgrade database '\".concat(this.name, \"'. Closing db now to resume the upgrade.\")) : console.warn(\"Another connection wants to delete database '\".concat(this.name, \"'. Closing db now to resume the delete request.\")), this.close();\n    }), this.on(\"blocked\", e => {\n      !e.newVersion || e.newVersion < e.oldVersion ? console.warn(\"Dexie.delete('\".concat(this.name, \"') was blocked\")) : console.warn(\"Upgrade '\".concat(this.name, \"' blocked by other connection holding version \").concat(e.oldVersion / 10));\n    }), this._maxKey = hn(t.IDBKeyRange), this._createTransaction = (e, t, n, r) => new this.Transaction(e, t, n, this._options.chromeTransactionDurability, r), this._fireOnBlocked = e => {\n      this.on(\"blocked\").fire(e), _t.filter(e => e.name === this.name && e !== this && !e._state.vcFired).map(t => t.on(\"versionchange\").fire(e));\n    }, this.use(Fn), this.use(Nn), this.use(Qn), this.use($n), this.vip = Object.create(this, {\n      _vip: {\n        value: !0\n      }\n    }), r.forEach(e => e(this));\n  }\n  version(e) {\n    if (isNaN(e) || e < .1) throw new X.Type(\"Given version is not a positive number\");\n    if (e = Math.round(10 * e) / 10, this.idbdb || this._state.isBeingOpened) throw new X.Schema(\"Cannot add version when database is open\");\n    this.verno = Math.max(this.verno, e);\n    const t = this._versions;\n    var n = t.filter(t => t._cfg.version === e)[0];\n    return n || (n = new this.Version(e), t.push(n), t.sort(_n), n.stores({}), this._state.autoSchema = !1, n);\n  }\n  _whenReady(e) {\n    return this.idbdb && (this._state.openComplete || Oe.letThrough || this._vip) ? e() : new je((e, t) => {\n      if (this._state.openComplete) return t(new X.DatabaseClosed(this._state.dbOpenError));\n      if (!this._state.isBeingOpened) {\n        if (!this._options.autoOpen) return void t(new X.DatabaseClosed());\n        this.open().catch(ee);\n      }\n      this._state.dbReadyPromise.then(e, t);\n    }).then(e);\n  }\n  use(_ref26) {\n    let {\n      stack: e,\n      create: t,\n      level: n,\n      name: r\n    } = _ref26;\n    r && this.unuse({\n      stack: e,\n      name: r\n    });\n    const s = this._middlewares[e] || (this._middlewares[e] = []);\n    return s.push({\n      stack: e,\n      create: t,\n      level: null == n ? 10 : n,\n      name: r\n    }), s.sort((e, t) => e.level - t.level), this;\n  }\n  unuse(_ref27) {\n    let {\n      stack: e,\n      name: t,\n      create: n\n    } = _ref27;\n    return e && this._middlewares[e] && (this._middlewares[e] = this._middlewares[e].filter(e => n ? e.create !== n : !!t && e.name !== t)), this;\n  }\n  open() {\n    return Dn(this);\n  }\n  _close() {\n    const e = this._state,\n      t = _t.indexOf(this);\n    if (t >= 0 && _t.splice(t, 1), this.idbdb) {\n      try {\n        this.idbdb.close();\n      } catch (e) {}\n      this._novip.idbdb = null;\n    }\n    e.dbReadyPromise = new je(t => {\n      e.dbReadyResolve = t;\n    }), e.openCanceller = new je((t, n) => {\n      e.cancelOpen = n;\n    });\n  }\n  close() {\n    this._close();\n    const e = this._state;\n    this._options.autoOpen = !1, e.dbOpenError = new X.DatabaseClosed(), e.isBeingOpened && e.cancelOpen(e.dbOpenError);\n  }\n  delete() {\n    const e = arguments.length > 0,\n      t = this._state;\n    return new je((n, r) => {\n      const s = () => {\n        this.close();\n        var e = this._deps.indexedDB.deleteDatabase(this.name);\n        e.onsuccess = Ye(() => {\n          !function (_ref28, n) {\n            let {\n              indexedDB: e,\n              IDBKeyRange: t\n            } = _ref28;\n            !An(e) && n !== Pt && Sn(e, t).delete(n).catch(ee);\n          }(this._deps, this.name), n();\n        }), e.onerror = tn(r), e.onblocked = this._fireOnBlocked;\n      };\n      if (e) throw new X.InvalidArgument(\"Arguments not allowed in db.delete()\");\n      t.isBeingOpened ? t.dbReadyPromise.then(s) : s();\n    });\n  }\n  backendDB() {\n    return this.idbdb;\n  }\n  isOpen() {\n    return null !== this.idbdb;\n  }\n  hasBeenClosed() {\n    const e = this._state.dbOpenError;\n    return e && \"DatabaseClosed\" === e.name;\n  }\n  hasFailed() {\n    return null !== this._state.dbOpenError;\n  }\n  dynamicallyOpened() {\n    return this._state.autoSchema;\n  }\n  get tables() {\n    return t(this._allTables).map(e => this._allTables[e]);\n  }\n  transaction() {\n    const e = Bn.apply(this, arguments);\n    return this._transaction.apply(this, e);\n  }\n  _transaction(e, t, n) {\n    let r = Oe.trans;\n    r && r.db === this && -1 === e.indexOf(\"!\") || (r = null);\n    const s = -1 !== e.indexOf(\"?\");\n    let i, o;\n    e = e.replace(\"!\", \"\").replace(\"?\", \"\");\n    try {\n      if (o = t.map(e => {\n        var t = e instanceof this.Table ? e.name : e;\n        if (\"string\" != typeof t) throw new TypeError(\"Invalid table argument to Dexie.transaction(). Only Table or String are allowed\");\n        return t;\n      }), \"r\" == e || e === Kt) i = Kt;else {\n        if (\"rw\" != e && e != Ot) throw new X.InvalidArgument(\"Invalid transaction mode: \" + e);\n        i = Ot;\n      }\n      if (r) {\n        if (r.mode === Kt && i === Ot) {\n          if (!s) throw new X.SubTransaction(\"Cannot enter a sub-transaction with READWRITE mode when parent transaction is READONLY\");\n          r = null;\n        }\n        r && o.forEach(e => {\n          if (r && -1 === r.storeNames.indexOf(e)) {\n            if (!s) throw new X.SubTransaction(\"Table \" + e + \" not included in parent transaction.\");\n            r = null;\n          }\n        }), s && r && !r.active && (r = null);\n      }\n    } catch (e) {\n      return r ? r._promise(null, (t, n) => {\n        n(e);\n      }) : ft(e);\n    }\n    const a = Tn.bind(null, this, i, o, r, n);\n    return r ? r._promise(i, a, \"lock\") : Oe.trans ? at(Oe.transless, () => this._whenReady(a)) : this._whenReady(a);\n  }\n  table(e) {\n    if (!o(this._allTables, e)) throw new X.InvalidTable(\"Table \".concat(e, \" does not exist\"));\n    return this._allTables[e];\n  }\n}\nconst Jn = \"undefined\" != typeof Symbol && \"observable\" in Symbol ? Symbol.observable : \"@@observable\";\nclass Zn {\n  constructor(e) {\n    this._subscribe = e;\n  }\n  subscribe(e, t, n) {\n    return this._subscribe(e && \"function\" != typeof e ? e : {\n      next: e,\n      error: t,\n      complete: n\n    });\n  }\n  [Jn]() {\n    return this;\n  }\n}\nfunction er(e, n) {\n  return t(n).forEach(t => {\n    Wn(e[t] || (e[t] = new Ln()), n[t]);\n  }), e;\n}\nfunction tr(e) {\n  let n,\n    r = !1;\n  const s = new Zn(s => {\n    const i = T(e);\n    let o = !1,\n      a = {},\n      u = {};\n    const l = {\n      get closed() {\n        return o;\n      },\n      unsubscribe: () => {\n        o = !0, on.storagemutated.unsubscribe(f);\n      }\n    };\n    s.start && s.start(l);\n    let c = !1,\n      h = !1;\n    function d() {\n      return t(u).some(e => a[e] && Yn(a[e], u[e]));\n    }\n    const f = e => {\n        er(a, e), d() && p();\n      },\n      p = () => {\n        if (c || o) return;\n        a = {};\n        const t = {},\n          y = function (t) {\n            i && et();\n            const n = () => Ze(e, {\n                subscr: t,\n                trans: null\n              }),\n              r = Oe.trans ? at(Oe.transless, n) : n();\n            return i && r.then(tt, tt), r;\n          }(t);\n        h || (on(rn, f), h = !0), c = !0, Promise.resolve(y).then(e => {\n          r = !0, n = e, c = !1, o || (d() ? p() : (a = {}, u = t, s.next && s.next(e)));\n        }, e => {\n          c = !1, r = !1, s.error && s.error(e), l.unsubscribe();\n        });\n      };\n    return p(), l;\n  });\n  return s.hasValue = () => r, s.getValue = () => n, s;\n}\nlet nr;\ntry {\n  nr = {\n    indexedDB: e.indexedDB || e.mozIndexedDB || e.webkitIndexedDB || e.msIndexedDB,\n    IDBKeyRange: e.IDBKeyRange || e.webkitIDBKeyRange\n  };\n} catch (e) {\n  nr = {\n    indexedDB: null,\n    IDBKeyRange: null\n  };\n}\nconst rr = Xn;\nfunction sr(e) {\n  let t = ir;\n  try {\n    ir = !0, on.storagemutated.fire(e);\n  } finally {\n    ir = t;\n  }\n}\na(rr, _objectSpread(_objectSpread({}, Z), {}, {\n  delete: e => new rr(e, {\n    addons: []\n  }).delete(),\n  exists: e => new rr(e, {\n    addons: []\n  }).open().then(e => (e.close(), !0)).catch(\"NoSuchDatabaseError\", () => !1),\n  getDatabaseNames(e) {\n    try {\n      return function (_ref29) {\n        let {\n          indexedDB: e,\n          IDBKeyRange: t\n        } = _ref29;\n        return An(e) ? Promise.resolve(e.databases()).then(e => e.map(e => e.name).filter(e => e !== Pt)) : Sn(e, t).toCollection().primaryKeys();\n      }(rr.dependencies).then(e);\n    } catch (e) {\n      return ft(new X.MissingAPI());\n    }\n  },\n  defineClass: () => function (e) {\n    r(this, e);\n  },\n  ignoreTransaction: e => Oe.trans ? at(Oe.transless, e) : e(),\n  vip: Cn,\n  async: function (e) {\n    return function () {\n      try {\n        var t = In(e.apply(this, arguments));\n        return t && \"function\" == typeof t.then ? t : je.resolve(t);\n      } catch (e) {\n        return ft(e);\n      }\n    };\n  },\n  spawn: function (e, t, n) {\n    try {\n      var r = In(e.apply(n, t || []));\n      return r && \"function\" == typeof r.then ? r : je.resolve(r);\n    } catch (e) {\n      return ft(e);\n    }\n  },\n  currentTransaction: {\n    get: () => Oe.trans || null\n  },\n  waitFor: function (e, t) {\n    const n = je.resolve(\"function\" == typeof e ? rr.ignoreTransaction(e) : e).timeout(t || 6e4);\n    return Oe.trans ? Oe.trans.waitFor(n) : n;\n  },\n  Promise: je,\n  debug: {\n    get: () => R,\n    set: e => {\n      F(e, \"dexie\" === e ? () => !0 : Et);\n    }\n  },\n  derive: c,\n  extend: r,\n  props: a,\n  override: y,\n  Events: Dt,\n  on: on,\n  liveQuery: tr,\n  extendObservabilitySet: er,\n  getByKeyPath: b,\n  setByKeyPath: _,\n  delByKeyPath: function (e, t) {\n    \"string\" == typeof t ? _(e, t, void 0) : \"length\" in t && [].map.call(t, function (t) {\n      _(e, t, void 0);\n    });\n  },\n  shallowClone: w,\n  deepClone: O,\n  getObjectDiff: Mn,\n  cmp: $t,\n  asap: v,\n  minKey: vt,\n  addons: [],\n  connections: _t,\n  errnames: H,\n  dependencies: nr,\n  semVer: yt,\n  version: yt.split(\".\").map(e => parseInt(e)).reduce((e, t, n) => e + t / Math.pow(10, 2 * n))\n})), rr.maxKey = hn(rr.dependencies.IDBKeyRange), \"undefined\" != typeof dispatchEvent && \"undefined\" != typeof addEventListener && (on(rn, e => {\n  if (!ir) {\n    let t;\n    wt ? (t = document.createEvent(\"CustomEvent\"), t.initCustomEvent(sn, !0, !0, e)) : t = new CustomEvent(sn, {\n      detail: e\n    }), ir = !0, dispatchEvent(t), ir = !1;\n  }\n}), addEventListener(sn, _ref30 => {\n  let {\n    detail: e\n  } = _ref30;\n  ir || sr(e);\n}));\nlet ir = !1;\nif (\"undefined\" != typeof BroadcastChannel) {\n  const e = new BroadcastChannel(sn);\n  \"function\" == typeof e.unref && e.unref(), on(rn, t => {\n    ir || e.postMessage(t);\n  }), e.onmessage = e => {\n    e.data && sr(e.data);\n  };\n} else if (\"undefined\" != typeof self && \"undefined\" != typeof navigator) {\n  on(rn, e => {\n    try {\n      ir || (\"undefined\" != typeof localStorage && localStorage.setItem(sn, JSON.stringify({\n        trig: Math.random(),\n        changedParts: e\n      })), \"object\" == typeof self.clients && [...self.clients.matchAll({\n        includeUncontrolled: !0\n      })].forEach(t => t.postMessage({\n        type: sn,\n        changedParts: e\n      })));\n    } catch (e) {}\n  }), \"undefined\" != typeof addEventListener && addEventListener(\"storage\", e => {\n    if (e.key === sn) {\n      const t = JSON.parse(e.newValue);\n      t && sr(t.changedParts);\n    }\n  });\n  const e = self.document && navigator.serviceWorker;\n  e && e.addEventListener(\"message\", function (_ref31) {\n    let {\n      data: e\n    } = _ref31;\n    e && e.type === sn && sr(e.changedParts);\n  });\n}\nje.rejectionMapper = function (e, t) {\n  if (!e || e instanceof W || e instanceof TypeError || e instanceof SyntaxError || !e.name || !J[e.name]) return e;\n  var n = new J[e.name](t || e.message, e);\n  return \"stack\" in e && l(n, \"stack\", {\n    get: function () {\n      return this.inner.stack;\n    }\n  }), n;\n}, F(R, Et);\nexport { Xn as Dexie, Ln as RangeSet, Xn as default, tr as liveQuery, Wn as mergeRanges, Yn as rangesOverlap };","map":{"version":3,"names":["e","globalThis","self","window","global","t","Object","keys","n","Array","isArray","r","forEach","Promise","s","getPrototypeOf","i","hasOwnProperty","o","call","a","Reflect","ownKeys","l","u","defineProperty","get","set","configurable","value","writable","c","from","prototype","create","extend","bind","h","getOwnPropertyDescriptor","d","f","slice","p","y","m","Error","v","setImmediate","setTimeout","g","reduce","b","length","push","indexOf","substr","_","isFrozen","isNaN","parseInt","splice","w","x","concat","k","apply","E","split","map","filter","P","K","O","WeakMap","S","constructor","toString","A","C","j","Symbol","iterator","D","I","B","arguments","next","done","T","toStringTag","R","location","test","href","F","M","libraryFilter","N","stack","q","$","name","message","join","U","L","V","VersionChanged","DatabaseClosed","Abort","TransactionInactive","MissingAPI","W","_e","Y","z","failures","failedKeys","successCount","G","failuresByPos","_stack","H","Q","X","inner","Syntax","SyntaxError","Type","TypeError","Range","RangeError","J","Z","ee","te","ne","re","se","onsuccess","onerror","ie","oe","ae","ue","then","ModifyError","DexieError","BulkError","le","ce","he","de","fe","resolve","crypto","subtle","digest","Uint8Array","pe","ye","me","ve","ge","$e","MutationObserver","document","createElement","observe","attributes","setAttribute","be","asap","Se","we","xe","ke","Ee","Pe","Ke","id","ref","unhandleds","onunhandled","dt","pgp","env","finalize","Oe","Ae","Ce","je","_listeners","onuncatched","_lib","_PSD","_stackHolder","_prev","_numPrev","_state","_value","Te","Be","De","Xe","tt","Fe","Ie","lt","qe","onFulfilled","onRejected","reject","psd","Ue","_then","Re","Le","_promise","some","Ve","Me","Ne","We","Ye","it","catch","finally","timeout","Timeout","clearTimeout","ot","all","nt","race","PSD","totalEchoes","newPSD","Ze","usePSD","at","scheduler","rejectionMapper","follow","allSettled","status","reason","any","AggregateError","ze","awaits","echoes","Ge","He","Qe","Je","parent","PromiseProp","nthen","ct","gthen","et","ft","rt","st","pop","ut","ht","promise","createEvent","initEvent","CustomEvent","detail","dispatchEvent","PromiseRejectionEvent","onunhandledrejection","defaultPrevented","console","warn","pt","idbdb","openComplete","letThrough","_vip","_createTransaction","_dbSchema","PR1398_maxLoop","InvalidState","isOpen","_close","open","trans","_completion","dbOpenError","isBeingOpened","_options","autoOpen","dbReadyPromise","yt","mt","String","fromCharCode","vt","gt","bt","_t","wt","navigator","userAgent","xt","kt","Et","Pt","Kt","Ot","St","At","type","lower","lowerOpen","upper","upperOpen","Ct","jt","_trans","_tx","schema","NotFound","idbtrans","db","transless","where","first","core","key","hook","reading","fire","WhereClause","equals","indexes","primKey","compound","every","keyPath","sort","_maxKey","JSON","stringify","idxByName","_deps","indexedDB","cmp","_ref","multi","toCollection","and","count","offset","limit","each","toArray","Collection","orderBy","reverse","mapToClass","mappedClass","readHook","unsubscribe","defineClass","add","auto","mutate","values","numFailures","lastResult","update","modify","InvalidArgument","put","delete","clear","range","bulkGet","getMany","bulkAdd","allKeys","wantResults","_ref2","results","bulkPut","_ref3","bulkDelete","_ref4","Dt","rv","subscribe","addEventType","subscribers","It","Bt","algorithm","or","justLimit","replayFilter","Tt","Rt","Ft","isPrimKey","primaryKey","getIndexByKeyPath","index","Schema","Mt","openCursor","keysOnly","dir","unique","query","Nt","union","stop","fail","_iterate","qt","valueMapper","start","continue","$t","Ut","NaN","Lt","ArrayBuffer","isView","buffer","byteOffset","byteLength","Vt","_read","_ctx","error","table","_write","_addAlgorithm","clone","raw","Math","min","sortBy","_ref5","result","advance","until","last","isMatch","_ondirectionchange","desc","eachKey","eachUniqueKey","eachPrimaryKey","primaryKeys","_ref6","uniqueKeys","firstKey","lastKey","distinct","modifyer","outbound","extractKey","modifyChunkSize","applyMutateResult","cache","Wt","criteria","changeSpec","_ref7","deleteCallback","Yt","zt","Gt","en","Ht","Zt","Qt","Xt","toUpperCase","toLowerCase","Jt","between","_cmp","above","aboveOrEqual","below","belowOrEqual","startsWith","startsWithIgnoreCase","equalsIgnoreCase","anyOfIgnoreCase","startsWithAnyOfIgnoreCase","anyOf","_ascending","_descending","notEqual","inAnyRange","includeLowers","includeUppers","noneOf","_min","_max","startsWithAnyOf","tn","nn","target","stopPropagation","preventDefault","rn","sn","on","an","_lock","_reculock","lockOwnerFor","_unlock","_blockedFuncs","_locked","shift","mode","OpenFailed","active","transaction","storeNames","durability","chromeTransactionDurability","_reject","onabort","oncomplete","_resolve","storagemutated","mutatedParts","ReadOnly","_root","waitFor","_waitingFor","_waitingQueue","objectStore","_spinCount","abort","_memoizedTables","Table","un","src","ln","cn","hn","only","getMaxKey","dn","fn","pn","yn","mn","upperBound","lowerBound","bound","hasGetAll","objectStoreNames","tables","autoIncrement","isPrimaryKey","indexNames","multiEntry","match","_ref8","_ref9","_pos","_ref0","getAll","getAllKeys","openKeyCursor","_ref1","___id","continuePrimaryKey","doThrowCursorIsStopped","guardedCallback","_ref10","MIN_KEY","MAX_KEY","vn","_ref11","_novip","_ref12","IDBKeyRange","_ref13","_objectSpread","dbcore","_middlewares","gn","_ref14","Transaction","enumerable","bn","_ref15","_n","_cfg","version","wn","_storeNames","kn","populate","_ref16","_versions","Pn","dbschema","Kn","xn","change","recreate","Upgrade","En","deleteIndex","del","contentUpgrade","deleteObjectStore","contains","def","createObjectStore","createIndex","_ref17","_hasGetAll","WorkerGlobalScope","On","_parseStoresSpec","trim","replace","stores","storesSource","_allTables","upgrade","Sn","_dbNamesDB","Xn","addons","dbnames","An","databases","Cn","jn","userAgentData","tryIdb","setInterval","clearInterval","Dn","openCanceller","dbReadyResolve","tryOpenDB","autoSchema","round","verno","onblocked","_fireOnBlocked","onupgradeneeded","allowEmptyDB","close","deleteDatabase","NoSuchDatabase","oldVersion","pow","_ref18","onversionchange","vcFired","onclose","_ref19","onReadyBeingFired","ready","vip","In","throw","Bn","Tn","PrematureCommit","Rn","Fn","level","isVirtual","keyTail","keyLength","Mn","Nn","deleting","creating","updating","_ref20","_ref21","qn","$n","_cache","Un","Ln","RangeSet","to","Vn","Gn","Wn","_ref22","Yn","zn","up","Hn","_ref23","max","addKey","addKeys","Qn","_ref24","subscr","_ref25","dependencies","cancelOpen","complete","Version","_IDBKeyRange","newVersion","use","_whenReady","_ref26","unuse","_ref27","doDelete","_ref28","backendDB","hasBeenClosed","hasFailed","dynamicallyOpened","_transaction","SubTransaction","InvalidTable","Jn","observable","Zn","_subscribe","er","tr","closed","doQuery","exec","hasValue","getValue","nr","mozIndexedDB","webkitIndexedDB","msIndexedDB","webkitIDBKeyRange","rr","sr","ir","exists","getDatabaseNames","_ref29","ignoreTransaction","async","spawn","currentTransaction","debug","derive","props","override","Events","liveQuery","extendObservabilitySet","getByKeyPath","setByKeyPath","delByKeyPath","shallowClone","deepClone","getObjectDiff","minKey","connections","errnames","semVer","maxKey","addEventListener","initCustomEvent","_ref30","BroadcastChannel","unref","postMessage","onmessage","data","localStorage","setItem","trig","random","changedParts","clients","matchAll","includeUncontrolled","parse","newValue","serviceWorker","_ref31","Dexie","default","mergeRanges","rangesOverlap"],"sources":["D:\\diarry me\\node_modules\\dexie\\dist\\modern\\dexie.mjs"],"sourcesContent":["/*\n * Dexie.js - a minimalistic wrapper for IndexedDB\n * ===============================================\n *\n * By David Fahlander, david.fahlander@gmail.com\n *\n * Version 3.2.7, Wed Mar 20 2024\n *\n * https://dexie.org\n *\n * Apache License Version 2.0, January 2004, http://www.apache.org/licenses/\n */\n \nconst _global = typeof globalThis !== 'undefined' ? globalThis :\n    typeof self !== 'undefined' ? self :\n        typeof window !== 'undefined' ? window :\n            global;\n\nconst keys = Object.keys;\nconst isArray = Array.isArray;\nif (typeof Promise !== 'undefined' && !_global.Promise) {\n    _global.Promise = Promise;\n}\nfunction extend(obj, extension) {\n    if (typeof extension !== 'object')\n        return obj;\n    keys(extension).forEach(function (key) {\n        obj[key] = extension[key];\n    });\n    return obj;\n}\nconst getProto = Object.getPrototypeOf;\nconst _hasOwn = {}.hasOwnProperty;\nfunction hasOwn(obj, prop) {\n    return _hasOwn.call(obj, prop);\n}\nfunction props(proto, extension) {\n    if (typeof extension === 'function')\n        extension = extension(getProto(proto));\n    (typeof Reflect === \"undefined\" ? keys : Reflect.ownKeys)(extension).forEach(key => {\n        setProp(proto, key, extension[key]);\n    });\n}\nconst defineProperty = Object.defineProperty;\nfunction setProp(obj, prop, functionOrGetSet, options) {\n    defineProperty(obj, prop, extend(functionOrGetSet && hasOwn(functionOrGetSet, \"get\") && typeof functionOrGetSet.get === 'function' ?\n        { get: functionOrGetSet.get, set: functionOrGetSet.set, configurable: true } :\n        { value: functionOrGetSet, configurable: true, writable: true }, options));\n}\nfunction derive(Child) {\n    return {\n        from: function (Parent) {\n            Child.prototype = Object.create(Parent.prototype);\n            setProp(Child.prototype, \"constructor\", Child);\n            return {\n                extend: props.bind(null, Child.prototype)\n            };\n        }\n    };\n}\nconst getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;\nfunction getPropertyDescriptor(obj, prop) {\n    const pd = getOwnPropertyDescriptor(obj, prop);\n    let proto;\n    return pd || (proto = getProto(obj)) && getPropertyDescriptor(proto, prop);\n}\nconst _slice = [].slice;\nfunction slice(args, start, end) {\n    return _slice.call(args, start, end);\n}\nfunction override(origFunc, overridedFactory) {\n    return overridedFactory(origFunc);\n}\nfunction assert(b) {\n    if (!b)\n        throw new Error(\"Assertion Failed\");\n}\nfunction asap$1(fn) {\n    if (_global.setImmediate)\n        setImmediate(fn);\n    else\n        setTimeout(fn, 0);\n}\nfunction arrayToObject(array, extractor) {\n    return array.reduce((result, item, i) => {\n        var nameAndValue = extractor(item, i);\n        if (nameAndValue)\n            result[nameAndValue[0]] = nameAndValue[1];\n        return result;\n    }, {});\n}\nfunction tryCatch(fn, onerror, args) {\n    try {\n        fn.apply(null, args);\n    }\n    catch (ex) {\n        onerror && onerror(ex);\n    }\n}\nfunction getByKeyPath(obj, keyPath) {\n    if (typeof keyPath === 'string' && hasOwn(obj, keyPath))\n        return obj[keyPath];\n    if (!keyPath)\n        return obj;\n    if (typeof keyPath !== 'string') {\n        var rv = [];\n        for (var i = 0, l = keyPath.length; i < l; ++i) {\n            var val = getByKeyPath(obj, keyPath[i]);\n            rv.push(val);\n        }\n        return rv;\n    }\n    var period = keyPath.indexOf('.');\n    if (period !== -1) {\n        var innerObj = obj[keyPath.substr(0, period)];\n        return innerObj == null ? undefined : getByKeyPath(innerObj, keyPath.substr(period + 1));\n    }\n    return undefined;\n}\nfunction setByKeyPath(obj, keyPath, value) {\n    if (!obj || keyPath === undefined)\n        return;\n    if ('isFrozen' in Object && Object.isFrozen(obj))\n        return;\n    if (typeof keyPath !== 'string' && 'length' in keyPath) {\n        assert(typeof value !== 'string' && 'length' in value);\n        for (var i = 0, l = keyPath.length; i < l; ++i) {\n            setByKeyPath(obj, keyPath[i], value[i]);\n        }\n    }\n    else {\n        var period = keyPath.indexOf('.');\n        if (period !== -1) {\n            var currentKeyPath = keyPath.substr(0, period);\n            var remainingKeyPath = keyPath.substr(period + 1);\n            if (remainingKeyPath === \"\")\n                if (value === undefined) {\n                    if (isArray(obj) && !isNaN(parseInt(currentKeyPath)))\n                        obj.splice(currentKeyPath, 1);\n                    else\n                        delete obj[currentKeyPath];\n                }\n                else\n                    obj[currentKeyPath] = value;\n            else {\n                var innerObj = obj[currentKeyPath];\n                if (!innerObj || !hasOwn(obj, currentKeyPath))\n                    innerObj = (obj[currentKeyPath] = {});\n                setByKeyPath(innerObj, remainingKeyPath, value);\n            }\n        }\n        else {\n            if (value === undefined) {\n                if (isArray(obj) && !isNaN(parseInt(keyPath)))\n                    obj.splice(keyPath, 1);\n                else\n                    delete obj[keyPath];\n            }\n            else\n                obj[keyPath] = value;\n        }\n    }\n}\nfunction delByKeyPath(obj, keyPath) {\n    if (typeof keyPath === 'string')\n        setByKeyPath(obj, keyPath, undefined);\n    else if ('length' in keyPath)\n        [].map.call(keyPath, function (kp) {\n            setByKeyPath(obj, kp, undefined);\n        });\n}\nfunction shallowClone(obj) {\n    var rv = {};\n    for (var m in obj) {\n        if (hasOwn(obj, m))\n            rv[m] = obj[m];\n    }\n    return rv;\n}\nconst concat = [].concat;\nfunction flatten(a) {\n    return concat.apply([], a);\n}\nconst intrinsicTypeNames = \"BigUint64Array,BigInt64Array,Array,Boolean,String,Date,RegExp,Blob,File,FileList,FileSystemFileHandle,FileSystemDirectoryHandle,ArrayBuffer,DataView,Uint8ClampedArray,ImageBitmap,ImageData,Map,Set,CryptoKey\"\n    .split(',').concat(flatten([8, 16, 32, 64].map(num => [\"Int\", \"Uint\", \"Float\"].map(t => t + num + \"Array\")))).filter(t => _global[t]);\nconst intrinsicTypes = intrinsicTypeNames.map(t => _global[t]);\narrayToObject(intrinsicTypeNames, x => [x, true]);\nlet circularRefs = null;\nfunction deepClone(any) {\n    circularRefs = typeof WeakMap !== 'undefined' && new WeakMap();\n    const rv = innerDeepClone(any);\n    circularRefs = null;\n    return rv;\n}\nfunction innerDeepClone(any) {\n    if (!any || typeof any !== 'object')\n        return any;\n    let rv = circularRefs && circularRefs.get(any);\n    if (rv)\n        return rv;\n    if (isArray(any)) {\n        rv = [];\n        circularRefs && circularRefs.set(any, rv);\n        for (var i = 0, l = any.length; i < l; ++i) {\n            rv.push(innerDeepClone(any[i]));\n        }\n    }\n    else if (intrinsicTypes.indexOf(any.constructor) >= 0) {\n        rv = any;\n    }\n    else {\n        const proto = getProto(any);\n        rv = proto === Object.prototype ? {} : Object.create(proto);\n        circularRefs && circularRefs.set(any, rv);\n        for (var prop in any) {\n            if (hasOwn(any, prop)) {\n                rv[prop] = innerDeepClone(any[prop]);\n            }\n        }\n    }\n    return rv;\n}\nconst { toString } = {};\nfunction toStringTag(o) {\n    return toString.call(o).slice(8, -1);\n}\nconst iteratorSymbol = typeof Symbol !== 'undefined' ?\n    Symbol.iterator :\n    '@@iterator';\nconst getIteratorOf = typeof iteratorSymbol === \"symbol\" ? function (x) {\n    var i;\n    return x != null && (i = x[iteratorSymbol]) && i.apply(x);\n} : function () { return null; };\nconst NO_CHAR_ARRAY = {};\nfunction getArrayOf(arrayLike) {\n    var i, a, x, it;\n    if (arguments.length === 1) {\n        if (isArray(arrayLike))\n            return arrayLike.slice();\n        if (this === NO_CHAR_ARRAY && typeof arrayLike === 'string')\n            return [arrayLike];\n        if ((it = getIteratorOf(arrayLike))) {\n            a = [];\n            while ((x = it.next()), !x.done)\n                a.push(x.value);\n            return a;\n        }\n        if (arrayLike == null)\n            return [arrayLike];\n        i = arrayLike.length;\n        if (typeof i === 'number') {\n            a = new Array(i);\n            while (i--)\n                a[i] = arrayLike[i];\n            return a;\n        }\n        return [arrayLike];\n    }\n    i = arguments.length;\n    a = new Array(i);\n    while (i--)\n        a[i] = arguments[i];\n    return a;\n}\nconst isAsyncFunction = typeof Symbol !== 'undefined'\n    ? (fn) => fn[Symbol.toStringTag] === 'AsyncFunction'\n    : () => false;\n\nvar debug = typeof location !== 'undefined' &&\n    /^(http|https):\\/\\/(localhost|127\\.0\\.0\\.1)/.test(location.href);\nfunction setDebug(value, filter) {\n    debug = value;\n    libraryFilter = filter;\n}\nvar libraryFilter = () => true;\nconst NEEDS_THROW_FOR_STACK = !new Error(\"\").stack;\nfunction getErrorWithStack() {\n    if (NEEDS_THROW_FOR_STACK)\n        try {\n            getErrorWithStack.arguments;\n            throw new Error();\n        }\n        catch (e) {\n            return e;\n        }\n    return new Error();\n}\nfunction prettyStack(exception, numIgnoredFrames) {\n    var stack = exception.stack;\n    if (!stack)\n        return \"\";\n    numIgnoredFrames = (numIgnoredFrames || 0);\n    if (stack.indexOf(exception.name) === 0)\n        numIgnoredFrames += (exception.name + exception.message).split('\\n').length;\n    return stack.split('\\n')\n        .slice(numIgnoredFrames)\n        .filter(libraryFilter)\n        .map(frame => \"\\n\" + frame)\n        .join('');\n}\n\nvar dexieErrorNames = [\n    'Modify',\n    'Bulk',\n    'OpenFailed',\n    'VersionChange',\n    'Schema',\n    'Upgrade',\n    'InvalidTable',\n    'MissingAPI',\n    'NoSuchDatabase',\n    'InvalidArgument',\n    'SubTransaction',\n    'Unsupported',\n    'Internal',\n    'DatabaseClosed',\n    'PrematureCommit',\n    'ForeignAwait'\n];\nvar idbDomErrorNames = [\n    'Unknown',\n    'Constraint',\n    'Data',\n    'TransactionInactive',\n    'ReadOnly',\n    'Version',\n    'NotFound',\n    'InvalidState',\n    'InvalidAccess',\n    'Abort',\n    'Timeout',\n    'QuotaExceeded',\n    'Syntax',\n    'DataClone'\n];\nvar errorList = dexieErrorNames.concat(idbDomErrorNames);\nvar defaultTexts = {\n    VersionChanged: \"Database version changed by other database connection\",\n    DatabaseClosed: \"Database has been closed\",\n    Abort: \"Transaction aborted\",\n    TransactionInactive: \"Transaction has already completed or failed\",\n    MissingAPI: \"IndexedDB API missing. Please visit https://tinyurl.com/y2uuvskb\"\n};\nfunction DexieError(name, msg) {\n    this._e = getErrorWithStack();\n    this.name = name;\n    this.message = msg;\n}\nderive(DexieError).from(Error).extend({\n    stack: {\n        get: function () {\n            return this._stack ||\n                (this._stack = this.name + \": \" + this.message + prettyStack(this._e, 2));\n        }\n    },\n    toString: function () { return this.name + \": \" + this.message; }\n});\nfunction getMultiErrorMessage(msg, failures) {\n    return msg + \". Errors: \" + Object.keys(failures)\n        .map(key => failures[key].toString())\n        .filter((v, i, s) => s.indexOf(v) === i)\n        .join('\\n');\n}\nfunction ModifyError(msg, failures, successCount, failedKeys) {\n    this._e = getErrorWithStack();\n    this.failures = failures;\n    this.failedKeys = failedKeys;\n    this.successCount = successCount;\n    this.message = getMultiErrorMessage(msg, failures);\n}\nderive(ModifyError).from(DexieError);\nfunction BulkError(msg, failures) {\n    this._e = getErrorWithStack();\n    this.name = \"BulkError\";\n    this.failures = Object.keys(failures).map(pos => failures[pos]);\n    this.failuresByPos = failures;\n    this.message = getMultiErrorMessage(msg, failures);\n}\nderive(BulkError).from(DexieError);\nvar errnames = errorList.reduce((obj, name) => (obj[name] = name + \"Error\", obj), {});\nconst BaseException = DexieError;\nvar exceptions = errorList.reduce((obj, name) => {\n    var fullName = name + \"Error\";\n    function DexieError(msgOrInner, inner) {\n        this._e = getErrorWithStack();\n        this.name = fullName;\n        if (!msgOrInner) {\n            this.message = defaultTexts[name] || fullName;\n            this.inner = null;\n        }\n        else if (typeof msgOrInner === 'string') {\n            this.message = `${msgOrInner}${!inner ? '' : '\\n ' + inner}`;\n            this.inner = inner || null;\n        }\n        else if (typeof msgOrInner === 'object') {\n            this.message = `${msgOrInner.name} ${msgOrInner.message}`;\n            this.inner = msgOrInner;\n        }\n    }\n    derive(DexieError).from(BaseException);\n    obj[name] = DexieError;\n    return obj;\n}, {});\nexceptions.Syntax = SyntaxError;\nexceptions.Type = TypeError;\nexceptions.Range = RangeError;\nvar exceptionMap = idbDomErrorNames.reduce((obj, name) => {\n    obj[name + \"Error\"] = exceptions[name];\n    return obj;\n}, {});\nfunction mapError(domError, message) {\n    if (!domError || domError instanceof DexieError || domError instanceof TypeError || domError instanceof SyntaxError || !domError.name || !exceptionMap[domError.name])\n        return domError;\n    var rv = new exceptionMap[domError.name](message || domError.message, domError);\n    if (\"stack\" in domError) {\n        setProp(rv, \"stack\", { get: function () {\n                return this.inner.stack;\n            } });\n    }\n    return rv;\n}\nvar fullNameExceptions = errorList.reduce((obj, name) => {\n    if ([\"Syntax\", \"Type\", \"Range\"].indexOf(name) === -1)\n        obj[name + \"Error\"] = exceptions[name];\n    return obj;\n}, {});\nfullNameExceptions.ModifyError = ModifyError;\nfullNameExceptions.DexieError = DexieError;\nfullNameExceptions.BulkError = BulkError;\n\nfunction nop() { }\nfunction mirror(val) { return val; }\nfunction pureFunctionChain(f1, f2) {\n    if (f1 == null || f1 === mirror)\n        return f2;\n    return function (val) {\n        return f2(f1(val));\n    };\n}\nfunction callBoth(on1, on2) {\n    return function () {\n        on1.apply(this, arguments);\n        on2.apply(this, arguments);\n    };\n}\nfunction hookCreatingChain(f1, f2) {\n    if (f1 === nop)\n        return f2;\n    return function () {\n        var res = f1.apply(this, arguments);\n        if (res !== undefined)\n            arguments[0] = res;\n        var onsuccess = this.onsuccess,\n        onerror = this.onerror;\n        this.onsuccess = null;\n        this.onerror = null;\n        var res2 = f2.apply(this, arguments);\n        if (onsuccess)\n            this.onsuccess = this.onsuccess ? callBoth(onsuccess, this.onsuccess) : onsuccess;\n        if (onerror)\n            this.onerror = this.onerror ? callBoth(onerror, this.onerror) : onerror;\n        return res2 !== undefined ? res2 : res;\n    };\n}\nfunction hookDeletingChain(f1, f2) {\n    if (f1 === nop)\n        return f2;\n    return function () {\n        f1.apply(this, arguments);\n        var onsuccess = this.onsuccess,\n        onerror = this.onerror;\n        this.onsuccess = this.onerror = null;\n        f2.apply(this, arguments);\n        if (onsuccess)\n            this.onsuccess = this.onsuccess ? callBoth(onsuccess, this.onsuccess) : onsuccess;\n        if (onerror)\n            this.onerror = this.onerror ? callBoth(onerror, this.onerror) : onerror;\n    };\n}\nfunction hookUpdatingChain(f1, f2) {\n    if (f1 === nop)\n        return f2;\n    return function (modifications) {\n        var res = f1.apply(this, arguments);\n        extend(modifications, res);\n        var onsuccess = this.onsuccess,\n        onerror = this.onerror;\n        this.onsuccess = null;\n        this.onerror = null;\n        var res2 = f2.apply(this, arguments);\n        if (onsuccess)\n            this.onsuccess = this.onsuccess ? callBoth(onsuccess, this.onsuccess) : onsuccess;\n        if (onerror)\n            this.onerror = this.onerror ? callBoth(onerror, this.onerror) : onerror;\n        return res === undefined ?\n            (res2 === undefined ? undefined : res2) :\n            (extend(res, res2));\n    };\n}\nfunction reverseStoppableEventChain(f1, f2) {\n    if (f1 === nop)\n        return f2;\n    return function () {\n        if (f2.apply(this, arguments) === false)\n            return false;\n        return f1.apply(this, arguments);\n    };\n}\nfunction promisableChain(f1, f2) {\n    if (f1 === nop)\n        return f2;\n    return function () {\n        var res = f1.apply(this, arguments);\n        if (res && typeof res.then === 'function') {\n            var thiz = this, i = arguments.length, args = new Array(i);\n            while (i--)\n                args[i] = arguments[i];\n            return res.then(function () {\n                return f2.apply(thiz, args);\n            });\n        }\n        return f2.apply(this, arguments);\n    };\n}\n\nvar INTERNAL = {};\nconst LONG_STACKS_CLIP_LIMIT = 100,\nMAX_LONG_STACKS = 20, ZONE_ECHO_LIMIT = 100, [resolvedNativePromise, nativePromiseProto, resolvedGlobalPromise] = typeof Promise === 'undefined' ?\n    [] :\n    (() => {\n        let globalP = Promise.resolve();\n        if (typeof crypto === 'undefined' || !crypto.subtle)\n            return [globalP, getProto(globalP), globalP];\n        const nativeP = crypto.subtle.digest(\"SHA-512\", new Uint8Array([0]));\n        return [\n            nativeP,\n            getProto(nativeP),\n            globalP\n        ];\n    })(), nativePromiseThen = nativePromiseProto && nativePromiseProto.then;\nconst NativePromise = resolvedNativePromise && resolvedNativePromise.constructor;\nconst patchGlobalPromise = !!resolvedGlobalPromise;\nvar stack_being_generated = false;\nvar schedulePhysicalTick = resolvedGlobalPromise ?\n    () => { resolvedGlobalPromise.then(physicalTick); }\n    :\n        _global.setImmediate ?\n            setImmediate.bind(null, physicalTick) :\n            _global.MutationObserver ?\n                () => {\n                    var hiddenDiv = document.createElement(\"div\");\n                    (new MutationObserver(() => {\n                        physicalTick();\n                        hiddenDiv = null;\n                    })).observe(hiddenDiv, { attributes: true });\n                    hiddenDiv.setAttribute('i', '1');\n                } :\n                () => { setTimeout(physicalTick, 0); };\nvar asap = function (callback, args) {\n    microtickQueue.push([callback, args]);\n    if (needsNewPhysicalTick) {\n        schedulePhysicalTick();\n        needsNewPhysicalTick = false;\n    }\n};\nvar isOutsideMicroTick = true,\nneedsNewPhysicalTick = true,\nunhandledErrors = [],\nrejectingErrors = [],\ncurrentFulfiller = null, rejectionMapper = mirror;\nvar globalPSD = {\n    id: 'global',\n    global: true,\n    ref: 0,\n    unhandleds: [],\n    onunhandled: globalError,\n    pgp: false,\n    env: {},\n    finalize: function () {\n        this.unhandleds.forEach(uh => {\n            try {\n                globalError(uh[0], uh[1]);\n            }\n            catch (e) { }\n        });\n    }\n};\nvar PSD = globalPSD;\nvar microtickQueue = [];\nvar numScheduledCalls = 0;\nvar tickFinalizers = [];\nfunction DexiePromise(fn) {\n    if (typeof this !== 'object')\n        throw new TypeError('Promises must be constructed via new');\n    this._listeners = [];\n    this.onuncatched = nop;\n    this._lib = false;\n    var psd = (this._PSD = PSD);\n    if (debug) {\n        this._stackHolder = getErrorWithStack();\n        this._prev = null;\n        this._numPrev = 0;\n    }\n    if (typeof fn !== 'function') {\n        if (fn !== INTERNAL)\n            throw new TypeError('Not a function');\n        this._state = arguments[1];\n        this._value = arguments[2];\n        if (this._state === false)\n            handleRejection(this, this._value);\n        return;\n    }\n    this._state = null;\n    this._value = null;\n    ++psd.ref;\n    executePromiseTask(this, fn);\n}\nconst thenProp = {\n    get: function () {\n        var psd = PSD, microTaskId = totalEchoes;\n        function then(onFulfilled, onRejected) {\n            var possibleAwait = !psd.global && (psd !== PSD || microTaskId !== totalEchoes);\n            const cleanup = possibleAwait && !decrementExpectedAwaits();\n            var rv = new DexiePromise((resolve, reject) => {\n                propagateToListener(this, new Listener(nativeAwaitCompatibleWrap(onFulfilled, psd, possibleAwait, cleanup), nativeAwaitCompatibleWrap(onRejected, psd, possibleAwait, cleanup), resolve, reject, psd));\n            });\n            debug && linkToPreviousPromise(rv, this);\n            return rv;\n        }\n        then.prototype = INTERNAL;\n        return then;\n    },\n    set: function (value) {\n        setProp(this, 'then', value && value.prototype === INTERNAL ?\n            thenProp :\n            {\n                get: function () {\n                    return value;\n                },\n                set: thenProp.set\n            });\n    }\n};\nprops(DexiePromise.prototype, {\n    then: thenProp,\n    _then: function (onFulfilled, onRejected) {\n        propagateToListener(this, new Listener(null, null, onFulfilled, onRejected, PSD));\n    },\n    catch: function (onRejected) {\n        if (arguments.length === 1)\n            return this.then(null, onRejected);\n        var type = arguments[0], handler = arguments[1];\n        return typeof type === 'function' ? this.then(null, err =>\n        err instanceof type ? handler(err) : PromiseReject(err))\n            : this.then(null, err =>\n            err && err.name === type ? handler(err) : PromiseReject(err));\n    },\n    finally: function (onFinally) {\n        return this.then(value => {\n            onFinally();\n            return value;\n        }, err => {\n            onFinally();\n            return PromiseReject(err);\n        });\n    },\n    stack: {\n        get: function () {\n            if (this._stack)\n                return this._stack;\n            try {\n                stack_being_generated = true;\n                var stacks = getStack(this, [], MAX_LONG_STACKS);\n                var stack = stacks.join(\"\\nFrom previous: \");\n                if (this._state !== null)\n                    this._stack = stack;\n                return stack;\n            }\n            finally {\n                stack_being_generated = false;\n            }\n        }\n    },\n    timeout: function (ms, msg) {\n        return ms < Infinity ?\n            new DexiePromise((resolve, reject) => {\n                var handle = setTimeout(() => reject(new exceptions.Timeout(msg)), ms);\n                this.then(resolve, reject).finally(clearTimeout.bind(null, handle));\n            }) : this;\n    }\n});\nif (typeof Symbol !== 'undefined' && Symbol.toStringTag)\n    setProp(DexiePromise.prototype, Symbol.toStringTag, 'Dexie.Promise');\nglobalPSD.env = snapShot();\nfunction Listener(onFulfilled, onRejected, resolve, reject, zone) {\n    this.onFulfilled = typeof onFulfilled === 'function' ? onFulfilled : null;\n    this.onRejected = typeof onRejected === 'function' ? onRejected : null;\n    this.resolve = resolve;\n    this.reject = reject;\n    this.psd = zone;\n}\nprops(DexiePromise, {\n    all: function () {\n        var values = getArrayOf.apply(null, arguments)\n            .map(onPossibleParallellAsync);\n        return new DexiePromise(function (resolve, reject) {\n            if (values.length === 0)\n                resolve([]);\n            var remaining = values.length;\n            values.forEach((a, i) => DexiePromise.resolve(a).then(x => {\n                values[i] = x;\n                if (!--remaining)\n                    resolve(values);\n            }, reject));\n        });\n    },\n    resolve: value => {\n        if (value instanceof DexiePromise)\n            return value;\n        if (value && typeof value.then === 'function')\n            return new DexiePromise((resolve, reject) => {\n                value.then(resolve, reject);\n            });\n        var rv = new DexiePromise(INTERNAL, true, value);\n        linkToPreviousPromise(rv, currentFulfiller);\n        return rv;\n    },\n    reject: PromiseReject,\n    race: function () {\n        var values = getArrayOf.apply(null, arguments).map(onPossibleParallellAsync);\n        return new DexiePromise((resolve, reject) => {\n            values.map(value => DexiePromise.resolve(value).then(resolve, reject));\n        });\n    },\n    PSD: {\n        get: () => PSD,\n        set: value => PSD = value\n    },\n    totalEchoes: { get: () => totalEchoes },\n    newPSD: newScope,\n    usePSD: usePSD,\n    scheduler: {\n        get: () => asap,\n        set: value => { asap = value; }\n    },\n    rejectionMapper: {\n        get: () => rejectionMapper,\n        set: value => { rejectionMapper = value; }\n    },\n    follow: (fn, zoneProps) => {\n        return new DexiePromise((resolve, reject) => {\n            return newScope((resolve, reject) => {\n                var psd = PSD;\n                psd.unhandleds = [];\n                psd.onunhandled = reject;\n                psd.finalize = callBoth(function () {\n                    run_at_end_of_this_or_next_physical_tick(() => {\n                        this.unhandleds.length === 0 ? resolve() : reject(this.unhandleds[0]);\n                    });\n                }, psd.finalize);\n                fn();\n            }, zoneProps, resolve, reject);\n        });\n    }\n});\nif (NativePromise) {\n    if (NativePromise.allSettled)\n        setProp(DexiePromise, \"allSettled\", function () {\n            const possiblePromises = getArrayOf.apply(null, arguments).map(onPossibleParallellAsync);\n            return new DexiePromise(resolve => {\n                if (possiblePromises.length === 0)\n                    resolve([]);\n                let remaining = possiblePromises.length;\n                const results = new Array(remaining);\n                possiblePromises.forEach((p, i) => DexiePromise.resolve(p).then(value => results[i] = { status: \"fulfilled\", value }, reason => results[i] = { status: \"rejected\", reason })\n                    .then(() => --remaining || resolve(results)));\n            });\n        });\n    if (NativePromise.any && typeof AggregateError !== 'undefined')\n        setProp(DexiePromise, \"any\", function () {\n            const possiblePromises = getArrayOf.apply(null, arguments).map(onPossibleParallellAsync);\n            return new DexiePromise((resolve, reject) => {\n                if (possiblePromises.length === 0)\n                    reject(new AggregateError([]));\n                let remaining = possiblePromises.length;\n                const failures = new Array(remaining);\n                possiblePromises.forEach((p, i) => DexiePromise.resolve(p).then(value => resolve(value), failure => {\n                    failures[i] = failure;\n                    if (!--remaining)\n                        reject(new AggregateError(failures));\n                }));\n            });\n        });\n}\nfunction executePromiseTask(promise, fn) {\n    try {\n        fn(value => {\n            if (promise._state !== null)\n                return;\n            if (value === promise)\n                throw new TypeError('A promise cannot be resolved with itself.');\n            var shouldExecuteTick = promise._lib && beginMicroTickScope();\n            if (value && typeof value.then === 'function') {\n                executePromiseTask(promise, (resolve, reject) => {\n                    value instanceof DexiePromise ?\n                        value._then(resolve, reject) :\n                        value.then(resolve, reject);\n                });\n            }\n            else {\n                promise._state = true;\n                promise._value = value;\n                propagateAllListeners(promise);\n            }\n            if (shouldExecuteTick)\n                endMicroTickScope();\n        }, handleRejection.bind(null, promise));\n    }\n    catch (ex) {\n        handleRejection(promise, ex);\n    }\n}\nfunction handleRejection(promise, reason) {\n    rejectingErrors.push(reason);\n    if (promise._state !== null)\n        return;\n    var shouldExecuteTick = promise._lib && beginMicroTickScope();\n    reason = rejectionMapper(reason);\n    promise._state = false;\n    promise._value = reason;\n    debug && reason !== null && typeof reason === 'object' && !reason._promise && tryCatch(() => {\n        var origProp = getPropertyDescriptor(reason, \"stack\");\n        reason._promise = promise;\n        setProp(reason, \"stack\", {\n            get: () => stack_being_generated ?\n                origProp && (origProp.get ?\n                    origProp.get.apply(reason) :\n                    origProp.value) :\n                promise.stack\n        });\n    });\n    addPossiblyUnhandledError(promise);\n    propagateAllListeners(promise);\n    if (shouldExecuteTick)\n        endMicroTickScope();\n}\nfunction propagateAllListeners(promise) {\n    var listeners = promise._listeners;\n    promise._listeners = [];\n    for (var i = 0, len = listeners.length; i < len; ++i) {\n        propagateToListener(promise, listeners[i]);\n    }\n    var psd = promise._PSD;\n    --psd.ref || psd.finalize();\n    if (numScheduledCalls === 0) {\n        ++numScheduledCalls;\n        asap(() => {\n            if (--numScheduledCalls === 0)\n                finalizePhysicalTick();\n        }, []);\n    }\n}\nfunction propagateToListener(promise, listener) {\n    if (promise._state === null) {\n        promise._listeners.push(listener);\n        return;\n    }\n    var cb = promise._state ? listener.onFulfilled : listener.onRejected;\n    if (cb === null) {\n        return (promise._state ? listener.resolve : listener.reject)(promise._value);\n    }\n    ++listener.psd.ref;\n    ++numScheduledCalls;\n    asap(callListener, [cb, promise, listener]);\n}\nfunction callListener(cb, promise, listener) {\n    try {\n        currentFulfiller = promise;\n        var ret, value = promise._value;\n        if (promise._state) {\n            ret = cb(value);\n        }\n        else {\n            if (rejectingErrors.length)\n                rejectingErrors = [];\n            ret = cb(value);\n            if (rejectingErrors.indexOf(value) === -1)\n                markErrorAsHandled(promise);\n        }\n        listener.resolve(ret);\n    }\n    catch (e) {\n        listener.reject(e);\n    }\n    finally {\n        currentFulfiller = null;\n        if (--numScheduledCalls === 0)\n            finalizePhysicalTick();\n        --listener.psd.ref || listener.psd.finalize();\n    }\n}\nfunction getStack(promise, stacks, limit) {\n    if (stacks.length === limit)\n        return stacks;\n    var stack = \"\";\n    if (promise._state === false) {\n        var failure = promise._value, errorName, message;\n        if (failure != null) {\n            errorName = failure.name || \"Error\";\n            message = failure.message || failure;\n            stack = prettyStack(failure, 0);\n        }\n        else {\n            errorName = failure;\n            message = \"\";\n        }\n        stacks.push(errorName + (message ? \": \" + message : \"\") + stack);\n    }\n    if (debug) {\n        stack = prettyStack(promise._stackHolder, 2);\n        if (stack && stacks.indexOf(stack) === -1)\n            stacks.push(stack);\n        if (promise._prev)\n            getStack(promise._prev, stacks, limit);\n    }\n    return stacks;\n}\nfunction linkToPreviousPromise(promise, prev) {\n    var numPrev = prev ? prev._numPrev + 1 : 0;\n    if (numPrev < LONG_STACKS_CLIP_LIMIT) {\n        promise._prev = prev;\n        promise._numPrev = numPrev;\n    }\n}\nfunction physicalTick() {\n    beginMicroTickScope() && endMicroTickScope();\n}\nfunction beginMicroTickScope() {\n    var wasRootExec = isOutsideMicroTick;\n    isOutsideMicroTick = false;\n    needsNewPhysicalTick = false;\n    return wasRootExec;\n}\nfunction endMicroTickScope() {\n    var callbacks, i, l;\n    do {\n        while (microtickQueue.length > 0) {\n            callbacks = microtickQueue;\n            microtickQueue = [];\n            l = callbacks.length;\n            for (i = 0; i < l; ++i) {\n                var item = callbacks[i];\n                item[0].apply(null, item[1]);\n            }\n        }\n    } while (microtickQueue.length > 0);\n    isOutsideMicroTick = true;\n    needsNewPhysicalTick = true;\n}\nfunction finalizePhysicalTick() {\n    var unhandledErrs = unhandledErrors;\n    unhandledErrors = [];\n    unhandledErrs.forEach(p => {\n        p._PSD.onunhandled.call(null, p._value, p);\n    });\n    var finalizers = tickFinalizers.slice(0);\n    var i = finalizers.length;\n    while (i)\n        finalizers[--i]();\n}\nfunction run_at_end_of_this_or_next_physical_tick(fn) {\n    function finalizer() {\n        fn();\n        tickFinalizers.splice(tickFinalizers.indexOf(finalizer), 1);\n    }\n    tickFinalizers.push(finalizer);\n    ++numScheduledCalls;\n    asap(() => {\n        if (--numScheduledCalls === 0)\n            finalizePhysicalTick();\n    }, []);\n}\nfunction addPossiblyUnhandledError(promise) {\n    if (!unhandledErrors.some(p => p._value === promise._value))\n        unhandledErrors.push(promise);\n}\nfunction markErrorAsHandled(promise) {\n    var i = unhandledErrors.length;\n    while (i)\n        if (unhandledErrors[--i]._value === promise._value) {\n            unhandledErrors.splice(i, 1);\n            return;\n        }\n}\nfunction PromiseReject(reason) {\n    return new DexiePromise(INTERNAL, false, reason);\n}\nfunction wrap(fn, errorCatcher) {\n    var psd = PSD;\n    return function () {\n        var wasRootExec = beginMicroTickScope(), outerScope = PSD;\n        try {\n            switchToZone(psd, true);\n            return fn.apply(this, arguments);\n        }\n        catch (e) {\n            errorCatcher && errorCatcher(e);\n        }\n        finally {\n            switchToZone(outerScope, false);\n            if (wasRootExec)\n                endMicroTickScope();\n        }\n    };\n}\nconst task = { awaits: 0, echoes: 0, id: 0 };\nvar taskCounter = 0;\nvar zoneStack = [];\nvar zoneEchoes = 0;\nvar totalEchoes = 0;\nvar zone_id_counter = 0;\nfunction newScope(fn, props, a1, a2) {\n    var parent = PSD, psd = Object.create(parent);\n    psd.parent = parent;\n    psd.ref = 0;\n    psd.global = false;\n    psd.id = ++zone_id_counter;\n    var globalEnv = globalPSD.env;\n    psd.env = patchGlobalPromise ? {\n        Promise: DexiePromise,\n        PromiseProp: { value: DexiePromise, configurable: true, writable: true },\n        all: DexiePromise.all,\n        race: DexiePromise.race,\n        allSettled: DexiePromise.allSettled,\n        any: DexiePromise.any,\n        resolve: DexiePromise.resolve,\n        reject: DexiePromise.reject,\n        nthen: getPatchedPromiseThen(globalEnv.nthen, psd),\n        gthen: getPatchedPromiseThen(globalEnv.gthen, psd)\n    } : {};\n    if (props)\n        extend(psd, props);\n    ++parent.ref;\n    psd.finalize = function () {\n        --this.parent.ref || this.parent.finalize();\n    };\n    var rv = usePSD(psd, fn, a1, a2);\n    if (psd.ref === 0)\n        psd.finalize();\n    return rv;\n}\nfunction incrementExpectedAwaits() {\n    if (!task.id)\n        task.id = ++taskCounter;\n    ++task.awaits;\n    task.echoes += ZONE_ECHO_LIMIT;\n    return task.id;\n}\nfunction decrementExpectedAwaits() {\n    if (!task.awaits)\n        return false;\n    if (--task.awaits === 0)\n        task.id = 0;\n    task.echoes = task.awaits * ZONE_ECHO_LIMIT;\n    return true;\n}\nif (('' + nativePromiseThen).indexOf('[native code]') === -1) {\n    incrementExpectedAwaits = decrementExpectedAwaits = nop;\n}\nfunction onPossibleParallellAsync(possiblePromise) {\n    if (task.echoes && possiblePromise && possiblePromise.constructor === NativePromise) {\n        incrementExpectedAwaits();\n        return possiblePromise.then(x => {\n            decrementExpectedAwaits();\n            return x;\n        }, e => {\n            decrementExpectedAwaits();\n            return rejection(e);\n        });\n    }\n    return possiblePromise;\n}\nfunction zoneEnterEcho(targetZone) {\n    ++totalEchoes;\n    if (!task.echoes || --task.echoes === 0) {\n        task.echoes = task.id = 0;\n    }\n    zoneStack.push(PSD);\n    switchToZone(targetZone, true);\n}\nfunction zoneLeaveEcho() {\n    var zone = zoneStack[zoneStack.length - 1];\n    zoneStack.pop();\n    switchToZone(zone, false);\n}\nfunction switchToZone(targetZone, bEnteringZone) {\n    var currentZone = PSD;\n    if (bEnteringZone ? task.echoes && (!zoneEchoes++ || targetZone !== PSD) : zoneEchoes && (!--zoneEchoes || targetZone !== PSD)) {\n        enqueueNativeMicroTask(bEnteringZone ? zoneEnterEcho.bind(null, targetZone) : zoneLeaveEcho);\n    }\n    if (targetZone === PSD)\n        return;\n    PSD = targetZone;\n    if (currentZone === globalPSD)\n        globalPSD.env = snapShot();\n    if (patchGlobalPromise) {\n        var GlobalPromise = globalPSD.env.Promise;\n        var targetEnv = targetZone.env;\n        nativePromiseProto.then = targetEnv.nthen;\n        GlobalPromise.prototype.then = targetEnv.gthen;\n        if (currentZone.global || targetZone.global) {\n            Object.defineProperty(_global, 'Promise', targetEnv.PromiseProp);\n            GlobalPromise.all = targetEnv.all;\n            GlobalPromise.race = targetEnv.race;\n            GlobalPromise.resolve = targetEnv.resolve;\n            GlobalPromise.reject = targetEnv.reject;\n            if (targetEnv.allSettled)\n                GlobalPromise.allSettled = targetEnv.allSettled;\n            if (targetEnv.any)\n                GlobalPromise.any = targetEnv.any;\n        }\n    }\n}\nfunction snapShot() {\n    var GlobalPromise = _global.Promise;\n    return patchGlobalPromise ? {\n        Promise: GlobalPromise,\n        PromiseProp: Object.getOwnPropertyDescriptor(_global, \"Promise\"),\n        all: GlobalPromise.all,\n        race: GlobalPromise.race,\n        allSettled: GlobalPromise.allSettled,\n        any: GlobalPromise.any,\n        resolve: GlobalPromise.resolve,\n        reject: GlobalPromise.reject,\n        nthen: nativePromiseProto.then,\n        gthen: GlobalPromise.prototype.then\n    } : {};\n}\nfunction usePSD(psd, fn, a1, a2, a3) {\n    var outerScope = PSD;\n    try {\n        switchToZone(psd, true);\n        return fn(a1, a2, a3);\n    }\n    finally {\n        switchToZone(outerScope, false);\n    }\n}\nfunction enqueueNativeMicroTask(job) {\n    nativePromiseThen.call(resolvedNativePromise, job);\n}\nfunction nativeAwaitCompatibleWrap(fn, zone, possibleAwait, cleanup) {\n    return typeof fn !== 'function' ? fn : function () {\n        var outerZone = PSD;\n        if (possibleAwait)\n            incrementExpectedAwaits();\n        switchToZone(zone, true);\n        try {\n            return fn.apply(this, arguments);\n        }\n        finally {\n            switchToZone(outerZone, false);\n            if (cleanup)\n                enqueueNativeMicroTask(decrementExpectedAwaits);\n        }\n    };\n}\nfunction getPatchedPromiseThen(origThen, zone) {\n    return function (onResolved, onRejected) {\n        return origThen.call(this, nativeAwaitCompatibleWrap(onResolved, zone), nativeAwaitCompatibleWrap(onRejected, zone));\n    };\n}\nconst UNHANDLEDREJECTION = \"unhandledrejection\";\nfunction globalError(err, promise) {\n    var rv;\n    try {\n        rv = promise.onuncatched(err);\n    }\n    catch (e) { }\n    if (rv !== false)\n        try {\n            var event, eventData = { promise: promise, reason: err };\n            if (_global.document && document.createEvent) {\n                event = document.createEvent('Event');\n                event.initEvent(UNHANDLEDREJECTION, true, true);\n                extend(event, eventData);\n            }\n            else if (_global.CustomEvent) {\n                event = new CustomEvent(UNHANDLEDREJECTION, { detail: eventData });\n                extend(event, eventData);\n            }\n            if (event && _global.dispatchEvent) {\n                dispatchEvent(event);\n                if (!_global.PromiseRejectionEvent && _global.onunhandledrejection)\n                    try {\n                        _global.onunhandledrejection(event);\n                    }\n                    catch (_) { }\n            }\n            if (debug && event && !event.defaultPrevented) {\n                console.warn(`Unhandled rejection: ${err.stack || err}`);\n            }\n        }\n        catch (e) { }\n}\nvar rejection = DexiePromise.reject;\n\nfunction tempTransaction(db, mode, storeNames, fn) {\n    if (!db.idbdb || (!db._state.openComplete && (!PSD.letThrough && !db._vip))) {\n        if (db._state.openComplete) {\n            return rejection(new exceptions.DatabaseClosed(db._state.dbOpenError));\n        }\n        if (!db._state.isBeingOpened) {\n            if (!db._options.autoOpen)\n                return rejection(new exceptions.DatabaseClosed());\n            db.open().catch(nop);\n        }\n        return db._state.dbReadyPromise.then(() => tempTransaction(db, mode, storeNames, fn));\n    }\n    else {\n        var trans = db._createTransaction(mode, storeNames, db._dbSchema);\n        try {\n            trans.create();\n            db._state.PR1398_maxLoop = 3;\n        }\n        catch (ex) {\n            if (ex.name === errnames.InvalidState && db.isOpen() && --db._state.PR1398_maxLoop > 0) {\n                console.warn('Dexie: Need to reopen db');\n                db._close();\n                return db.open().then(() => tempTransaction(db, mode, storeNames, fn));\n            }\n            return rejection(ex);\n        }\n        return trans._promise(mode, (resolve, reject) => {\n            return newScope(() => {\n                PSD.trans = trans;\n                return fn(resolve, reject, trans);\n            });\n        }).then(result => {\n            return trans._completion.then(() => result);\n        });\n    }\n}\n\nconst DEXIE_VERSION = '3.2.7';\nconst maxString = String.fromCharCode(65535);\nconst minKey = -Infinity;\nconst INVALID_KEY_ARGUMENT = \"Invalid key provided. Keys must be of type string, number, Date or Array<string | number | Date>.\";\nconst STRING_EXPECTED = \"String expected.\";\nconst connections = [];\nconst isIEOrEdge = typeof navigator !== 'undefined' && /(MSIE|Trident|Edge)/.test(navigator.userAgent);\nconst hasIEDeleteObjectStoreBug = isIEOrEdge;\nconst hangsOnDeleteLargeKeyRange = isIEOrEdge;\nconst dexieStackFrameFilter = frame => !/(dexie\\.js|dexie\\.min\\.js)/.test(frame);\nconst DBNAMES_DB = '__dbnames';\nconst READONLY = 'readonly';\nconst READWRITE = 'readwrite';\n\nfunction combine(filter1, filter2) {\n    return filter1 ?\n        filter2 ?\n            function () { return filter1.apply(this, arguments) && filter2.apply(this, arguments); } :\n            filter1 :\n        filter2;\n}\n\nconst AnyRange = {\n    type: 3 ,\n    lower: -Infinity,\n    lowerOpen: false,\n    upper: [[]],\n    upperOpen: false\n};\n\nfunction workaroundForUndefinedPrimKey(keyPath) {\n    return typeof keyPath === \"string\" && !/\\./.test(keyPath)\n        ? (obj) => {\n            if (obj[keyPath] === undefined && (keyPath in obj)) {\n                obj = deepClone(obj);\n                delete obj[keyPath];\n            }\n            return obj;\n        }\n        : (obj) => obj;\n}\n\nclass Table {\n    _trans(mode, fn, writeLocked) {\n        const trans = this._tx || PSD.trans;\n        const tableName = this.name;\n        function checkTableInTransaction(resolve, reject, trans) {\n            if (!trans.schema[tableName])\n                throw new exceptions.NotFound(\"Table \" + tableName + \" not part of transaction\");\n            return fn(trans.idbtrans, trans);\n        }\n        const wasRootExec = beginMicroTickScope();\n        try {\n            return trans && trans.db === this.db ?\n                trans === PSD.trans ?\n                    trans._promise(mode, checkTableInTransaction, writeLocked) :\n                    newScope(() => trans._promise(mode, checkTableInTransaction, writeLocked), { trans: trans, transless: PSD.transless || PSD }) :\n                tempTransaction(this.db, mode, [this.name], checkTableInTransaction);\n        }\n        finally {\n            if (wasRootExec)\n                endMicroTickScope();\n        }\n    }\n    get(keyOrCrit, cb) {\n        if (keyOrCrit && keyOrCrit.constructor === Object)\n            return this.where(keyOrCrit).first(cb);\n        return this._trans('readonly', (trans) => {\n            return this.core.get({ trans, key: keyOrCrit })\n                .then(res => this.hook.reading.fire(res));\n        }).then(cb);\n    }\n    where(indexOrCrit) {\n        if (typeof indexOrCrit === 'string')\n            return new this.db.WhereClause(this, indexOrCrit);\n        if (isArray(indexOrCrit))\n            return new this.db.WhereClause(this, `[${indexOrCrit.join('+')}]`);\n        const keyPaths = keys(indexOrCrit);\n        if (keyPaths.length === 1)\n            return this\n                .where(keyPaths[0])\n                .equals(indexOrCrit[keyPaths[0]]);\n        const compoundIndex = this.schema.indexes.concat(this.schema.primKey).filter(ix => {\n            if (ix.compound &&\n                keyPaths.every(keyPath => ix.keyPath.indexOf(keyPath) >= 0)) {\n                for (let i = 0; i < keyPaths.length; ++i) {\n                    if (keyPaths.indexOf(ix.keyPath[i]) === -1)\n                        return false;\n                }\n                return true;\n            }\n            return false;\n        }).sort((a, b) => a.keyPath.length - b.keyPath.length)[0];\n        if (compoundIndex && this.db._maxKey !== maxString) {\n            const keyPathsInValidOrder = compoundIndex.keyPath.slice(0, keyPaths.length);\n            return this\n                .where(keyPathsInValidOrder)\n                .equals(keyPathsInValidOrder.map(kp => indexOrCrit[kp]));\n        }\n        if (!compoundIndex && debug)\n            console.warn(`The query ${JSON.stringify(indexOrCrit)} on ${this.name} would benefit of a ` +\n                `compound index [${keyPaths.join('+')}]`);\n        const { idxByName } = this.schema;\n        const idb = this.db._deps.indexedDB;\n        function equals(a, b) {\n            try {\n                return idb.cmp(a, b) === 0;\n            }\n            catch (e) {\n                return false;\n            }\n        }\n        const [idx, filterFunction] = keyPaths.reduce(([prevIndex, prevFilterFn], keyPath) => {\n            const index = idxByName[keyPath];\n            const value = indexOrCrit[keyPath];\n            return [\n                prevIndex || index,\n                prevIndex || !index ?\n                    combine(prevFilterFn, index && index.multi ?\n                        x => {\n                            const prop = getByKeyPath(x, keyPath);\n                            return isArray(prop) && prop.some(item => equals(value, item));\n                        } : x => equals(value, getByKeyPath(x, keyPath)))\n                    : prevFilterFn\n            ];\n        }, [null, null]);\n        return idx ?\n            this.where(idx.name).equals(indexOrCrit[idx.keyPath])\n                .filter(filterFunction) :\n            compoundIndex ?\n                this.filter(filterFunction) :\n                this.where(keyPaths).equals('');\n    }\n    filter(filterFunction) {\n        return this.toCollection().and(filterFunction);\n    }\n    count(thenShortcut) {\n        return this.toCollection().count(thenShortcut);\n    }\n    offset(offset) {\n        return this.toCollection().offset(offset);\n    }\n    limit(numRows) {\n        return this.toCollection().limit(numRows);\n    }\n    each(callback) {\n        return this.toCollection().each(callback);\n    }\n    toArray(thenShortcut) {\n        return this.toCollection().toArray(thenShortcut);\n    }\n    toCollection() {\n        return new this.db.Collection(new this.db.WhereClause(this));\n    }\n    orderBy(index) {\n        return new this.db.Collection(new this.db.WhereClause(this, isArray(index) ?\n            `[${index.join('+')}]` :\n            index));\n    }\n    reverse() {\n        return this.toCollection().reverse();\n    }\n    mapToClass(constructor) {\n        this.schema.mappedClass = constructor;\n        const readHook = obj => {\n            if (!obj)\n                return obj;\n            const res = Object.create(constructor.prototype);\n            for (var m in obj)\n                if (hasOwn(obj, m))\n                    try {\n                        res[m] = obj[m];\n                    }\n                    catch (_) { }\n            return res;\n        };\n        if (this.schema.readHook) {\n            this.hook.reading.unsubscribe(this.schema.readHook);\n        }\n        this.schema.readHook = readHook;\n        this.hook(\"reading\", readHook);\n        return constructor;\n    }\n    defineClass() {\n        function Class(content) {\n            extend(this, content);\n        }\n        return this.mapToClass(Class);\n    }\n    add(obj, key) {\n        const { auto, keyPath } = this.schema.primKey;\n        let objToAdd = obj;\n        if (keyPath && auto) {\n            objToAdd = workaroundForUndefinedPrimKey(keyPath)(obj);\n        }\n        return this._trans('readwrite', trans => {\n            return this.core.mutate({ trans, type: 'add', keys: key != null ? [key] : null, values: [objToAdd] });\n        }).then(res => res.numFailures ? DexiePromise.reject(res.failures[0]) : res.lastResult)\n            .then(lastResult => {\n            if (keyPath) {\n                try {\n                    setByKeyPath(obj, keyPath, lastResult);\n                }\n                catch (_) { }\n            }\n            return lastResult;\n        });\n    }\n    update(keyOrObject, modifications) {\n        if (typeof keyOrObject === 'object' && !isArray(keyOrObject)) {\n            const key = getByKeyPath(keyOrObject, this.schema.primKey.keyPath);\n            if (key === undefined)\n                return rejection(new exceptions.InvalidArgument(\"Given object does not contain its primary key\"));\n            try {\n                if (typeof modifications !== \"function\") {\n                    keys(modifications).forEach(keyPath => {\n                        setByKeyPath(keyOrObject, keyPath, modifications[keyPath]);\n                    });\n                }\n                else {\n                    modifications(keyOrObject, { value: keyOrObject, primKey: key });\n                }\n            }\n            catch (_a) {\n            }\n            return this.where(\":id\").equals(key).modify(modifications);\n        }\n        else {\n            return this.where(\":id\").equals(keyOrObject).modify(modifications);\n        }\n    }\n    put(obj, key) {\n        const { auto, keyPath } = this.schema.primKey;\n        let objToAdd = obj;\n        if (keyPath && auto) {\n            objToAdd = workaroundForUndefinedPrimKey(keyPath)(obj);\n        }\n        return this._trans('readwrite', trans => this.core.mutate({ trans, type: 'put', values: [objToAdd], keys: key != null ? [key] : null }))\n            .then(res => res.numFailures ? DexiePromise.reject(res.failures[0]) : res.lastResult)\n            .then(lastResult => {\n            if (keyPath) {\n                try {\n                    setByKeyPath(obj, keyPath, lastResult);\n                }\n                catch (_) { }\n            }\n            return lastResult;\n        });\n    }\n    delete(key) {\n        return this._trans('readwrite', trans => this.core.mutate({ trans, type: 'delete', keys: [key] }))\n            .then(res => res.numFailures ? DexiePromise.reject(res.failures[0]) : undefined);\n    }\n    clear() {\n        return this._trans('readwrite', trans => this.core.mutate({ trans, type: 'deleteRange', range: AnyRange }))\n            .then(res => res.numFailures ? DexiePromise.reject(res.failures[0]) : undefined);\n    }\n    bulkGet(keys) {\n        return this._trans('readonly', trans => {\n            return this.core.getMany({\n                keys,\n                trans\n            }).then(result => result.map(res => this.hook.reading.fire(res)));\n        });\n    }\n    bulkAdd(objects, keysOrOptions, options) {\n        const keys = Array.isArray(keysOrOptions) ? keysOrOptions : undefined;\n        options = options || (keys ? undefined : keysOrOptions);\n        const wantResults = options ? options.allKeys : undefined;\n        return this._trans('readwrite', trans => {\n            const { auto, keyPath } = this.schema.primKey;\n            if (keyPath && keys)\n                throw new exceptions.InvalidArgument(\"bulkAdd(): keys argument invalid on tables with inbound keys\");\n            if (keys && keys.length !== objects.length)\n                throw new exceptions.InvalidArgument(\"Arguments objects and keys must have the same length\");\n            const numObjects = objects.length;\n            let objectsToAdd = keyPath && auto ?\n                objects.map(workaroundForUndefinedPrimKey(keyPath)) :\n                objects;\n            return this.core.mutate({ trans, type: 'add', keys: keys, values: objectsToAdd, wantResults })\n                .then(({ numFailures, results, lastResult, failures }) => {\n                const result = wantResults ? results : lastResult;\n                if (numFailures === 0)\n                    return result;\n                throw new BulkError(`${this.name}.bulkAdd(): ${numFailures} of ${numObjects} operations failed`, failures);\n            });\n        });\n    }\n    bulkPut(objects, keysOrOptions, options) {\n        const keys = Array.isArray(keysOrOptions) ? keysOrOptions : undefined;\n        options = options || (keys ? undefined : keysOrOptions);\n        const wantResults = options ? options.allKeys : undefined;\n        return this._trans('readwrite', trans => {\n            const { auto, keyPath } = this.schema.primKey;\n            if (keyPath && keys)\n                throw new exceptions.InvalidArgument(\"bulkPut(): keys argument invalid on tables with inbound keys\");\n            if (keys && keys.length !== objects.length)\n                throw new exceptions.InvalidArgument(\"Arguments objects and keys must have the same length\");\n            const numObjects = objects.length;\n            let objectsToPut = keyPath && auto ?\n                objects.map(workaroundForUndefinedPrimKey(keyPath)) :\n                objects;\n            return this.core.mutate({ trans, type: 'put', keys: keys, values: objectsToPut, wantResults })\n                .then(({ numFailures, results, lastResult, failures }) => {\n                const result = wantResults ? results : lastResult;\n                if (numFailures === 0)\n                    return result;\n                throw new BulkError(`${this.name}.bulkPut(): ${numFailures} of ${numObjects} operations failed`, failures);\n            });\n        });\n    }\n    bulkDelete(keys) {\n        const numKeys = keys.length;\n        return this._trans('readwrite', trans => {\n            return this.core.mutate({ trans, type: 'delete', keys: keys });\n        }).then(({ numFailures, lastResult, failures }) => {\n            if (numFailures === 0)\n                return lastResult;\n            throw new BulkError(`${this.name}.bulkDelete(): ${numFailures} of ${numKeys} operations failed`, failures);\n        });\n    }\n}\n\nfunction Events(ctx) {\n    var evs = {};\n    var rv = function (eventName, subscriber) {\n        if (subscriber) {\n            var i = arguments.length, args = new Array(i - 1);\n            while (--i)\n                args[i - 1] = arguments[i];\n            evs[eventName].subscribe.apply(null, args);\n            return ctx;\n        }\n        else if (typeof (eventName) === 'string') {\n            return evs[eventName];\n        }\n    };\n    rv.addEventType = add;\n    for (var i = 1, l = arguments.length; i < l; ++i) {\n        add(arguments[i]);\n    }\n    return rv;\n    function add(eventName, chainFunction, defaultFunction) {\n        if (typeof eventName === 'object')\n            return addConfiguredEvents(eventName);\n        if (!chainFunction)\n            chainFunction = reverseStoppableEventChain;\n        if (!defaultFunction)\n            defaultFunction = nop;\n        var context = {\n            subscribers: [],\n            fire: defaultFunction,\n            subscribe: function (cb) {\n                if (context.subscribers.indexOf(cb) === -1) {\n                    context.subscribers.push(cb);\n                    context.fire = chainFunction(context.fire, cb);\n                }\n            },\n            unsubscribe: function (cb) {\n                context.subscribers = context.subscribers.filter(function (fn) { return fn !== cb; });\n                context.fire = context.subscribers.reduce(chainFunction, defaultFunction);\n            }\n        };\n        evs[eventName] = rv[eventName] = context;\n        return context;\n    }\n    function addConfiguredEvents(cfg) {\n        keys(cfg).forEach(function (eventName) {\n            var args = cfg[eventName];\n            if (isArray(args)) {\n                add(eventName, cfg[eventName][0], cfg[eventName][1]);\n            }\n            else if (args === 'asap') {\n                var context = add(eventName, mirror, function fire() {\n                    var i = arguments.length, args = new Array(i);\n                    while (i--)\n                        args[i] = arguments[i];\n                    context.subscribers.forEach(function (fn) {\n                        asap$1(function fireEvent() {\n                            fn.apply(null, args);\n                        });\n                    });\n                });\n            }\n            else\n                throw new exceptions.InvalidArgument(\"Invalid event config\");\n        });\n    }\n}\n\nfunction makeClassConstructor(prototype, constructor) {\n    derive(constructor).from({ prototype });\n    return constructor;\n}\n\nfunction createTableConstructor(db) {\n    return makeClassConstructor(Table.prototype, function Table(name, tableSchema, trans) {\n        this.db = db;\n        this._tx = trans;\n        this.name = name;\n        this.schema = tableSchema;\n        this.hook = db._allTables[name] ? db._allTables[name].hook : Events(null, {\n            \"creating\": [hookCreatingChain, nop],\n            \"reading\": [pureFunctionChain, mirror],\n            \"updating\": [hookUpdatingChain, nop],\n            \"deleting\": [hookDeletingChain, nop]\n        });\n    });\n}\n\nfunction isPlainKeyRange(ctx, ignoreLimitFilter) {\n    return !(ctx.filter || ctx.algorithm || ctx.or) &&\n        (ignoreLimitFilter ? ctx.justLimit : !ctx.replayFilter);\n}\nfunction addFilter(ctx, fn) {\n    ctx.filter = combine(ctx.filter, fn);\n}\nfunction addReplayFilter(ctx, factory, isLimitFilter) {\n    var curr = ctx.replayFilter;\n    ctx.replayFilter = curr ? () => combine(curr(), factory()) : factory;\n    ctx.justLimit = isLimitFilter && !curr;\n}\nfunction addMatchFilter(ctx, fn) {\n    ctx.isMatch = combine(ctx.isMatch, fn);\n}\nfunction getIndexOrStore(ctx, coreSchema) {\n    if (ctx.isPrimKey)\n        return coreSchema.primaryKey;\n    const index = coreSchema.getIndexByKeyPath(ctx.index);\n    if (!index)\n        throw new exceptions.Schema(\"KeyPath \" + ctx.index + \" on object store \" + coreSchema.name + \" is not indexed\");\n    return index;\n}\nfunction openCursor(ctx, coreTable, trans) {\n    const index = getIndexOrStore(ctx, coreTable.schema);\n    return coreTable.openCursor({\n        trans,\n        values: !ctx.keysOnly,\n        reverse: ctx.dir === 'prev',\n        unique: !!ctx.unique,\n        query: {\n            index,\n            range: ctx.range\n        }\n    });\n}\nfunction iter(ctx, fn, coreTrans, coreTable) {\n    const filter = ctx.replayFilter ? combine(ctx.filter, ctx.replayFilter()) : ctx.filter;\n    if (!ctx.or) {\n        return iterate(openCursor(ctx, coreTable, coreTrans), combine(ctx.algorithm, filter), fn, !ctx.keysOnly && ctx.valueMapper);\n    }\n    else {\n        const set = {};\n        const union = (item, cursor, advance) => {\n            if (!filter || filter(cursor, advance, result => cursor.stop(result), err => cursor.fail(err))) {\n                var primaryKey = cursor.primaryKey;\n                var key = '' + primaryKey;\n                if (key === '[object ArrayBuffer]')\n                    key = '' + new Uint8Array(primaryKey);\n                if (!hasOwn(set, key)) {\n                    set[key] = true;\n                    fn(item, cursor, advance);\n                }\n            }\n        };\n        return Promise.all([\n            ctx.or._iterate(union, coreTrans),\n            iterate(openCursor(ctx, coreTable, coreTrans), ctx.algorithm, union, !ctx.keysOnly && ctx.valueMapper)\n        ]);\n    }\n}\nfunction iterate(cursorPromise, filter, fn, valueMapper) {\n    var mappedFn = valueMapper ? (x, c, a) => fn(valueMapper(x), c, a) : fn;\n    var wrappedFn = wrap(mappedFn);\n    return cursorPromise.then(cursor => {\n        if (cursor) {\n            return cursor.start(() => {\n                var c = () => cursor.continue();\n                if (!filter || filter(cursor, advancer => c = advancer, val => { cursor.stop(val); c = nop; }, e => { cursor.fail(e); c = nop; }))\n                    wrappedFn(cursor.value, cursor, advancer => c = advancer);\n                c();\n            });\n        }\n    });\n}\n\nfunction cmp(a, b) {\n    try {\n        const ta = type(a);\n        const tb = type(b);\n        if (ta !== tb) {\n            if (ta === 'Array')\n                return 1;\n            if (tb === 'Array')\n                return -1;\n            if (ta === 'binary')\n                return 1;\n            if (tb === 'binary')\n                return -1;\n            if (ta === 'string')\n                return 1;\n            if (tb === 'string')\n                return -1;\n            if (ta === 'Date')\n                return 1;\n            if (tb !== 'Date')\n                return NaN;\n            return -1;\n        }\n        switch (ta) {\n            case 'number':\n            case 'Date':\n            case 'string':\n                return a > b ? 1 : a < b ? -1 : 0;\n            case 'binary': {\n                return compareUint8Arrays(getUint8Array(a), getUint8Array(b));\n            }\n            case 'Array':\n                return compareArrays(a, b);\n        }\n    }\n    catch (_a) { }\n    return NaN;\n}\nfunction compareArrays(a, b) {\n    const al = a.length;\n    const bl = b.length;\n    const l = al < bl ? al : bl;\n    for (let i = 0; i < l; ++i) {\n        const res = cmp(a[i], b[i]);\n        if (res !== 0)\n            return res;\n    }\n    return al === bl ? 0 : al < bl ? -1 : 1;\n}\nfunction compareUint8Arrays(a, b) {\n    const al = a.length;\n    const bl = b.length;\n    const l = al < bl ? al : bl;\n    for (let i = 0; i < l; ++i) {\n        if (a[i] !== b[i])\n            return a[i] < b[i] ? -1 : 1;\n    }\n    return al === bl ? 0 : al < bl ? -1 : 1;\n}\nfunction type(x) {\n    const t = typeof x;\n    if (t !== 'object')\n        return t;\n    if (ArrayBuffer.isView(x))\n        return 'binary';\n    const tsTag = toStringTag(x);\n    return tsTag === 'ArrayBuffer' ? 'binary' : tsTag;\n}\nfunction getUint8Array(a) {\n    if (a instanceof Uint8Array)\n        return a;\n    if (ArrayBuffer.isView(a))\n        return new Uint8Array(a.buffer, a.byteOffset, a.byteLength);\n    return new Uint8Array(a);\n}\n\nclass Collection {\n    _read(fn, cb) {\n        var ctx = this._ctx;\n        return ctx.error ?\n            ctx.table._trans(null, rejection.bind(null, ctx.error)) :\n            ctx.table._trans('readonly', fn).then(cb);\n    }\n    _write(fn) {\n        var ctx = this._ctx;\n        return ctx.error ?\n            ctx.table._trans(null, rejection.bind(null, ctx.error)) :\n            ctx.table._trans('readwrite', fn, \"locked\");\n    }\n    _addAlgorithm(fn) {\n        var ctx = this._ctx;\n        ctx.algorithm = combine(ctx.algorithm, fn);\n    }\n    _iterate(fn, coreTrans) {\n        return iter(this._ctx, fn, coreTrans, this._ctx.table.core);\n    }\n    clone(props) {\n        var rv = Object.create(this.constructor.prototype), ctx = Object.create(this._ctx);\n        if (props)\n            extend(ctx, props);\n        rv._ctx = ctx;\n        return rv;\n    }\n    raw() {\n        this._ctx.valueMapper = null;\n        return this;\n    }\n    each(fn) {\n        var ctx = this._ctx;\n        return this._read(trans => iter(ctx, fn, trans, ctx.table.core));\n    }\n    count(cb) {\n        return this._read(trans => {\n            const ctx = this._ctx;\n            const coreTable = ctx.table.core;\n            if (isPlainKeyRange(ctx, true)) {\n                return coreTable.count({\n                    trans,\n                    query: {\n                        index: getIndexOrStore(ctx, coreTable.schema),\n                        range: ctx.range\n                    }\n                }).then(count => Math.min(count, ctx.limit));\n            }\n            else {\n                var count = 0;\n                return iter(ctx, () => { ++count; return false; }, trans, coreTable)\n                    .then(() => count);\n            }\n        }).then(cb);\n    }\n    sortBy(keyPath, cb) {\n        const parts = keyPath.split('.').reverse(), lastPart = parts[0], lastIndex = parts.length - 1;\n        function getval(obj, i) {\n            if (i)\n                return getval(obj[parts[i]], i - 1);\n            return obj[lastPart];\n        }\n        var order = this._ctx.dir === \"next\" ? 1 : -1;\n        function sorter(a, b) {\n            var aVal = getval(a, lastIndex), bVal = getval(b, lastIndex);\n            return aVal < bVal ? -order : aVal > bVal ? order : 0;\n        }\n        return this.toArray(function (a) {\n            return a.sort(sorter);\n        }).then(cb);\n    }\n    toArray(cb) {\n        return this._read(trans => {\n            var ctx = this._ctx;\n            if (ctx.dir === 'next' && isPlainKeyRange(ctx, true) && ctx.limit > 0) {\n                const { valueMapper } = ctx;\n                const index = getIndexOrStore(ctx, ctx.table.core.schema);\n                return ctx.table.core.query({\n                    trans,\n                    limit: ctx.limit,\n                    values: true,\n                    query: {\n                        index,\n                        range: ctx.range\n                    }\n                }).then(({ result }) => valueMapper ? result.map(valueMapper) : result);\n            }\n            else {\n                const a = [];\n                return iter(ctx, item => a.push(item), trans, ctx.table.core).then(() => a);\n            }\n        }, cb);\n    }\n    offset(offset) {\n        var ctx = this._ctx;\n        if (offset <= 0)\n            return this;\n        ctx.offset += offset;\n        if (isPlainKeyRange(ctx)) {\n            addReplayFilter(ctx, () => {\n                var offsetLeft = offset;\n                return (cursor, advance) => {\n                    if (offsetLeft === 0)\n                        return true;\n                    if (offsetLeft === 1) {\n                        --offsetLeft;\n                        return false;\n                    }\n                    advance(() => {\n                        cursor.advance(offsetLeft);\n                        offsetLeft = 0;\n                    });\n                    return false;\n                };\n            });\n        }\n        else {\n            addReplayFilter(ctx, () => {\n                var offsetLeft = offset;\n                return () => (--offsetLeft < 0);\n            });\n        }\n        return this;\n    }\n    limit(numRows) {\n        this._ctx.limit = Math.min(this._ctx.limit, numRows);\n        addReplayFilter(this._ctx, () => {\n            var rowsLeft = numRows;\n            return function (cursor, advance, resolve) {\n                if (--rowsLeft <= 0)\n                    advance(resolve);\n                return rowsLeft >= 0;\n            };\n        }, true);\n        return this;\n    }\n    until(filterFunction, bIncludeStopEntry) {\n        addFilter(this._ctx, function (cursor, advance, resolve) {\n            if (filterFunction(cursor.value)) {\n                advance(resolve);\n                return bIncludeStopEntry;\n            }\n            else {\n                return true;\n            }\n        });\n        return this;\n    }\n    first(cb) {\n        return this.limit(1).toArray(function (a) { return a[0]; }).then(cb);\n    }\n    last(cb) {\n        return this.reverse().first(cb);\n    }\n    filter(filterFunction) {\n        addFilter(this._ctx, function (cursor) {\n            return filterFunction(cursor.value);\n        });\n        addMatchFilter(this._ctx, filterFunction);\n        return this;\n    }\n    and(filter) {\n        return this.filter(filter);\n    }\n    or(indexName) {\n        return new this.db.WhereClause(this._ctx.table, indexName, this);\n    }\n    reverse() {\n        this._ctx.dir = (this._ctx.dir === \"prev\" ? \"next\" : \"prev\");\n        if (this._ondirectionchange)\n            this._ondirectionchange(this._ctx.dir);\n        return this;\n    }\n    desc() {\n        return this.reverse();\n    }\n    eachKey(cb) {\n        var ctx = this._ctx;\n        ctx.keysOnly = !ctx.isMatch;\n        return this.each(function (val, cursor) { cb(cursor.key, cursor); });\n    }\n    eachUniqueKey(cb) {\n        this._ctx.unique = \"unique\";\n        return this.eachKey(cb);\n    }\n    eachPrimaryKey(cb) {\n        var ctx = this._ctx;\n        ctx.keysOnly = !ctx.isMatch;\n        return this.each(function (val, cursor) { cb(cursor.primaryKey, cursor); });\n    }\n    keys(cb) {\n        var ctx = this._ctx;\n        ctx.keysOnly = !ctx.isMatch;\n        var a = [];\n        return this.each(function (item, cursor) {\n            a.push(cursor.key);\n        }).then(function () {\n            return a;\n        }).then(cb);\n    }\n    primaryKeys(cb) {\n        var ctx = this._ctx;\n        if (ctx.dir === 'next' && isPlainKeyRange(ctx, true) && ctx.limit > 0) {\n            return this._read(trans => {\n                var index = getIndexOrStore(ctx, ctx.table.core.schema);\n                return ctx.table.core.query({\n                    trans,\n                    values: false,\n                    limit: ctx.limit,\n                    query: {\n                        index,\n                        range: ctx.range\n                    }\n                });\n            }).then(({ result }) => result).then(cb);\n        }\n        ctx.keysOnly = !ctx.isMatch;\n        var a = [];\n        return this.each(function (item, cursor) {\n            a.push(cursor.primaryKey);\n        }).then(function () {\n            return a;\n        }).then(cb);\n    }\n    uniqueKeys(cb) {\n        this._ctx.unique = \"unique\";\n        return this.keys(cb);\n    }\n    firstKey(cb) {\n        return this.limit(1).keys(function (a) { return a[0]; }).then(cb);\n    }\n    lastKey(cb) {\n        return this.reverse().firstKey(cb);\n    }\n    distinct() {\n        var ctx = this._ctx, idx = ctx.index && ctx.table.schema.idxByName[ctx.index];\n        if (!idx || !idx.multi)\n            return this;\n        var set = {};\n        addFilter(this._ctx, function (cursor) {\n            var strKey = cursor.primaryKey.toString();\n            var found = hasOwn(set, strKey);\n            set[strKey] = true;\n            return !found;\n        });\n        return this;\n    }\n    modify(changes) {\n        var ctx = this._ctx;\n        return this._write(trans => {\n            var modifyer;\n            if (typeof changes === 'function') {\n                modifyer = changes;\n            }\n            else {\n                var keyPaths = keys(changes);\n                var numKeys = keyPaths.length;\n                modifyer = function (item) {\n                    var anythingModified = false;\n                    for (var i = 0; i < numKeys; ++i) {\n                        var keyPath = keyPaths[i], val = changes[keyPath];\n                        if (getByKeyPath(item, keyPath) !== val) {\n                            setByKeyPath(item, keyPath, val);\n                            anythingModified = true;\n                        }\n                    }\n                    return anythingModified;\n                };\n            }\n            const coreTable = ctx.table.core;\n            const { outbound, extractKey } = coreTable.schema.primaryKey;\n            const limit = this.db._options.modifyChunkSize || 200;\n            const totalFailures = [];\n            let successCount = 0;\n            const failedKeys = [];\n            const applyMutateResult = (expectedCount, res) => {\n                const { failures, numFailures } = res;\n                successCount += expectedCount - numFailures;\n                for (let pos of keys(failures)) {\n                    totalFailures.push(failures[pos]);\n                }\n            };\n            return this.clone().primaryKeys().then(keys => {\n                const nextChunk = (offset) => {\n                    const count = Math.min(limit, keys.length - offset);\n                    return coreTable.getMany({\n                        trans,\n                        keys: keys.slice(offset, offset + count),\n                        cache: \"immutable\"\n                    }).then(values => {\n                        const addValues = [];\n                        const putValues = [];\n                        const putKeys = outbound ? [] : null;\n                        const deleteKeys = [];\n                        for (let i = 0; i < count; ++i) {\n                            const origValue = values[i];\n                            const ctx = {\n                                value: deepClone(origValue),\n                                primKey: keys[offset + i]\n                            };\n                            if (modifyer.call(ctx, ctx.value, ctx) !== false) {\n                                if (ctx.value == null) {\n                                    deleteKeys.push(keys[offset + i]);\n                                }\n                                else if (!outbound && cmp(extractKey(origValue), extractKey(ctx.value)) !== 0) {\n                                    deleteKeys.push(keys[offset + i]);\n                                    addValues.push(ctx.value);\n                                }\n                                else {\n                                    putValues.push(ctx.value);\n                                    if (outbound)\n                                        putKeys.push(keys[offset + i]);\n                                }\n                            }\n                        }\n                        const criteria = isPlainKeyRange(ctx) &&\n                            ctx.limit === Infinity &&\n                            (typeof changes !== 'function' || changes === deleteCallback) && {\n                            index: ctx.index,\n                            range: ctx.range\n                        };\n                        return Promise.resolve(addValues.length > 0 &&\n                            coreTable.mutate({ trans, type: 'add', values: addValues })\n                                .then(res => {\n                                for (let pos in res.failures) {\n                                    deleteKeys.splice(parseInt(pos), 1);\n                                }\n                                applyMutateResult(addValues.length, res);\n                            })).then(() => (putValues.length > 0 || (criteria && typeof changes === 'object')) &&\n                            coreTable.mutate({\n                                trans,\n                                type: 'put',\n                                keys: putKeys,\n                                values: putValues,\n                                criteria,\n                                changeSpec: typeof changes !== 'function'\n                                    && changes\n                            }).then(res => applyMutateResult(putValues.length, res))).then(() => (deleteKeys.length > 0 || (criteria && changes === deleteCallback)) &&\n                            coreTable.mutate({\n                                trans,\n                                type: 'delete',\n                                keys: deleteKeys,\n                                criteria\n                            }).then(res => applyMutateResult(deleteKeys.length, res))).then(() => {\n                            return keys.length > offset + count && nextChunk(offset + limit);\n                        });\n                    });\n                };\n                return nextChunk(0).then(() => {\n                    if (totalFailures.length > 0)\n                        throw new ModifyError(\"Error modifying one or more objects\", totalFailures, successCount, failedKeys);\n                    return keys.length;\n                });\n            });\n        });\n    }\n    delete() {\n        var ctx = this._ctx, range = ctx.range;\n        if (isPlainKeyRange(ctx) &&\n            ((ctx.isPrimKey && !hangsOnDeleteLargeKeyRange) || range.type === 3 ))\n         {\n            return this._write(trans => {\n                const { primaryKey } = ctx.table.core.schema;\n                const coreRange = range;\n                return ctx.table.core.count({ trans, query: { index: primaryKey, range: coreRange } }).then(count => {\n                    return ctx.table.core.mutate({ trans, type: 'deleteRange', range: coreRange })\n                        .then(({ failures, lastResult, results, numFailures }) => {\n                        if (numFailures)\n                            throw new ModifyError(\"Could not delete some values\", Object.keys(failures).map(pos => failures[pos]), count - numFailures);\n                        return count - numFailures;\n                    });\n                });\n            });\n        }\n        return this.modify(deleteCallback);\n    }\n}\nconst deleteCallback = (value, ctx) => ctx.value = null;\n\nfunction createCollectionConstructor(db) {\n    return makeClassConstructor(Collection.prototype, function Collection(whereClause, keyRangeGenerator) {\n        this.db = db;\n        let keyRange = AnyRange, error = null;\n        if (keyRangeGenerator)\n            try {\n                keyRange = keyRangeGenerator();\n            }\n            catch (ex) {\n                error = ex;\n            }\n        const whereCtx = whereClause._ctx;\n        const table = whereCtx.table;\n        const readingHook = table.hook.reading.fire;\n        this._ctx = {\n            table: table,\n            index: whereCtx.index,\n            isPrimKey: (!whereCtx.index || (table.schema.primKey.keyPath && whereCtx.index === table.schema.primKey.name)),\n            range: keyRange,\n            keysOnly: false,\n            dir: \"next\",\n            unique: \"\",\n            algorithm: null,\n            filter: null,\n            replayFilter: null,\n            justLimit: true,\n            isMatch: null,\n            offset: 0,\n            limit: Infinity,\n            error: error,\n            or: whereCtx.or,\n            valueMapper: readingHook !== mirror ? readingHook : null\n        };\n    });\n}\n\nfunction simpleCompare(a, b) {\n    return a < b ? -1 : a === b ? 0 : 1;\n}\nfunction simpleCompareReverse(a, b) {\n    return a > b ? -1 : a === b ? 0 : 1;\n}\n\nfunction fail(collectionOrWhereClause, err, T) {\n    var collection = collectionOrWhereClause instanceof WhereClause ?\n        new collectionOrWhereClause.Collection(collectionOrWhereClause) :\n        collectionOrWhereClause;\n    collection._ctx.error = T ? new T(err) : new TypeError(err);\n    return collection;\n}\nfunction emptyCollection(whereClause) {\n    return new whereClause.Collection(whereClause, () => rangeEqual(\"\")).limit(0);\n}\nfunction upperFactory(dir) {\n    return dir === \"next\" ?\n        (s) => s.toUpperCase() :\n        (s) => s.toLowerCase();\n}\nfunction lowerFactory(dir) {\n    return dir === \"next\" ?\n        (s) => s.toLowerCase() :\n        (s) => s.toUpperCase();\n}\nfunction nextCasing(key, lowerKey, upperNeedle, lowerNeedle, cmp, dir) {\n    var length = Math.min(key.length, lowerNeedle.length);\n    var llp = -1;\n    for (var i = 0; i < length; ++i) {\n        var lwrKeyChar = lowerKey[i];\n        if (lwrKeyChar !== lowerNeedle[i]) {\n            if (cmp(key[i], upperNeedle[i]) < 0)\n                return key.substr(0, i) + upperNeedle[i] + upperNeedle.substr(i + 1);\n            if (cmp(key[i], lowerNeedle[i]) < 0)\n                return key.substr(0, i) + lowerNeedle[i] + upperNeedle.substr(i + 1);\n            if (llp >= 0)\n                return key.substr(0, llp) + lowerKey[llp] + upperNeedle.substr(llp + 1);\n            return null;\n        }\n        if (cmp(key[i], lwrKeyChar) < 0)\n            llp = i;\n    }\n    if (length < lowerNeedle.length && dir === \"next\")\n        return key + upperNeedle.substr(key.length);\n    if (length < key.length && dir === \"prev\")\n        return key.substr(0, upperNeedle.length);\n    return (llp < 0 ? null : key.substr(0, llp) + lowerNeedle[llp] + upperNeedle.substr(llp + 1));\n}\nfunction addIgnoreCaseAlgorithm(whereClause, match, needles, suffix) {\n    var upper, lower, compare, upperNeedles, lowerNeedles, direction, nextKeySuffix, needlesLen = needles.length;\n    if (!needles.every(s => typeof s === 'string')) {\n        return fail(whereClause, STRING_EXPECTED);\n    }\n    function initDirection(dir) {\n        upper = upperFactory(dir);\n        lower = lowerFactory(dir);\n        compare = (dir === \"next\" ? simpleCompare : simpleCompareReverse);\n        var needleBounds = needles.map(function (needle) {\n            return { lower: lower(needle), upper: upper(needle) };\n        }).sort(function (a, b) {\n            return compare(a.lower, b.lower);\n        });\n        upperNeedles = needleBounds.map(function (nb) { return nb.upper; });\n        lowerNeedles = needleBounds.map(function (nb) { return nb.lower; });\n        direction = dir;\n        nextKeySuffix = (dir === \"next\" ? \"\" : suffix);\n    }\n    initDirection(\"next\");\n    var c = new whereClause.Collection(whereClause, () => createRange(upperNeedles[0], lowerNeedles[needlesLen - 1] + suffix));\n    c._ondirectionchange = function (direction) {\n        initDirection(direction);\n    };\n    var firstPossibleNeedle = 0;\n    c._addAlgorithm(function (cursor, advance, resolve) {\n        var key = cursor.key;\n        if (typeof key !== 'string')\n            return false;\n        var lowerKey = lower(key);\n        if (match(lowerKey, lowerNeedles, firstPossibleNeedle)) {\n            return true;\n        }\n        else {\n            var lowestPossibleCasing = null;\n            for (var i = firstPossibleNeedle; i < needlesLen; ++i) {\n                var casing = nextCasing(key, lowerKey, upperNeedles[i], lowerNeedles[i], compare, direction);\n                if (casing === null && lowestPossibleCasing === null)\n                    firstPossibleNeedle = i + 1;\n                else if (lowestPossibleCasing === null || compare(lowestPossibleCasing, casing) > 0) {\n                    lowestPossibleCasing = casing;\n                }\n            }\n            if (lowestPossibleCasing !== null) {\n                advance(function () { cursor.continue(lowestPossibleCasing + nextKeySuffix); });\n            }\n            else {\n                advance(resolve);\n            }\n            return false;\n        }\n    });\n    return c;\n}\nfunction createRange(lower, upper, lowerOpen, upperOpen) {\n    return {\n        type: 2 ,\n        lower,\n        upper,\n        lowerOpen,\n        upperOpen\n    };\n}\nfunction rangeEqual(value) {\n    return {\n        type: 1 ,\n        lower: value,\n        upper: value\n    };\n}\n\nclass WhereClause {\n    get Collection() {\n        return this._ctx.table.db.Collection;\n    }\n    between(lower, upper, includeLower, includeUpper) {\n        includeLower = includeLower !== false;\n        includeUpper = includeUpper === true;\n        try {\n            if ((this._cmp(lower, upper) > 0) ||\n                (this._cmp(lower, upper) === 0 && (includeLower || includeUpper) && !(includeLower && includeUpper)))\n                return emptyCollection(this);\n            return new this.Collection(this, () => createRange(lower, upper, !includeLower, !includeUpper));\n        }\n        catch (e) {\n            return fail(this, INVALID_KEY_ARGUMENT);\n        }\n    }\n    equals(value) {\n        if (value == null)\n            return fail(this, INVALID_KEY_ARGUMENT);\n        return new this.Collection(this, () => rangeEqual(value));\n    }\n    above(value) {\n        if (value == null)\n            return fail(this, INVALID_KEY_ARGUMENT);\n        return new this.Collection(this, () => createRange(value, undefined, true));\n    }\n    aboveOrEqual(value) {\n        if (value == null)\n            return fail(this, INVALID_KEY_ARGUMENT);\n        return new this.Collection(this, () => createRange(value, undefined, false));\n    }\n    below(value) {\n        if (value == null)\n            return fail(this, INVALID_KEY_ARGUMENT);\n        return new this.Collection(this, () => createRange(undefined, value, false, true));\n    }\n    belowOrEqual(value) {\n        if (value == null)\n            return fail(this, INVALID_KEY_ARGUMENT);\n        return new this.Collection(this, () => createRange(undefined, value));\n    }\n    startsWith(str) {\n        if (typeof str !== 'string')\n            return fail(this, STRING_EXPECTED);\n        return this.between(str, str + maxString, true, true);\n    }\n    startsWithIgnoreCase(str) {\n        if (str === \"\")\n            return this.startsWith(str);\n        return addIgnoreCaseAlgorithm(this, (x, a) => x.indexOf(a[0]) === 0, [str], maxString);\n    }\n    equalsIgnoreCase(str) {\n        return addIgnoreCaseAlgorithm(this, (x, a) => x === a[0], [str], \"\");\n    }\n    anyOfIgnoreCase() {\n        var set = getArrayOf.apply(NO_CHAR_ARRAY, arguments);\n        if (set.length === 0)\n            return emptyCollection(this);\n        return addIgnoreCaseAlgorithm(this, (x, a) => a.indexOf(x) !== -1, set, \"\");\n    }\n    startsWithAnyOfIgnoreCase() {\n        var set = getArrayOf.apply(NO_CHAR_ARRAY, arguments);\n        if (set.length === 0)\n            return emptyCollection(this);\n        return addIgnoreCaseAlgorithm(this, (x, a) => a.some(n => x.indexOf(n) === 0), set, maxString);\n    }\n    anyOf() {\n        const set = getArrayOf.apply(NO_CHAR_ARRAY, arguments);\n        let compare = this._cmp;\n        try {\n            set.sort(compare);\n        }\n        catch (e) {\n            return fail(this, INVALID_KEY_ARGUMENT);\n        }\n        if (set.length === 0)\n            return emptyCollection(this);\n        const c = new this.Collection(this, () => createRange(set[0], set[set.length - 1]));\n        c._ondirectionchange = direction => {\n            compare = (direction === \"next\" ?\n                this._ascending :\n                this._descending);\n            set.sort(compare);\n        };\n        let i = 0;\n        c._addAlgorithm((cursor, advance, resolve) => {\n            const key = cursor.key;\n            while (compare(key, set[i]) > 0) {\n                ++i;\n                if (i === set.length) {\n                    advance(resolve);\n                    return false;\n                }\n            }\n            if (compare(key, set[i]) === 0) {\n                return true;\n            }\n            else {\n                advance(() => { cursor.continue(set[i]); });\n                return false;\n            }\n        });\n        return c;\n    }\n    notEqual(value) {\n        return this.inAnyRange([[minKey, value], [value, this.db._maxKey]], { includeLowers: false, includeUppers: false });\n    }\n    noneOf() {\n        const set = getArrayOf.apply(NO_CHAR_ARRAY, arguments);\n        if (set.length === 0)\n            return new this.Collection(this);\n        try {\n            set.sort(this._ascending);\n        }\n        catch (e) {\n            return fail(this, INVALID_KEY_ARGUMENT);\n        }\n        const ranges = set.reduce((res, val) => res ?\n            res.concat([[res[res.length - 1][1], val]]) :\n            [[minKey, val]], null);\n        ranges.push([set[set.length - 1], this.db._maxKey]);\n        return this.inAnyRange(ranges, { includeLowers: false, includeUppers: false });\n    }\n    inAnyRange(ranges, options) {\n        const cmp = this._cmp, ascending = this._ascending, descending = this._descending, min = this._min, max = this._max;\n        if (ranges.length === 0)\n            return emptyCollection(this);\n        if (!ranges.every(range => range[0] !== undefined &&\n            range[1] !== undefined &&\n            ascending(range[0], range[1]) <= 0)) {\n            return fail(this, \"First argument to inAnyRange() must be an Array of two-value Arrays [lower,upper] where upper must not be lower than lower\", exceptions.InvalidArgument);\n        }\n        const includeLowers = !options || options.includeLowers !== false;\n        const includeUppers = options && options.includeUppers === true;\n        function addRange(ranges, newRange) {\n            let i = 0, l = ranges.length;\n            for (; i < l; ++i) {\n                const range = ranges[i];\n                if (cmp(newRange[0], range[1]) < 0 && cmp(newRange[1], range[0]) > 0) {\n                    range[0] = min(range[0], newRange[0]);\n                    range[1] = max(range[1], newRange[1]);\n                    break;\n                }\n            }\n            if (i === l)\n                ranges.push(newRange);\n            return ranges;\n        }\n        let sortDirection = ascending;\n        function rangeSorter(a, b) { return sortDirection(a[0], b[0]); }\n        let set;\n        try {\n            set = ranges.reduce(addRange, []);\n            set.sort(rangeSorter);\n        }\n        catch (ex) {\n            return fail(this, INVALID_KEY_ARGUMENT);\n        }\n        let rangePos = 0;\n        const keyIsBeyondCurrentEntry = includeUppers ?\n            key => ascending(key, set[rangePos][1]) > 0 :\n            key => ascending(key, set[rangePos][1]) >= 0;\n        const keyIsBeforeCurrentEntry = includeLowers ?\n            key => descending(key, set[rangePos][0]) > 0 :\n            key => descending(key, set[rangePos][0]) >= 0;\n        function keyWithinCurrentRange(key) {\n            return !keyIsBeyondCurrentEntry(key) && !keyIsBeforeCurrentEntry(key);\n        }\n        let checkKey = keyIsBeyondCurrentEntry;\n        const c = new this.Collection(this, () => createRange(set[0][0], set[set.length - 1][1], !includeLowers, !includeUppers));\n        c._ondirectionchange = direction => {\n            if (direction === \"next\") {\n                checkKey = keyIsBeyondCurrentEntry;\n                sortDirection = ascending;\n            }\n            else {\n                checkKey = keyIsBeforeCurrentEntry;\n                sortDirection = descending;\n            }\n            set.sort(rangeSorter);\n        };\n        c._addAlgorithm((cursor, advance, resolve) => {\n            var key = cursor.key;\n            while (checkKey(key)) {\n                ++rangePos;\n                if (rangePos === set.length) {\n                    advance(resolve);\n                    return false;\n                }\n            }\n            if (keyWithinCurrentRange(key)) {\n                return true;\n            }\n            else if (this._cmp(key, set[rangePos][1]) === 0 || this._cmp(key, set[rangePos][0]) === 0) {\n                return false;\n            }\n            else {\n                advance(() => {\n                    if (sortDirection === ascending)\n                        cursor.continue(set[rangePos][0]);\n                    else\n                        cursor.continue(set[rangePos][1]);\n                });\n                return false;\n            }\n        });\n        return c;\n    }\n    startsWithAnyOf() {\n        const set = getArrayOf.apply(NO_CHAR_ARRAY, arguments);\n        if (!set.every(s => typeof s === 'string')) {\n            return fail(this, \"startsWithAnyOf() only works with strings\");\n        }\n        if (set.length === 0)\n            return emptyCollection(this);\n        return this.inAnyRange(set.map((str) => [str, str + maxString]));\n    }\n}\n\nfunction createWhereClauseConstructor(db) {\n    return makeClassConstructor(WhereClause.prototype, function WhereClause(table, index, orCollection) {\n        this.db = db;\n        this._ctx = {\n            table: table,\n            index: index === \":id\" ? null : index,\n            or: orCollection\n        };\n        const indexedDB = db._deps.indexedDB;\n        if (!indexedDB)\n            throw new exceptions.MissingAPI();\n        this._cmp = this._ascending = indexedDB.cmp.bind(indexedDB);\n        this._descending = (a, b) => indexedDB.cmp(b, a);\n        this._max = (a, b) => indexedDB.cmp(a, b) > 0 ? a : b;\n        this._min = (a, b) => indexedDB.cmp(a, b) < 0 ? a : b;\n        this._IDBKeyRange = db._deps.IDBKeyRange;\n    });\n}\n\nfunction eventRejectHandler(reject) {\n    return wrap(function (event) {\n        preventDefault(event);\n        reject(event.target.error);\n        return false;\n    });\n}\nfunction preventDefault(event) {\n    if (event.stopPropagation)\n        event.stopPropagation();\n    if (event.preventDefault)\n        event.preventDefault();\n}\n\nconst DEXIE_STORAGE_MUTATED_EVENT_NAME = 'storagemutated';\nconst STORAGE_MUTATED_DOM_EVENT_NAME = 'x-storagemutated-1';\nconst globalEvents = Events(null, DEXIE_STORAGE_MUTATED_EVENT_NAME);\n\nclass Transaction {\n    _lock() {\n        assert(!PSD.global);\n        ++this._reculock;\n        if (this._reculock === 1 && !PSD.global)\n            PSD.lockOwnerFor = this;\n        return this;\n    }\n    _unlock() {\n        assert(!PSD.global);\n        if (--this._reculock === 0) {\n            if (!PSD.global)\n                PSD.lockOwnerFor = null;\n            while (this._blockedFuncs.length > 0 && !this._locked()) {\n                var fnAndPSD = this._blockedFuncs.shift();\n                try {\n                    usePSD(fnAndPSD[1], fnAndPSD[0]);\n                }\n                catch (e) { }\n            }\n        }\n        return this;\n    }\n    _locked() {\n        return this._reculock && PSD.lockOwnerFor !== this;\n    }\n    create(idbtrans) {\n        if (!this.mode)\n            return this;\n        const idbdb = this.db.idbdb;\n        const dbOpenError = this.db._state.dbOpenError;\n        assert(!this.idbtrans);\n        if (!idbtrans && !idbdb) {\n            switch (dbOpenError && dbOpenError.name) {\n                case \"DatabaseClosedError\":\n                    throw new exceptions.DatabaseClosed(dbOpenError);\n                case \"MissingAPIError\":\n                    throw new exceptions.MissingAPI(dbOpenError.message, dbOpenError);\n                default:\n                    throw new exceptions.OpenFailed(dbOpenError);\n            }\n        }\n        if (!this.active)\n            throw new exceptions.TransactionInactive();\n        assert(this._completion._state === null);\n        idbtrans = this.idbtrans = idbtrans ||\n            (this.db.core\n                ? this.db.core.transaction(this.storeNames, this.mode, { durability: this.chromeTransactionDurability })\n                : idbdb.transaction(this.storeNames, this.mode, { durability: this.chromeTransactionDurability }));\n        idbtrans.onerror = wrap(ev => {\n            preventDefault(ev);\n            this._reject(idbtrans.error);\n        });\n        idbtrans.onabort = wrap(ev => {\n            preventDefault(ev);\n            this.active && this._reject(new exceptions.Abort(idbtrans.error));\n            this.active = false;\n            this.on(\"abort\").fire(ev);\n        });\n        idbtrans.oncomplete = wrap(() => {\n            this.active = false;\n            this._resolve();\n            if ('mutatedParts' in idbtrans) {\n                globalEvents.storagemutated.fire(idbtrans[\"mutatedParts\"]);\n            }\n        });\n        return this;\n    }\n    _promise(mode, fn, bWriteLock) {\n        if (mode === 'readwrite' && this.mode !== 'readwrite')\n            return rejection(new exceptions.ReadOnly(\"Transaction is readonly\"));\n        if (!this.active)\n            return rejection(new exceptions.TransactionInactive());\n        if (this._locked()) {\n            return new DexiePromise((resolve, reject) => {\n                this._blockedFuncs.push([() => {\n                        this._promise(mode, fn, bWriteLock).then(resolve, reject);\n                    }, PSD]);\n            });\n        }\n        else if (bWriteLock) {\n            return newScope(() => {\n                var p = new DexiePromise((resolve, reject) => {\n                    this._lock();\n                    const rv = fn(resolve, reject, this);\n                    if (rv && rv.then)\n                        rv.then(resolve, reject);\n                });\n                p.finally(() => this._unlock());\n                p._lib = true;\n                return p;\n            });\n        }\n        else {\n            var p = new DexiePromise((resolve, reject) => {\n                var rv = fn(resolve, reject, this);\n                if (rv && rv.then)\n                    rv.then(resolve, reject);\n            });\n            p._lib = true;\n            return p;\n        }\n    }\n    _root() {\n        return this.parent ? this.parent._root() : this;\n    }\n    waitFor(promiseLike) {\n        var root = this._root();\n        const promise = DexiePromise.resolve(promiseLike);\n        if (root._waitingFor) {\n            root._waitingFor = root._waitingFor.then(() => promise);\n        }\n        else {\n            root._waitingFor = promise;\n            root._waitingQueue = [];\n            var store = root.idbtrans.objectStore(root.storeNames[0]);\n            (function spin() {\n                ++root._spinCount;\n                while (root._waitingQueue.length)\n                    (root._waitingQueue.shift())();\n                if (root._waitingFor)\n                    store.get(-Infinity).onsuccess = spin;\n            }());\n        }\n        var currentWaitPromise = root._waitingFor;\n        return new DexiePromise((resolve, reject) => {\n            promise.then(res => root._waitingQueue.push(wrap(resolve.bind(null, res))), err => root._waitingQueue.push(wrap(reject.bind(null, err)))).finally(() => {\n                if (root._waitingFor === currentWaitPromise) {\n                    root._waitingFor = null;\n                }\n            });\n        });\n    }\n    abort() {\n        if (this.active) {\n            this.active = false;\n            if (this.idbtrans)\n                this.idbtrans.abort();\n            this._reject(new exceptions.Abort());\n        }\n    }\n    table(tableName) {\n        const memoizedTables = (this._memoizedTables || (this._memoizedTables = {}));\n        if (hasOwn(memoizedTables, tableName))\n            return memoizedTables[tableName];\n        const tableSchema = this.schema[tableName];\n        if (!tableSchema) {\n            throw new exceptions.NotFound(\"Table \" + tableName + \" not part of transaction\");\n        }\n        const transactionBoundTable = new this.db.Table(tableName, tableSchema, this);\n        transactionBoundTable.core = this.db.core.table(tableName);\n        memoizedTables[tableName] = transactionBoundTable;\n        return transactionBoundTable;\n    }\n}\n\nfunction createTransactionConstructor(db) {\n    return makeClassConstructor(Transaction.prototype, function Transaction(mode, storeNames, dbschema, chromeTransactionDurability, parent) {\n        this.db = db;\n        this.mode = mode;\n        this.storeNames = storeNames;\n        this.schema = dbschema;\n        this.chromeTransactionDurability = chromeTransactionDurability;\n        this.idbtrans = null;\n        this.on = Events(this, \"complete\", \"error\", \"abort\");\n        this.parent = parent || null;\n        this.active = true;\n        this._reculock = 0;\n        this._blockedFuncs = [];\n        this._resolve = null;\n        this._reject = null;\n        this._waitingFor = null;\n        this._waitingQueue = null;\n        this._spinCount = 0;\n        this._completion = new DexiePromise((resolve, reject) => {\n            this._resolve = resolve;\n            this._reject = reject;\n        });\n        this._completion.then(() => {\n            this.active = false;\n            this.on.complete.fire();\n        }, e => {\n            var wasActive = this.active;\n            this.active = false;\n            this.on.error.fire(e);\n            this.parent ?\n                this.parent._reject(e) :\n                wasActive && this.idbtrans && this.idbtrans.abort();\n            return rejection(e);\n        });\n    });\n}\n\nfunction createIndexSpec(name, keyPath, unique, multi, auto, compound, isPrimKey) {\n    return {\n        name,\n        keyPath,\n        unique,\n        multi,\n        auto,\n        compound,\n        src: (unique && !isPrimKey ? '&' : '') + (multi ? '*' : '') + (auto ? \"++\" : \"\") + nameFromKeyPath(keyPath)\n    };\n}\nfunction nameFromKeyPath(keyPath) {\n    return typeof keyPath === 'string' ?\n        keyPath :\n        keyPath ? ('[' + [].join.call(keyPath, '+') + ']') : \"\";\n}\n\nfunction createTableSchema(name, primKey, indexes) {\n    return {\n        name,\n        primKey,\n        indexes,\n        mappedClass: null,\n        idxByName: arrayToObject(indexes, index => [index.name, index])\n    };\n}\n\nfunction safariMultiStoreFix(storeNames) {\n    return storeNames.length === 1 ? storeNames[0] : storeNames;\n}\nlet getMaxKey = (IdbKeyRange) => {\n    try {\n        IdbKeyRange.only([[]]);\n        getMaxKey = () => [[]];\n        return [[]];\n    }\n    catch (e) {\n        getMaxKey = () => maxString;\n        return maxString;\n    }\n};\n\nfunction getKeyExtractor(keyPath) {\n    if (keyPath == null) {\n        return () => undefined;\n    }\n    else if (typeof keyPath === 'string') {\n        return getSinglePathKeyExtractor(keyPath);\n    }\n    else {\n        return obj => getByKeyPath(obj, keyPath);\n    }\n}\nfunction getSinglePathKeyExtractor(keyPath) {\n    const split = keyPath.split('.');\n    if (split.length === 1) {\n        return obj => obj[keyPath];\n    }\n    else {\n        return obj => getByKeyPath(obj, keyPath);\n    }\n}\n\nfunction arrayify(arrayLike) {\n    return [].slice.call(arrayLike);\n}\nlet _id_counter = 0;\nfunction getKeyPathAlias(keyPath) {\n    return keyPath == null ?\n        \":id\" :\n        typeof keyPath === 'string' ?\n            keyPath :\n            `[${keyPath.join('+')}]`;\n}\nfunction createDBCore(db, IdbKeyRange, tmpTrans) {\n    function extractSchema(db, trans) {\n        const tables = arrayify(db.objectStoreNames);\n        return {\n            schema: {\n                name: db.name,\n                tables: tables.map(table => trans.objectStore(table)).map(store => {\n                    const { keyPath, autoIncrement } = store;\n                    const compound = isArray(keyPath);\n                    const outbound = keyPath == null;\n                    const indexByKeyPath = {};\n                    const result = {\n                        name: store.name,\n                        primaryKey: {\n                            name: null,\n                            isPrimaryKey: true,\n                            outbound,\n                            compound,\n                            keyPath,\n                            autoIncrement,\n                            unique: true,\n                            extractKey: getKeyExtractor(keyPath)\n                        },\n                        indexes: arrayify(store.indexNames).map(indexName => store.index(indexName))\n                            .map(index => {\n                            const { name, unique, multiEntry, keyPath } = index;\n                            const compound = isArray(keyPath);\n                            const result = {\n                                name,\n                                compound,\n                                keyPath,\n                                unique,\n                                multiEntry,\n                                extractKey: getKeyExtractor(keyPath)\n                            };\n                            indexByKeyPath[getKeyPathAlias(keyPath)] = result;\n                            return result;\n                        }),\n                        getIndexByKeyPath: (keyPath) => indexByKeyPath[getKeyPathAlias(keyPath)]\n                    };\n                    indexByKeyPath[\":id\"] = result.primaryKey;\n                    if (keyPath != null) {\n                        indexByKeyPath[getKeyPathAlias(keyPath)] = result.primaryKey;\n                    }\n                    return result;\n                })\n            },\n            hasGetAll: tables.length > 0 && ('getAll' in trans.objectStore(tables[0])) &&\n                !(typeof navigator !== 'undefined' && /Safari/.test(navigator.userAgent) &&\n                    !/(Chrome\\/|Edge\\/)/.test(navigator.userAgent) &&\n                    [].concat(navigator.userAgent.match(/Safari\\/(\\d*)/))[1] < 604)\n        };\n    }\n    function makeIDBKeyRange(range) {\n        if (range.type === 3 )\n            return null;\n        if (range.type === 4 )\n            throw new Error(\"Cannot convert never type to IDBKeyRange\");\n        const { lower, upper, lowerOpen, upperOpen } = range;\n        const idbRange = lower === undefined ?\n            upper === undefined ?\n                null :\n                IdbKeyRange.upperBound(upper, !!upperOpen) :\n            upper === undefined ?\n                IdbKeyRange.lowerBound(lower, !!lowerOpen) :\n                IdbKeyRange.bound(lower, upper, !!lowerOpen, !!upperOpen);\n        return idbRange;\n    }\n    function createDbCoreTable(tableSchema) {\n        const tableName = tableSchema.name;\n        function mutate({ trans, type, keys, values, range }) {\n            return new Promise((resolve, reject) => {\n                resolve = wrap(resolve);\n                const store = trans.objectStore(tableName);\n                const outbound = store.keyPath == null;\n                const isAddOrPut = type === \"put\" || type === \"add\";\n                if (!isAddOrPut && type !== 'delete' && type !== 'deleteRange')\n                    throw new Error(\"Invalid operation type: \" + type);\n                const { length } = keys || values || { length: 1 };\n                if (keys && values && keys.length !== values.length) {\n                    throw new Error(\"Given keys array must have same length as given values array.\");\n                }\n                if (length === 0)\n                    return resolve({ numFailures: 0, failures: {}, results: [], lastResult: undefined });\n                let req;\n                const reqs = [];\n                const failures = [];\n                let numFailures = 0;\n                const errorHandler = event => {\n                    ++numFailures;\n                    preventDefault(event);\n                };\n                if (type === 'deleteRange') {\n                    if (range.type === 4 )\n                        return resolve({ numFailures, failures, results: [], lastResult: undefined });\n                    if (range.type === 3 )\n                        reqs.push(req = store.clear());\n                    else\n                        reqs.push(req = store.delete(makeIDBKeyRange(range)));\n                }\n                else {\n                    const [args1, args2] = isAddOrPut ?\n                        outbound ?\n                            [values, keys] :\n                            [values, null] :\n                        [keys, null];\n                    if (isAddOrPut) {\n                        for (let i = 0; i < length; ++i) {\n                            reqs.push(req = (args2 && args2[i] !== undefined ?\n                                store[type](args1[i], args2[i]) :\n                                store[type](args1[i])));\n                            req.onerror = errorHandler;\n                        }\n                    }\n                    else {\n                        for (let i = 0; i < length; ++i) {\n                            reqs.push(req = store[type](args1[i]));\n                            req.onerror = errorHandler;\n                        }\n                    }\n                }\n                const done = event => {\n                    const lastResult = event.target.result;\n                    reqs.forEach((req, i) => req.error != null && (failures[i] = req.error));\n                    resolve({\n                        numFailures,\n                        failures,\n                        results: type === \"delete\" ? keys : reqs.map(req => req.result),\n                        lastResult\n                    });\n                };\n                req.onerror = event => {\n                    errorHandler(event);\n                    done(event);\n                };\n                req.onsuccess = done;\n            });\n        }\n        function openCursor({ trans, values, query, reverse, unique }) {\n            return new Promise((resolve, reject) => {\n                resolve = wrap(resolve);\n                const { index, range } = query;\n                const store = trans.objectStore(tableName);\n                const source = index.isPrimaryKey ?\n                    store :\n                    store.index(index.name);\n                const direction = reverse ?\n                    unique ?\n                        \"prevunique\" :\n                        \"prev\" :\n                    unique ?\n                        \"nextunique\" :\n                        \"next\";\n                const req = values || !('openKeyCursor' in source) ?\n                    source.openCursor(makeIDBKeyRange(range), direction) :\n                    source.openKeyCursor(makeIDBKeyRange(range), direction);\n                req.onerror = eventRejectHandler(reject);\n                req.onsuccess = wrap(ev => {\n                    const cursor = req.result;\n                    if (!cursor) {\n                        resolve(null);\n                        return;\n                    }\n                    cursor.___id = ++_id_counter;\n                    cursor.done = false;\n                    const _cursorContinue = cursor.continue.bind(cursor);\n                    let _cursorContinuePrimaryKey = cursor.continuePrimaryKey;\n                    if (_cursorContinuePrimaryKey)\n                        _cursorContinuePrimaryKey = _cursorContinuePrimaryKey.bind(cursor);\n                    const _cursorAdvance = cursor.advance.bind(cursor);\n                    const doThrowCursorIsNotStarted = () => { throw new Error(\"Cursor not started\"); };\n                    const doThrowCursorIsStopped = () => { throw new Error(\"Cursor not stopped\"); };\n                    cursor.trans = trans;\n                    cursor.stop = cursor.continue = cursor.continuePrimaryKey = cursor.advance = doThrowCursorIsNotStarted;\n                    cursor.fail = wrap(reject);\n                    cursor.next = function () {\n                        let gotOne = 1;\n                        return this.start(() => gotOne-- ? this.continue() : this.stop()).then(() => this);\n                    };\n                    cursor.start = (callback) => {\n                        const iterationPromise = new Promise((resolveIteration, rejectIteration) => {\n                            resolveIteration = wrap(resolveIteration);\n                            req.onerror = eventRejectHandler(rejectIteration);\n                            cursor.fail = rejectIteration;\n                            cursor.stop = value => {\n                                cursor.stop = cursor.continue = cursor.continuePrimaryKey = cursor.advance = doThrowCursorIsStopped;\n                                resolveIteration(value);\n                            };\n                        });\n                        const guardedCallback = () => {\n                            if (req.result) {\n                                try {\n                                    callback();\n                                }\n                                catch (err) {\n                                    cursor.fail(err);\n                                }\n                            }\n                            else {\n                                cursor.done = true;\n                                cursor.start = () => { throw new Error(\"Cursor behind last entry\"); };\n                                cursor.stop();\n                            }\n                        };\n                        req.onsuccess = wrap(ev => {\n                            req.onsuccess = guardedCallback;\n                            guardedCallback();\n                        });\n                        cursor.continue = _cursorContinue;\n                        cursor.continuePrimaryKey = _cursorContinuePrimaryKey;\n                        cursor.advance = _cursorAdvance;\n                        guardedCallback();\n                        return iterationPromise;\n                    };\n                    resolve(cursor);\n                }, reject);\n            });\n        }\n        function query(hasGetAll) {\n            return (request) => {\n                return new Promise((resolve, reject) => {\n                    resolve = wrap(resolve);\n                    const { trans, values, limit, query } = request;\n                    const nonInfinitLimit = limit === Infinity ? undefined : limit;\n                    const { index, range } = query;\n                    const store = trans.objectStore(tableName);\n                    const source = index.isPrimaryKey ? store : store.index(index.name);\n                    const idbKeyRange = makeIDBKeyRange(range);\n                    if (limit === 0)\n                        return resolve({ result: [] });\n                    if (hasGetAll) {\n                        const req = values ?\n                            source.getAll(idbKeyRange, nonInfinitLimit) :\n                            source.getAllKeys(idbKeyRange, nonInfinitLimit);\n                        req.onsuccess = event => resolve({ result: event.target.result });\n                        req.onerror = eventRejectHandler(reject);\n                    }\n                    else {\n                        let count = 0;\n                        const req = values || !('openKeyCursor' in source) ?\n                            source.openCursor(idbKeyRange) :\n                            source.openKeyCursor(idbKeyRange);\n                        const result = [];\n                        req.onsuccess = event => {\n                            const cursor = req.result;\n                            if (!cursor)\n                                return resolve({ result });\n                            result.push(values ? cursor.value : cursor.primaryKey);\n                            if (++count === limit)\n                                return resolve({ result });\n                            cursor.continue();\n                        };\n                        req.onerror = eventRejectHandler(reject);\n                    }\n                });\n            };\n        }\n        return {\n            name: tableName,\n            schema: tableSchema,\n            mutate,\n            getMany({ trans, keys }) {\n                return new Promise((resolve, reject) => {\n                    resolve = wrap(resolve);\n                    const store = trans.objectStore(tableName);\n                    const length = keys.length;\n                    const result = new Array(length);\n                    let keyCount = 0;\n                    let callbackCount = 0;\n                    let req;\n                    const successHandler = event => {\n                        const req = event.target;\n                        if ((result[req._pos] = req.result) != null)\n                            ;\n                        if (++callbackCount === keyCount)\n                            resolve(result);\n                    };\n                    const errorHandler = eventRejectHandler(reject);\n                    for (let i = 0; i < length; ++i) {\n                        const key = keys[i];\n                        if (key != null) {\n                            req = store.get(keys[i]);\n                            req._pos = i;\n                            req.onsuccess = successHandler;\n                            req.onerror = errorHandler;\n                            ++keyCount;\n                        }\n                    }\n                    if (keyCount === 0)\n                        resolve(result);\n                });\n            },\n            get({ trans, key }) {\n                return new Promise((resolve, reject) => {\n                    resolve = wrap(resolve);\n                    const store = trans.objectStore(tableName);\n                    const req = store.get(key);\n                    req.onsuccess = event => resolve(event.target.result);\n                    req.onerror = eventRejectHandler(reject);\n                });\n            },\n            query: query(hasGetAll),\n            openCursor,\n            count({ query, trans }) {\n                const { index, range } = query;\n                return new Promise((resolve, reject) => {\n                    const store = trans.objectStore(tableName);\n                    const source = index.isPrimaryKey ? store : store.index(index.name);\n                    const idbKeyRange = makeIDBKeyRange(range);\n                    const req = idbKeyRange ? source.count(idbKeyRange) : source.count();\n                    req.onsuccess = wrap(ev => resolve(ev.target.result));\n                    req.onerror = eventRejectHandler(reject);\n                });\n            }\n        };\n    }\n    const { schema, hasGetAll } = extractSchema(db, tmpTrans);\n    const tables = schema.tables.map(tableSchema => createDbCoreTable(tableSchema));\n    const tableMap = {};\n    tables.forEach(table => tableMap[table.name] = table);\n    return {\n        stack: \"dbcore\",\n        transaction: db.transaction.bind(db),\n        table(name) {\n            const result = tableMap[name];\n            if (!result)\n                throw new Error(`Table '${name}' not found`);\n            return tableMap[name];\n        },\n        MIN_KEY: -Infinity,\n        MAX_KEY: getMaxKey(IdbKeyRange),\n        schema\n    };\n}\n\nfunction createMiddlewareStack(stackImpl, middlewares) {\n    return middlewares.reduce((down, { create }) => ({ ...down, ...create(down) }), stackImpl);\n}\nfunction createMiddlewareStacks(middlewares, idbdb, { IDBKeyRange, indexedDB }, tmpTrans) {\n    const dbcore = createMiddlewareStack(createDBCore(idbdb, IDBKeyRange, tmpTrans), middlewares.dbcore);\n    return {\n        dbcore\n    };\n}\nfunction generateMiddlewareStacks({ _novip: db }, tmpTrans) {\n    const idbdb = tmpTrans.db;\n    const stacks = createMiddlewareStacks(db._middlewares, idbdb, db._deps, tmpTrans);\n    db.core = stacks.dbcore;\n    db.tables.forEach(table => {\n        const tableName = table.name;\n        if (db.core.schema.tables.some(tbl => tbl.name === tableName)) {\n            table.core = db.core.table(tableName);\n            if (db[tableName] instanceof db.Table) {\n                db[tableName].core = table.core;\n            }\n        }\n    });\n}\n\nfunction setApiOnPlace({ _novip: db }, objs, tableNames, dbschema) {\n    tableNames.forEach(tableName => {\n        const schema = dbschema[tableName];\n        objs.forEach(obj => {\n            const propDesc = getPropertyDescriptor(obj, tableName);\n            if (!propDesc || (\"value\" in propDesc && propDesc.value === undefined)) {\n                if (obj === db.Transaction.prototype || obj instanceof db.Transaction) {\n                    setProp(obj, tableName, {\n                        get() { return this.table(tableName); },\n                        set(value) {\n                            defineProperty(this, tableName, { value, writable: true, configurable: true, enumerable: true });\n                        }\n                    });\n                }\n                else {\n                    obj[tableName] = new db.Table(tableName, schema);\n                }\n            }\n        });\n    });\n}\nfunction removeTablesApi({ _novip: db }, objs) {\n    objs.forEach(obj => {\n        for (let key in obj) {\n            if (obj[key] instanceof db.Table)\n                delete obj[key];\n        }\n    });\n}\nfunction lowerVersionFirst(a, b) {\n    return a._cfg.version - b._cfg.version;\n}\nfunction runUpgraders(db, oldVersion, idbUpgradeTrans, reject) {\n    const globalSchema = db._dbSchema;\n    const trans = db._createTransaction('readwrite', db._storeNames, globalSchema);\n    trans.create(idbUpgradeTrans);\n    trans._completion.catch(reject);\n    const rejectTransaction = trans._reject.bind(trans);\n    const transless = PSD.transless || PSD;\n    newScope(() => {\n        PSD.trans = trans;\n        PSD.transless = transless;\n        if (oldVersion === 0) {\n            keys(globalSchema).forEach(tableName => {\n                createTable(idbUpgradeTrans, tableName, globalSchema[tableName].primKey, globalSchema[tableName].indexes);\n            });\n            generateMiddlewareStacks(db, idbUpgradeTrans);\n            DexiePromise.follow(() => db.on.populate.fire(trans)).catch(rejectTransaction);\n        }\n        else\n            updateTablesAndIndexes(db, oldVersion, trans, idbUpgradeTrans).catch(rejectTransaction);\n    });\n}\nfunction updateTablesAndIndexes({ _novip: db }, oldVersion, trans, idbUpgradeTrans) {\n    const queue = [];\n    const versions = db._versions;\n    let globalSchema = db._dbSchema = buildGlobalSchema(db, db.idbdb, idbUpgradeTrans);\n    let anyContentUpgraderHasRun = false;\n    const versToRun = versions.filter(v => v._cfg.version >= oldVersion);\n    versToRun.forEach(version => {\n        queue.push(() => {\n            const oldSchema = globalSchema;\n            const newSchema = version._cfg.dbschema;\n            adjustToExistingIndexNames(db, oldSchema, idbUpgradeTrans);\n            adjustToExistingIndexNames(db, newSchema, idbUpgradeTrans);\n            globalSchema = db._dbSchema = newSchema;\n            const diff = getSchemaDiff(oldSchema, newSchema);\n            diff.add.forEach(tuple => {\n                createTable(idbUpgradeTrans, tuple[0], tuple[1].primKey, tuple[1].indexes);\n            });\n            diff.change.forEach(change => {\n                if (change.recreate) {\n                    throw new exceptions.Upgrade(\"Not yet support for changing primary key\");\n                }\n                else {\n                    const store = idbUpgradeTrans.objectStore(change.name);\n                    change.add.forEach(idx => addIndex(store, idx));\n                    change.change.forEach(idx => {\n                        store.deleteIndex(idx.name);\n                        addIndex(store, idx);\n                    });\n                    change.del.forEach(idxName => store.deleteIndex(idxName));\n                }\n            });\n            const contentUpgrade = version._cfg.contentUpgrade;\n            if (contentUpgrade && version._cfg.version > oldVersion) {\n                generateMiddlewareStacks(db, idbUpgradeTrans);\n                trans._memoizedTables = {};\n                anyContentUpgraderHasRun = true;\n                let upgradeSchema = shallowClone(newSchema);\n                diff.del.forEach(table => {\n                    upgradeSchema[table] = oldSchema[table];\n                });\n                removeTablesApi(db, [db.Transaction.prototype]);\n                setApiOnPlace(db, [db.Transaction.prototype], keys(upgradeSchema), upgradeSchema);\n                trans.schema = upgradeSchema;\n                const contentUpgradeIsAsync = isAsyncFunction(contentUpgrade);\n                if (contentUpgradeIsAsync) {\n                    incrementExpectedAwaits();\n                }\n                let returnValue;\n                const promiseFollowed = DexiePromise.follow(() => {\n                    returnValue = contentUpgrade(trans);\n                    if (returnValue) {\n                        if (contentUpgradeIsAsync) {\n                            var decrementor = decrementExpectedAwaits.bind(null, null);\n                            returnValue.then(decrementor, decrementor);\n                        }\n                    }\n                });\n                return (returnValue && typeof returnValue.then === 'function' ?\n                    DexiePromise.resolve(returnValue) : promiseFollowed.then(() => returnValue));\n            }\n        });\n        queue.push(idbtrans => {\n            if (!anyContentUpgraderHasRun || !hasIEDeleteObjectStoreBug) {\n                const newSchema = version._cfg.dbschema;\n                deleteRemovedTables(newSchema, idbtrans);\n            }\n            removeTablesApi(db, [db.Transaction.prototype]);\n            setApiOnPlace(db, [db.Transaction.prototype], db._storeNames, db._dbSchema);\n            trans.schema = db._dbSchema;\n        });\n    });\n    function runQueue() {\n        return queue.length ? DexiePromise.resolve(queue.shift()(trans.idbtrans)).then(runQueue) :\n            DexiePromise.resolve();\n    }\n    return runQueue().then(() => {\n        createMissingTables(globalSchema, idbUpgradeTrans);\n    });\n}\nfunction getSchemaDiff(oldSchema, newSchema) {\n    const diff = {\n        del: [],\n        add: [],\n        change: []\n    };\n    let table;\n    for (table in oldSchema) {\n        if (!newSchema[table])\n            diff.del.push(table);\n    }\n    for (table in newSchema) {\n        const oldDef = oldSchema[table], newDef = newSchema[table];\n        if (!oldDef) {\n            diff.add.push([table, newDef]);\n        }\n        else {\n            const change = {\n                name: table,\n                def: newDef,\n                recreate: false,\n                del: [],\n                add: [],\n                change: []\n            };\n            if ((\n            '' + (oldDef.primKey.keyPath || '')) !== ('' + (newDef.primKey.keyPath || '')) ||\n                (oldDef.primKey.auto !== newDef.primKey.auto && !isIEOrEdge))\n             {\n                change.recreate = true;\n                diff.change.push(change);\n            }\n            else {\n                const oldIndexes = oldDef.idxByName;\n                const newIndexes = newDef.idxByName;\n                let idxName;\n                for (idxName in oldIndexes) {\n                    if (!newIndexes[idxName])\n                        change.del.push(idxName);\n                }\n                for (idxName in newIndexes) {\n                    const oldIdx = oldIndexes[idxName], newIdx = newIndexes[idxName];\n                    if (!oldIdx)\n                        change.add.push(newIdx);\n                    else if (oldIdx.src !== newIdx.src)\n                        change.change.push(newIdx);\n                }\n                if (change.del.length > 0 || change.add.length > 0 || change.change.length > 0) {\n                    diff.change.push(change);\n                }\n            }\n        }\n    }\n    return diff;\n}\nfunction createTable(idbtrans, tableName, primKey, indexes) {\n    const store = idbtrans.db.createObjectStore(tableName, primKey.keyPath ?\n        { keyPath: primKey.keyPath, autoIncrement: primKey.auto } :\n        { autoIncrement: primKey.auto });\n    indexes.forEach(idx => addIndex(store, idx));\n    return store;\n}\nfunction createMissingTables(newSchema, idbtrans) {\n    keys(newSchema).forEach(tableName => {\n        if (!idbtrans.db.objectStoreNames.contains(tableName)) {\n            createTable(idbtrans, tableName, newSchema[tableName].primKey, newSchema[tableName].indexes);\n        }\n    });\n}\nfunction deleteRemovedTables(newSchema, idbtrans) {\n    [].slice.call(idbtrans.db.objectStoreNames).forEach(storeName => newSchema[storeName] == null && idbtrans.db.deleteObjectStore(storeName));\n}\nfunction addIndex(store, idx) {\n    store.createIndex(idx.name, idx.keyPath, { unique: idx.unique, multiEntry: idx.multi });\n}\nfunction buildGlobalSchema(db, idbdb, tmpTrans) {\n    const globalSchema = {};\n    const dbStoreNames = slice(idbdb.objectStoreNames, 0);\n    dbStoreNames.forEach(storeName => {\n        const store = tmpTrans.objectStore(storeName);\n        let keyPath = store.keyPath;\n        const primKey = createIndexSpec(nameFromKeyPath(keyPath), keyPath || \"\", false, false, !!store.autoIncrement, keyPath && typeof keyPath !== \"string\", true);\n        const indexes = [];\n        for (let j = 0; j < store.indexNames.length; ++j) {\n            const idbindex = store.index(store.indexNames[j]);\n            keyPath = idbindex.keyPath;\n            var index = createIndexSpec(idbindex.name, keyPath, !!idbindex.unique, !!idbindex.multiEntry, false, keyPath && typeof keyPath !== \"string\", false);\n            indexes.push(index);\n        }\n        globalSchema[storeName] = createTableSchema(storeName, primKey, indexes);\n    });\n    return globalSchema;\n}\nfunction readGlobalSchema({ _novip: db }, idbdb, tmpTrans) {\n    db.verno = idbdb.version / 10;\n    const globalSchema = db._dbSchema = buildGlobalSchema(db, idbdb, tmpTrans);\n    db._storeNames = slice(idbdb.objectStoreNames, 0);\n    setApiOnPlace(db, [db._allTables], keys(globalSchema), globalSchema);\n}\nfunction verifyInstalledSchema(db, tmpTrans) {\n    const installedSchema = buildGlobalSchema(db, db.idbdb, tmpTrans);\n    const diff = getSchemaDiff(installedSchema, db._dbSchema);\n    return !(diff.add.length || diff.change.some(ch => ch.add.length || ch.change.length));\n}\nfunction adjustToExistingIndexNames({ _novip: db }, schema, idbtrans) {\n    const storeNames = idbtrans.db.objectStoreNames;\n    for (let i = 0; i < storeNames.length; ++i) {\n        const storeName = storeNames[i];\n        const store = idbtrans.objectStore(storeName);\n        db._hasGetAll = 'getAll' in store;\n        for (let j = 0; j < store.indexNames.length; ++j) {\n            const indexName = store.indexNames[j];\n            const keyPath = store.index(indexName).keyPath;\n            const dexieName = typeof keyPath === 'string' ? keyPath : \"[\" + slice(keyPath).join('+') + \"]\";\n            if (schema[storeName]) {\n                const indexSpec = schema[storeName].idxByName[dexieName];\n                if (indexSpec) {\n                    indexSpec.name = indexName;\n                    delete schema[storeName].idxByName[dexieName];\n                    schema[storeName].idxByName[indexName] = indexSpec;\n                }\n            }\n        }\n    }\n    if (typeof navigator !== 'undefined' && /Safari/.test(navigator.userAgent) &&\n        !/(Chrome\\/|Edge\\/)/.test(navigator.userAgent) &&\n        _global.WorkerGlobalScope && _global instanceof _global.WorkerGlobalScope &&\n        [].concat(navigator.userAgent.match(/Safari\\/(\\d*)/))[1] < 604) {\n        db._hasGetAll = false;\n    }\n}\nfunction parseIndexSyntax(primKeyAndIndexes) {\n    return primKeyAndIndexes.split(',').map((index, indexNum) => {\n        index = index.trim();\n        const name = index.replace(/([&*]|\\+\\+)/g, \"\");\n        const keyPath = /^\\[/.test(name) ? name.match(/^\\[(.*)\\]$/)[1].split('+') : name;\n        return createIndexSpec(name, keyPath || null, /\\&/.test(index), /\\*/.test(index), /\\+\\+/.test(index), isArray(keyPath), indexNum === 0);\n    });\n}\n\nclass Version {\n    _parseStoresSpec(stores, outSchema) {\n        keys(stores).forEach(tableName => {\n            if (stores[tableName] !== null) {\n                var indexes = parseIndexSyntax(stores[tableName]);\n                var primKey = indexes.shift();\n                if (primKey.multi)\n                    throw new exceptions.Schema(\"Primary key cannot be multi-valued\");\n                indexes.forEach(idx => {\n                    if (idx.auto)\n                        throw new exceptions.Schema(\"Only primary key can be marked as autoIncrement (++)\");\n                    if (!idx.keyPath)\n                        throw new exceptions.Schema(\"Index must have a name and cannot be an empty string\");\n                });\n                outSchema[tableName] = createTableSchema(tableName, primKey, indexes);\n            }\n        });\n    }\n    stores(stores) {\n        const db = this.db;\n        this._cfg.storesSource = this._cfg.storesSource ?\n            extend(this._cfg.storesSource, stores) :\n            stores;\n        const versions = db._versions;\n        const storesSpec = {};\n        let dbschema = {};\n        versions.forEach(version => {\n            extend(storesSpec, version._cfg.storesSource);\n            dbschema = (version._cfg.dbschema = {});\n            version._parseStoresSpec(storesSpec, dbschema);\n        });\n        db._dbSchema = dbschema;\n        removeTablesApi(db, [db._allTables, db, db.Transaction.prototype]);\n        setApiOnPlace(db, [db._allTables, db, db.Transaction.prototype, this._cfg.tables], keys(dbschema), dbschema);\n        db._storeNames = keys(dbschema);\n        return this;\n    }\n    upgrade(upgradeFunction) {\n        this._cfg.contentUpgrade = promisableChain(this._cfg.contentUpgrade || nop, upgradeFunction);\n        return this;\n    }\n}\n\nfunction createVersionConstructor(db) {\n    return makeClassConstructor(Version.prototype, function Version(versionNumber) {\n        this.db = db;\n        this._cfg = {\n            version: versionNumber,\n            storesSource: null,\n            dbschema: {},\n            tables: {},\n            contentUpgrade: null\n        };\n    });\n}\n\nfunction getDbNamesTable(indexedDB, IDBKeyRange) {\n    let dbNamesDB = indexedDB[\"_dbNamesDB\"];\n    if (!dbNamesDB) {\n        dbNamesDB = indexedDB[\"_dbNamesDB\"] = new Dexie$1(DBNAMES_DB, {\n            addons: [],\n            indexedDB,\n            IDBKeyRange,\n        });\n        dbNamesDB.version(1).stores({ dbnames: \"name\" });\n    }\n    return dbNamesDB.table(\"dbnames\");\n}\nfunction hasDatabasesNative(indexedDB) {\n    return indexedDB && typeof indexedDB.databases === \"function\";\n}\nfunction getDatabaseNames({ indexedDB, IDBKeyRange, }) {\n    return hasDatabasesNative(indexedDB)\n        ? Promise.resolve(indexedDB.databases()).then((infos) => infos\n            .map((info) => info.name)\n            .filter((name) => name !== DBNAMES_DB))\n        : getDbNamesTable(indexedDB, IDBKeyRange).toCollection().primaryKeys();\n}\nfunction _onDatabaseCreated({ indexedDB, IDBKeyRange }, name) {\n    !hasDatabasesNative(indexedDB) &&\n        name !== DBNAMES_DB &&\n        getDbNamesTable(indexedDB, IDBKeyRange).put({ name }).catch(nop);\n}\nfunction _onDatabaseDeleted({ indexedDB, IDBKeyRange }, name) {\n    !hasDatabasesNative(indexedDB) &&\n        name !== DBNAMES_DB &&\n        getDbNamesTable(indexedDB, IDBKeyRange).delete(name).catch(nop);\n}\n\nfunction vip(fn) {\n    return newScope(function () {\n        PSD.letThrough = true;\n        return fn();\n    });\n}\n\nfunction idbReady() {\n    var isSafari = !navigator.userAgentData &&\n        /Safari\\//.test(navigator.userAgent) &&\n        !/Chrom(e|ium)\\//.test(navigator.userAgent);\n    if (!isSafari || !indexedDB.databases)\n        return Promise.resolve();\n    var intervalId;\n    return new Promise(function (resolve) {\n        var tryIdb = function () { return indexedDB.databases().finally(resolve); };\n        intervalId = setInterval(tryIdb, 100);\n        tryIdb();\n    }).finally(function () { return clearInterval(intervalId); });\n}\n\nfunction dexieOpen(db) {\n    const state = db._state;\n    const { indexedDB } = db._deps;\n    if (state.isBeingOpened || db.idbdb)\n        return state.dbReadyPromise.then(() => state.dbOpenError ?\n            rejection(state.dbOpenError) :\n            db);\n    debug && (state.openCanceller._stackHolder = getErrorWithStack());\n    state.isBeingOpened = true;\n    state.dbOpenError = null;\n    state.openComplete = false;\n    const openCanceller = state.openCanceller;\n    function throwIfCancelled() {\n        if (state.openCanceller !== openCanceller)\n            throw new exceptions.DatabaseClosed('db.open() was cancelled');\n    }\n    let resolveDbReady = state.dbReadyResolve,\n    upgradeTransaction = null, wasCreated = false;\n    const tryOpenDB = () => new DexiePromise((resolve, reject) => {\n        throwIfCancelled();\n        if (!indexedDB)\n            throw new exceptions.MissingAPI();\n        const dbName = db.name;\n        const req = state.autoSchema ?\n            indexedDB.open(dbName) :\n            indexedDB.open(dbName, Math.round(db.verno * 10));\n        if (!req)\n            throw new exceptions.MissingAPI();\n        req.onerror = eventRejectHandler(reject);\n        req.onblocked = wrap(db._fireOnBlocked);\n        req.onupgradeneeded = wrap(e => {\n            upgradeTransaction = req.transaction;\n            if (state.autoSchema && !db._options.allowEmptyDB) {\n                req.onerror = preventDefault;\n                upgradeTransaction.abort();\n                req.result.close();\n                const delreq = indexedDB.deleteDatabase(dbName);\n                delreq.onsuccess = delreq.onerror = wrap(() => {\n                    reject(new exceptions.NoSuchDatabase(`Database ${dbName} doesnt exist`));\n                });\n            }\n            else {\n                upgradeTransaction.onerror = eventRejectHandler(reject);\n                var oldVer = e.oldVersion > Math.pow(2, 62) ? 0 : e.oldVersion;\n                wasCreated = oldVer < 1;\n                db._novip.idbdb = req.result;\n                runUpgraders(db, oldVer / 10, upgradeTransaction, reject);\n            }\n        }, reject);\n        req.onsuccess = wrap(() => {\n            upgradeTransaction = null;\n            const idbdb = db._novip.idbdb = req.result;\n            const objectStoreNames = slice(idbdb.objectStoreNames);\n            if (objectStoreNames.length > 0)\n                try {\n                    const tmpTrans = idbdb.transaction(safariMultiStoreFix(objectStoreNames), 'readonly');\n                    if (state.autoSchema)\n                        readGlobalSchema(db, idbdb, tmpTrans);\n                    else {\n                        adjustToExistingIndexNames(db, db._dbSchema, tmpTrans);\n                        if (!verifyInstalledSchema(db, tmpTrans)) {\n                            console.warn(`Dexie SchemaDiff: Schema was extended without increasing the number passed to db.version(). Some queries may fail.`);\n                        }\n                    }\n                    generateMiddlewareStacks(db, tmpTrans);\n                }\n                catch (e) {\n                }\n            connections.push(db);\n            idbdb.onversionchange = wrap(ev => {\n                state.vcFired = true;\n                db.on(\"versionchange\").fire(ev);\n            });\n            idbdb.onclose = wrap(ev => {\n                db.on(\"close\").fire(ev);\n            });\n            if (wasCreated)\n                _onDatabaseCreated(db._deps, dbName);\n            resolve();\n        }, reject);\n    }).catch(err => {\n        if (err && err.name === 'UnknownError' && state.PR1398_maxLoop > 0) {\n            state.PR1398_maxLoop--;\n            console.warn('Dexie: Workaround for Chrome UnknownError on open()');\n            return tryOpenDB();\n        }\n        else {\n            return DexiePromise.reject(err);\n        }\n    });\n    return DexiePromise.race([\n        openCanceller,\n        (typeof navigator === 'undefined' ? DexiePromise.resolve() : idbReady()).then(tryOpenDB)\n    ]).then(() => {\n        throwIfCancelled();\n        state.onReadyBeingFired = [];\n        return DexiePromise.resolve(vip(() => db.on.ready.fire(db.vip))).then(function fireRemainders() {\n            if (state.onReadyBeingFired.length > 0) {\n                let remainders = state.onReadyBeingFired.reduce(promisableChain, nop);\n                state.onReadyBeingFired = [];\n                return DexiePromise.resolve(vip(() => remainders(db.vip))).then(fireRemainders);\n            }\n        });\n    }).finally(() => {\n        state.onReadyBeingFired = null;\n        state.isBeingOpened = false;\n    }).then(() => {\n        return db;\n    }).catch(err => {\n        state.dbOpenError = err;\n        try {\n            upgradeTransaction && upgradeTransaction.abort();\n        }\n        catch (_a) { }\n        if (openCanceller === state.openCanceller) {\n            db._close();\n        }\n        return rejection(err);\n    }).finally(() => {\n        state.openComplete = true;\n        resolveDbReady();\n    });\n}\n\nfunction awaitIterator(iterator) {\n    var callNext = result => iterator.next(result), doThrow = error => iterator.throw(error), onSuccess = step(callNext), onError = step(doThrow);\n    function step(getNext) {\n        return (val) => {\n            var next = getNext(val), value = next.value;\n            return next.done ? value :\n                (!value || typeof value.then !== 'function' ?\n                    isArray(value) ? Promise.all(value).then(onSuccess, onError) : onSuccess(value) :\n                    value.then(onSuccess, onError));\n        };\n    }\n    return step(callNext)();\n}\n\nfunction extractTransactionArgs(mode, _tableArgs_, scopeFunc) {\n    var i = arguments.length;\n    if (i < 2)\n        throw new exceptions.InvalidArgument(\"Too few arguments\");\n    var args = new Array(i - 1);\n    while (--i)\n        args[i - 1] = arguments[i];\n    scopeFunc = args.pop();\n    var tables = flatten(args);\n    return [mode, tables, scopeFunc];\n}\nfunction enterTransactionScope(db, mode, storeNames, parentTransaction, scopeFunc) {\n    return DexiePromise.resolve().then(() => {\n        const transless = PSD.transless || PSD;\n        const trans = db._createTransaction(mode, storeNames, db._dbSchema, parentTransaction);\n        const zoneProps = {\n            trans: trans,\n            transless: transless\n        };\n        if (parentTransaction) {\n            trans.idbtrans = parentTransaction.idbtrans;\n        }\n        else {\n            try {\n                trans.create();\n                db._state.PR1398_maxLoop = 3;\n            }\n            catch (ex) {\n                if (ex.name === errnames.InvalidState && db.isOpen() && --db._state.PR1398_maxLoop > 0) {\n                    console.warn('Dexie: Need to reopen db');\n                    db._close();\n                    return db.open().then(() => enterTransactionScope(db, mode, storeNames, null, scopeFunc));\n                }\n                return rejection(ex);\n            }\n        }\n        const scopeFuncIsAsync = isAsyncFunction(scopeFunc);\n        if (scopeFuncIsAsync) {\n            incrementExpectedAwaits();\n        }\n        let returnValue;\n        const promiseFollowed = DexiePromise.follow(() => {\n            returnValue = scopeFunc.call(trans, trans);\n            if (returnValue) {\n                if (scopeFuncIsAsync) {\n                    var decrementor = decrementExpectedAwaits.bind(null, null);\n                    returnValue.then(decrementor, decrementor);\n                }\n                else if (typeof returnValue.next === 'function' && typeof returnValue.throw === 'function') {\n                    returnValue = awaitIterator(returnValue);\n                }\n            }\n        }, zoneProps);\n        return (returnValue && typeof returnValue.then === 'function' ?\n            DexiePromise.resolve(returnValue).then(x => trans.active ?\n                x\n                : rejection(new exceptions.PrematureCommit(\"Transaction committed too early. See http://bit.ly/2kdckMn\")))\n            : promiseFollowed.then(() => returnValue)).then(x => {\n            if (parentTransaction)\n                trans._resolve();\n            return trans._completion.then(() => x);\n        }).catch(e => {\n            trans._reject(e);\n            return rejection(e);\n        });\n    });\n}\n\nfunction pad(a, value, count) {\n    const result = isArray(a) ? a.slice() : [a];\n    for (let i = 0; i < count; ++i)\n        result.push(value);\n    return result;\n}\nfunction createVirtualIndexMiddleware(down) {\n    return {\n        ...down,\n        table(tableName) {\n            const table = down.table(tableName);\n            const { schema } = table;\n            const indexLookup = {};\n            const allVirtualIndexes = [];\n            function addVirtualIndexes(keyPath, keyTail, lowLevelIndex) {\n                const keyPathAlias = getKeyPathAlias(keyPath);\n                const indexList = (indexLookup[keyPathAlias] = indexLookup[keyPathAlias] || []);\n                const keyLength = keyPath == null ? 0 : typeof keyPath === 'string' ? 1 : keyPath.length;\n                const isVirtual = keyTail > 0;\n                const virtualIndex = {\n                    ...lowLevelIndex,\n                    isVirtual,\n                    keyTail,\n                    keyLength,\n                    extractKey: getKeyExtractor(keyPath),\n                    unique: !isVirtual && lowLevelIndex.unique\n                };\n                indexList.push(virtualIndex);\n                if (!virtualIndex.isPrimaryKey) {\n                    allVirtualIndexes.push(virtualIndex);\n                }\n                if (keyLength > 1) {\n                    const virtualKeyPath = keyLength === 2 ?\n                        keyPath[0] :\n                        keyPath.slice(0, keyLength - 1);\n                    addVirtualIndexes(virtualKeyPath, keyTail + 1, lowLevelIndex);\n                }\n                indexList.sort((a, b) => a.keyTail - b.keyTail);\n                return virtualIndex;\n            }\n            const primaryKey = addVirtualIndexes(schema.primaryKey.keyPath, 0, schema.primaryKey);\n            indexLookup[\":id\"] = [primaryKey];\n            for (const index of schema.indexes) {\n                addVirtualIndexes(index.keyPath, 0, index);\n            }\n            function findBestIndex(keyPath) {\n                const result = indexLookup[getKeyPathAlias(keyPath)];\n                return result && result[0];\n            }\n            function translateRange(range, keyTail) {\n                return {\n                    type: range.type === 1  ?\n                        2  :\n                        range.type,\n                    lower: pad(range.lower, range.lowerOpen ? down.MAX_KEY : down.MIN_KEY, keyTail),\n                    lowerOpen: true,\n                    upper: pad(range.upper, range.upperOpen ? down.MIN_KEY : down.MAX_KEY, keyTail),\n                    upperOpen: true\n                };\n            }\n            function translateRequest(req) {\n                const index = req.query.index;\n                return index.isVirtual ? {\n                    ...req,\n                    query: {\n                        index,\n                        range: translateRange(req.query.range, index.keyTail)\n                    }\n                } : req;\n            }\n            const result = {\n                ...table,\n                schema: {\n                    ...schema,\n                    primaryKey,\n                    indexes: allVirtualIndexes,\n                    getIndexByKeyPath: findBestIndex\n                },\n                count(req) {\n                    return table.count(translateRequest(req));\n                },\n                query(req) {\n                    return table.query(translateRequest(req));\n                },\n                openCursor(req) {\n                    const { keyTail, isVirtual, keyLength } = req.query.index;\n                    if (!isVirtual)\n                        return table.openCursor(req);\n                    function createVirtualCursor(cursor) {\n                        function _continue(key) {\n                            key != null ?\n                                cursor.continue(pad(key, req.reverse ? down.MAX_KEY : down.MIN_KEY, keyTail)) :\n                                req.unique ?\n                                    cursor.continue(cursor.key.slice(0, keyLength)\n                                        .concat(req.reverse\n                                        ? down.MIN_KEY\n                                        : down.MAX_KEY, keyTail)) :\n                                    cursor.continue();\n                        }\n                        const virtualCursor = Object.create(cursor, {\n                            continue: { value: _continue },\n                            continuePrimaryKey: {\n                                value(key, primaryKey) {\n                                    cursor.continuePrimaryKey(pad(key, down.MAX_KEY, keyTail), primaryKey);\n                                }\n                            },\n                            primaryKey: {\n                                get() {\n                                    return cursor.primaryKey;\n                                }\n                            },\n                            key: {\n                                get() {\n                                    const key = cursor.key;\n                                    return keyLength === 1 ?\n                                        key[0] :\n                                        key.slice(0, keyLength);\n                                }\n                            },\n                            value: {\n                                get() {\n                                    return cursor.value;\n                                }\n                            }\n                        });\n                        return virtualCursor;\n                    }\n                    return table.openCursor(translateRequest(req))\n                        .then(cursor => cursor && createVirtualCursor(cursor));\n                }\n            };\n            return result;\n        }\n    };\n}\nconst virtualIndexMiddleware = {\n    stack: \"dbcore\",\n    name: \"VirtualIndexMiddleware\",\n    level: 1,\n    create: createVirtualIndexMiddleware\n};\n\nfunction getObjectDiff(a, b, rv, prfx) {\n    rv = rv || {};\n    prfx = prfx || '';\n    keys(a).forEach((prop) => {\n        if (!hasOwn(b, prop)) {\n            rv[prfx + prop] = undefined;\n        }\n        else {\n            var ap = a[prop], bp = b[prop];\n            if (typeof ap === 'object' && typeof bp === 'object' && ap && bp) {\n                const apTypeName = toStringTag(ap);\n                const bpTypeName = toStringTag(bp);\n                if (apTypeName !== bpTypeName) {\n                    rv[prfx + prop] = b[prop];\n                }\n                else if (apTypeName === 'Object') {\n                    getObjectDiff(ap, bp, rv, prfx + prop + '.');\n                }\n                else if (ap !== bp) {\n                    rv[prfx + prop] = b[prop];\n                }\n            }\n            else if (ap !== bp)\n                rv[prfx + prop] = b[prop];\n        }\n    });\n    keys(b).forEach((prop) => {\n        if (!hasOwn(a, prop)) {\n            rv[prfx + prop] = b[prop];\n        }\n    });\n    return rv;\n}\n\nfunction getEffectiveKeys(primaryKey, req) {\n    if (req.type === 'delete')\n        return req.keys;\n    return req.keys || req.values.map(primaryKey.extractKey);\n}\n\nconst hooksMiddleware = {\n    stack: \"dbcore\",\n    name: \"HooksMiddleware\",\n    level: 2,\n    create: (downCore) => ({\n        ...downCore,\n        table(tableName) {\n            const downTable = downCore.table(tableName);\n            const { primaryKey } = downTable.schema;\n            const tableMiddleware = {\n                ...downTable,\n                mutate(req) {\n                    const dxTrans = PSD.trans;\n                    const { deleting, creating, updating } = dxTrans.table(tableName).hook;\n                    switch (req.type) {\n                        case 'add':\n                            if (creating.fire === nop)\n                                break;\n                            return dxTrans._promise('readwrite', () => addPutOrDelete(req), true);\n                        case 'put':\n                            if (creating.fire === nop && updating.fire === nop)\n                                break;\n                            return dxTrans._promise('readwrite', () => addPutOrDelete(req), true);\n                        case 'delete':\n                            if (deleting.fire === nop)\n                                break;\n                            return dxTrans._promise('readwrite', () => addPutOrDelete(req), true);\n                        case 'deleteRange':\n                            if (deleting.fire === nop)\n                                break;\n                            return dxTrans._promise('readwrite', () => deleteRange(req), true);\n                    }\n                    return downTable.mutate(req);\n                    function addPutOrDelete(req) {\n                        const dxTrans = PSD.trans;\n                        const keys = req.keys || getEffectiveKeys(primaryKey, req);\n                        if (!keys)\n                            throw new Error(\"Keys missing\");\n                        req = req.type === 'add' || req.type === 'put' ?\n                            { ...req, keys } :\n                            { ...req };\n                        if (req.type !== 'delete')\n                            req.values = [...req.values];\n                        if (req.keys)\n                            req.keys = [...req.keys];\n                        return getExistingValues(downTable, req, keys).then(existingValues => {\n                            const contexts = keys.map((key, i) => {\n                                const existingValue = existingValues[i];\n                                const ctx = { onerror: null, onsuccess: null };\n                                if (req.type === 'delete') {\n                                    deleting.fire.call(ctx, key, existingValue, dxTrans);\n                                }\n                                else if (req.type === 'add' || existingValue === undefined) {\n                                    const generatedPrimaryKey = creating.fire.call(ctx, key, req.values[i], dxTrans);\n                                    if (key == null && generatedPrimaryKey != null) {\n                                        key = generatedPrimaryKey;\n                                        req.keys[i] = key;\n                                        if (!primaryKey.outbound) {\n                                            setByKeyPath(req.values[i], primaryKey.keyPath, key);\n                                        }\n                                    }\n                                }\n                                else {\n                                    const objectDiff = getObjectDiff(existingValue, req.values[i]);\n                                    const additionalChanges = updating.fire.call(ctx, objectDiff, key, existingValue, dxTrans);\n                                    if (additionalChanges) {\n                                        const requestedValue = req.values[i];\n                                        Object.keys(additionalChanges).forEach(keyPath => {\n                                            if (hasOwn(requestedValue, keyPath)) {\n                                                requestedValue[keyPath] = additionalChanges[keyPath];\n                                            }\n                                            else {\n                                                setByKeyPath(requestedValue, keyPath, additionalChanges[keyPath]);\n                                            }\n                                        });\n                                    }\n                                }\n                                return ctx;\n                            });\n                            return downTable.mutate(req).then(({ failures, results, numFailures, lastResult }) => {\n                                for (let i = 0; i < keys.length; ++i) {\n                                    const primKey = results ? results[i] : keys[i];\n                                    const ctx = contexts[i];\n                                    if (primKey == null) {\n                                        ctx.onerror && ctx.onerror(failures[i]);\n                                    }\n                                    else {\n                                        ctx.onsuccess && ctx.onsuccess(req.type === 'put' && existingValues[i] ?\n                                            req.values[i] :\n                                            primKey\n                                        );\n                                    }\n                                }\n                                return { failures, results, numFailures, lastResult };\n                            }).catch(error => {\n                                contexts.forEach(ctx => ctx.onerror && ctx.onerror(error));\n                                return Promise.reject(error);\n                            });\n                        });\n                    }\n                    function deleteRange(req) {\n                        return deleteNextChunk(req.trans, req.range, 10000);\n                    }\n                    function deleteNextChunk(trans, range, limit) {\n                        return downTable.query({ trans, values: false, query: { index: primaryKey, range }, limit })\n                            .then(({ result }) => {\n                            return addPutOrDelete({ type: 'delete', keys: result, trans }).then(res => {\n                                if (res.numFailures > 0)\n                                    return Promise.reject(res.failures[0]);\n                                if (result.length < limit) {\n                                    return { failures: [], numFailures: 0, lastResult: undefined };\n                                }\n                                else {\n                                    return deleteNextChunk(trans, { ...range, lower: result[result.length - 1], lowerOpen: true }, limit);\n                                }\n                            });\n                        });\n                    }\n                }\n            };\n            return tableMiddleware;\n        },\n    })\n};\nfunction getExistingValues(table, req, effectiveKeys) {\n    return req.type === \"add\"\n        ? Promise.resolve([])\n        : table.getMany({ trans: req.trans, keys: effectiveKeys, cache: \"immutable\" });\n}\n\nfunction getFromTransactionCache(keys, cache, clone) {\n    try {\n        if (!cache)\n            return null;\n        if (cache.keys.length < keys.length)\n            return null;\n        const result = [];\n        for (let i = 0, j = 0; i < cache.keys.length && j < keys.length; ++i) {\n            if (cmp(cache.keys[i], keys[j]) !== 0)\n                continue;\n            result.push(clone ? deepClone(cache.values[i]) : cache.values[i]);\n            ++j;\n        }\n        return result.length === keys.length ? result : null;\n    }\n    catch (_a) {\n        return null;\n    }\n}\nconst cacheExistingValuesMiddleware = {\n    stack: \"dbcore\",\n    level: -1,\n    create: (core) => {\n        return {\n            table: (tableName) => {\n                const table = core.table(tableName);\n                return {\n                    ...table,\n                    getMany: (req) => {\n                        if (!req.cache) {\n                            return table.getMany(req);\n                        }\n                        const cachedResult = getFromTransactionCache(req.keys, req.trans[\"_cache\"], req.cache === \"clone\");\n                        if (cachedResult) {\n                            return DexiePromise.resolve(cachedResult);\n                        }\n                        return table.getMany(req).then((res) => {\n                            req.trans[\"_cache\"] = {\n                                keys: req.keys,\n                                values: req.cache === \"clone\" ? deepClone(res) : res,\n                            };\n                            return res;\n                        });\n                    },\n                    mutate: (req) => {\n                        if (req.type !== \"add\")\n                            req.trans[\"_cache\"] = null;\n                        return table.mutate(req);\n                    },\n                };\n            },\n        };\n    },\n};\n\nfunction isEmptyRange(node) {\n    return !(\"from\" in node);\n}\nconst RangeSet = function (fromOrTree, to) {\n    if (this) {\n        extend(this, arguments.length ? { d: 1, from: fromOrTree, to: arguments.length > 1 ? to : fromOrTree } : { d: 0 });\n    }\n    else {\n        const rv = new RangeSet();\n        if (fromOrTree && (\"d\" in fromOrTree)) {\n            extend(rv, fromOrTree);\n        }\n        return rv;\n    }\n};\nprops(RangeSet.prototype, {\n    add(rangeSet) {\n        mergeRanges(this, rangeSet);\n        return this;\n    },\n    addKey(key) {\n        addRange(this, key, key);\n        return this;\n    },\n    addKeys(keys) {\n        keys.forEach(key => addRange(this, key, key));\n        return this;\n    },\n    [iteratorSymbol]() {\n        return getRangeSetIterator(this);\n    }\n});\nfunction addRange(target, from, to) {\n    const diff = cmp(from, to);\n    if (isNaN(diff))\n        return;\n    if (diff > 0)\n        throw RangeError();\n    if (isEmptyRange(target))\n        return extend(target, { from, to, d: 1 });\n    const left = target.l;\n    const right = target.r;\n    if (cmp(to, target.from) < 0) {\n        left\n            ? addRange(left, from, to)\n            : (target.l = { from, to, d: 1, l: null, r: null });\n        return rebalance(target);\n    }\n    if (cmp(from, target.to) > 0) {\n        right\n            ? addRange(right, from, to)\n            : (target.r = { from, to, d: 1, l: null, r: null });\n        return rebalance(target);\n    }\n    if (cmp(from, target.from) < 0) {\n        target.from = from;\n        target.l = null;\n        target.d = right ? right.d + 1 : 1;\n    }\n    if (cmp(to, target.to) > 0) {\n        target.to = to;\n        target.r = null;\n        target.d = target.l ? target.l.d + 1 : 1;\n    }\n    const rightWasCutOff = !target.r;\n    if (left && !target.l) {\n        mergeRanges(target, left);\n    }\n    if (right && rightWasCutOff) {\n        mergeRanges(target, right);\n    }\n}\nfunction mergeRanges(target, newSet) {\n    function _addRangeSet(target, { from, to, l, r }) {\n        addRange(target, from, to);\n        if (l)\n            _addRangeSet(target, l);\n        if (r)\n            _addRangeSet(target, r);\n    }\n    if (!isEmptyRange(newSet))\n        _addRangeSet(target, newSet);\n}\nfunction rangesOverlap(rangeSet1, rangeSet2) {\n    const i1 = getRangeSetIterator(rangeSet2);\n    let nextResult1 = i1.next();\n    if (nextResult1.done)\n        return false;\n    let a = nextResult1.value;\n    const i2 = getRangeSetIterator(rangeSet1);\n    let nextResult2 = i2.next(a.from);\n    let b = nextResult2.value;\n    while (!nextResult1.done && !nextResult2.done) {\n        if (cmp(b.from, a.to) <= 0 && cmp(b.to, a.from) >= 0)\n            return true;\n        cmp(a.from, b.from) < 0\n            ? (a = (nextResult1 = i1.next(b.from)).value)\n            : (b = (nextResult2 = i2.next(a.from)).value);\n    }\n    return false;\n}\nfunction getRangeSetIterator(node) {\n    let state = isEmptyRange(node) ? null : { s: 0, n: node };\n    return {\n        next(key) {\n            const keyProvided = arguments.length > 0;\n            while (state) {\n                switch (state.s) {\n                    case 0:\n                        state.s = 1;\n                        if (keyProvided) {\n                            while (state.n.l && cmp(key, state.n.from) < 0)\n                                state = { up: state, n: state.n.l, s: 1 };\n                        }\n                        else {\n                            while (state.n.l)\n                                state = { up: state, n: state.n.l, s: 1 };\n                        }\n                    case 1:\n                        state.s = 2;\n                        if (!keyProvided || cmp(key, state.n.to) <= 0)\n                            return { value: state.n, done: false };\n                    case 2:\n                        if (state.n.r) {\n                            state.s = 3;\n                            state = { up: state, n: state.n.r, s: 0 };\n                            continue;\n                        }\n                    case 3:\n                        state = state.up;\n                }\n            }\n            return { done: true };\n        },\n    };\n}\nfunction rebalance(target) {\n    var _a, _b;\n    const diff = (((_a = target.r) === null || _a === void 0 ? void 0 : _a.d) || 0) - (((_b = target.l) === null || _b === void 0 ? void 0 : _b.d) || 0);\n    const r = diff > 1 ? \"r\" : diff < -1 ? \"l\" : \"\";\n    if (r) {\n        const l = r === \"r\" ? \"l\" : \"r\";\n        const rootClone = { ...target };\n        const oldRootRight = target[r];\n        target.from = oldRootRight.from;\n        target.to = oldRootRight.to;\n        target[r] = oldRootRight[r];\n        rootClone[r] = oldRootRight[l];\n        target[l] = rootClone;\n        rootClone.d = computeDepth(rootClone);\n    }\n    target.d = computeDepth(target);\n}\nfunction computeDepth({ r, l }) {\n    return (r ? (l ? Math.max(r.d, l.d) : r.d) : l ? l.d : 0) + 1;\n}\n\nconst observabilityMiddleware = {\n    stack: \"dbcore\",\n    level: 0,\n    create: (core) => {\n        const dbName = core.schema.name;\n        const FULL_RANGE = new RangeSet(core.MIN_KEY, core.MAX_KEY);\n        return {\n            ...core,\n            table: (tableName) => {\n                const table = core.table(tableName);\n                const { schema } = table;\n                const { primaryKey } = schema;\n                const { extractKey, outbound } = primaryKey;\n                const tableClone = {\n                    ...table,\n                    mutate: (req) => {\n                        const trans = req.trans;\n                        const mutatedParts = trans.mutatedParts || (trans.mutatedParts = {});\n                        const getRangeSet = (indexName) => {\n                            const part = `idb://${dbName}/${tableName}/${indexName}`;\n                            return (mutatedParts[part] ||\n                                (mutatedParts[part] = new RangeSet()));\n                        };\n                        const pkRangeSet = getRangeSet(\"\");\n                        const delsRangeSet = getRangeSet(\":dels\");\n                        const { type } = req;\n                        let [keys, newObjs] = req.type === \"deleteRange\"\n                            ? [req.range]\n                            : req.type === \"delete\"\n                                ? [req.keys]\n                                : req.values.length < 50\n                                    ? [[], req.values]\n                                    : [];\n                        const oldCache = req.trans[\"_cache\"];\n                        return table.mutate(req).then((res) => {\n                            if (isArray(keys)) {\n                                if (type !== \"delete\")\n                                    keys = res.results;\n                                pkRangeSet.addKeys(keys);\n                                const oldObjs = getFromTransactionCache(keys, oldCache);\n                                if (!oldObjs && type !== \"add\") {\n                                    delsRangeSet.addKeys(keys);\n                                }\n                                if (oldObjs || newObjs) {\n                                    trackAffectedIndexes(getRangeSet, schema, oldObjs, newObjs);\n                                }\n                            }\n                            else if (keys) {\n                                const range = { from: keys.lower, to: keys.upper };\n                                delsRangeSet.add(range);\n                                pkRangeSet.add(range);\n                            }\n                            else {\n                                pkRangeSet.add(FULL_RANGE);\n                                delsRangeSet.add(FULL_RANGE);\n                                schema.indexes.forEach(idx => getRangeSet(idx.name).add(FULL_RANGE));\n                            }\n                            return res;\n                        });\n                    },\n                };\n                const getRange = ({ query: { index, range }, }) => {\n                    var _a, _b;\n                    return [\n                        index,\n                        new RangeSet((_a = range.lower) !== null && _a !== void 0 ? _a : core.MIN_KEY, (_b = range.upper) !== null && _b !== void 0 ? _b : core.MAX_KEY),\n                    ];\n                };\n                const readSubscribers = {\n                    get: (req) => [primaryKey, new RangeSet(req.key)],\n                    getMany: (req) => [primaryKey, new RangeSet().addKeys(req.keys)],\n                    count: getRange,\n                    query: getRange,\n                    openCursor: getRange,\n                };\n                keys(readSubscribers).forEach(method => {\n                    tableClone[method] = function (req) {\n                        const { subscr } = PSD;\n                        if (subscr) {\n                            const getRangeSet = (indexName) => {\n                                const part = `idb://${dbName}/${tableName}/${indexName}`;\n                                return (subscr[part] ||\n                                    (subscr[part] = new RangeSet()));\n                            };\n                            const pkRangeSet = getRangeSet(\"\");\n                            const delsRangeSet = getRangeSet(\":dels\");\n                            const [queriedIndex, queriedRanges] = readSubscribers[method](req);\n                            getRangeSet(queriedIndex.name || \"\").add(queriedRanges);\n                            if (!queriedIndex.isPrimaryKey) {\n                                if (method === \"count\") {\n                                    delsRangeSet.add(FULL_RANGE);\n                                }\n                                else {\n                                    const keysPromise = method === \"query\" &&\n                                        outbound &&\n                                        req.values &&\n                                        table.query({\n                                            ...req,\n                                            values: false,\n                                        });\n                                    return table[method].apply(this, arguments).then((res) => {\n                                        if (method === \"query\") {\n                                            if (outbound && req.values) {\n                                                return keysPromise.then(({ result: resultingKeys }) => {\n                                                    pkRangeSet.addKeys(resultingKeys);\n                                                    return res;\n                                                });\n                                            }\n                                            const pKeys = req.values\n                                                ? res.result.map(extractKey)\n                                                : res.result;\n                                            if (req.values) {\n                                                pkRangeSet.addKeys(pKeys);\n                                            }\n                                            else {\n                                                delsRangeSet.addKeys(pKeys);\n                                            }\n                                        }\n                                        else if (method === \"openCursor\") {\n                                            const cursor = res;\n                                            const wantValues = req.values;\n                                            return (cursor &&\n                                                Object.create(cursor, {\n                                                    key: {\n                                                        get() {\n                                                            delsRangeSet.addKey(cursor.primaryKey);\n                                                            return cursor.key;\n                                                        },\n                                                    },\n                                                    primaryKey: {\n                                                        get() {\n                                                            const pkey = cursor.primaryKey;\n                                                            delsRangeSet.addKey(pkey);\n                                                            return pkey;\n                                                        },\n                                                    },\n                                                    value: {\n                                                        get() {\n                                                            wantValues && pkRangeSet.addKey(cursor.primaryKey);\n                                                            return cursor.value;\n                                                        },\n                                                    },\n                                                }));\n                                        }\n                                        return res;\n                                    });\n                                }\n                            }\n                        }\n                        return table[method].apply(this, arguments);\n                    };\n                });\n                return tableClone;\n            },\n        };\n    },\n};\nfunction trackAffectedIndexes(getRangeSet, schema, oldObjs, newObjs) {\n    function addAffectedIndex(ix) {\n        const rangeSet = getRangeSet(ix.name || \"\");\n        function extractKey(obj) {\n            return obj != null ? ix.extractKey(obj) : null;\n        }\n        const addKeyOrKeys = (key) => ix.multiEntry && isArray(key)\n            ? key.forEach(key => rangeSet.addKey(key))\n            : rangeSet.addKey(key);\n        (oldObjs || newObjs).forEach((_, i) => {\n            const oldKey = oldObjs && extractKey(oldObjs[i]);\n            const newKey = newObjs && extractKey(newObjs[i]);\n            if (cmp(oldKey, newKey) !== 0) {\n                if (oldKey != null)\n                    addKeyOrKeys(oldKey);\n                if (newKey != null)\n                    addKeyOrKeys(newKey);\n            }\n        });\n    }\n    schema.indexes.forEach(addAffectedIndex);\n}\n\nclass Dexie$1 {\n    constructor(name, options) {\n        this._middlewares = {};\n        this.verno = 0;\n        const deps = Dexie$1.dependencies;\n        this._options = options = {\n            addons: Dexie$1.addons,\n            autoOpen: true,\n            indexedDB: deps.indexedDB,\n            IDBKeyRange: deps.IDBKeyRange,\n            ...options\n        };\n        this._deps = {\n            indexedDB: options.indexedDB,\n            IDBKeyRange: options.IDBKeyRange\n        };\n        const { addons, } = options;\n        this._dbSchema = {};\n        this._versions = [];\n        this._storeNames = [];\n        this._allTables = {};\n        this.idbdb = null;\n        this._novip = this;\n        const state = {\n            dbOpenError: null,\n            isBeingOpened: false,\n            onReadyBeingFired: null,\n            openComplete: false,\n            dbReadyResolve: nop,\n            dbReadyPromise: null,\n            cancelOpen: nop,\n            openCanceller: null,\n            autoSchema: true,\n            PR1398_maxLoop: 3\n        };\n        state.dbReadyPromise = new DexiePromise(resolve => {\n            state.dbReadyResolve = resolve;\n        });\n        state.openCanceller = new DexiePromise((_, reject) => {\n            state.cancelOpen = reject;\n        });\n        this._state = state;\n        this.name = name;\n        this.on = Events(this, \"populate\", \"blocked\", \"versionchange\", \"close\", { ready: [promisableChain, nop] });\n        this.on.ready.subscribe = override(this.on.ready.subscribe, subscribe => {\n            return (subscriber, bSticky) => {\n                Dexie$1.vip(() => {\n                    const state = this._state;\n                    if (state.openComplete) {\n                        if (!state.dbOpenError)\n                            DexiePromise.resolve().then(subscriber);\n                        if (bSticky)\n                            subscribe(subscriber);\n                    }\n                    else if (state.onReadyBeingFired) {\n                        state.onReadyBeingFired.push(subscriber);\n                        if (bSticky)\n                            subscribe(subscriber);\n                    }\n                    else {\n                        subscribe(subscriber);\n                        const db = this;\n                        if (!bSticky)\n                            subscribe(function unsubscribe() {\n                                db.on.ready.unsubscribe(subscriber);\n                                db.on.ready.unsubscribe(unsubscribe);\n                            });\n                    }\n                });\n            };\n        });\n        this.Collection = createCollectionConstructor(this);\n        this.Table = createTableConstructor(this);\n        this.Transaction = createTransactionConstructor(this);\n        this.Version = createVersionConstructor(this);\n        this.WhereClause = createWhereClauseConstructor(this);\n        this.on(\"versionchange\", ev => {\n            if (ev.newVersion > 0)\n                console.warn(`Another connection wants to upgrade database '${this.name}'. Closing db now to resume the upgrade.`);\n            else\n                console.warn(`Another connection wants to delete database '${this.name}'. Closing db now to resume the delete request.`);\n            this.close();\n        });\n        this.on(\"blocked\", ev => {\n            if (!ev.newVersion || ev.newVersion < ev.oldVersion)\n                console.warn(`Dexie.delete('${this.name}') was blocked`);\n            else\n                console.warn(`Upgrade '${this.name}' blocked by other connection holding version ${ev.oldVersion / 10}`);\n        });\n        this._maxKey = getMaxKey(options.IDBKeyRange);\n        this._createTransaction = (mode, storeNames, dbschema, parentTransaction) => new this.Transaction(mode, storeNames, dbschema, this._options.chromeTransactionDurability, parentTransaction);\n        this._fireOnBlocked = ev => {\n            this.on(\"blocked\").fire(ev);\n            connections\n                .filter(c => c.name === this.name && c !== this && !c._state.vcFired)\n                .map(c => c.on(\"versionchange\").fire(ev));\n        };\n        this.use(virtualIndexMiddleware);\n        this.use(hooksMiddleware);\n        this.use(observabilityMiddleware);\n        this.use(cacheExistingValuesMiddleware);\n        this.vip = Object.create(this, { _vip: { value: true } });\n        addons.forEach(addon => addon(this));\n    }\n    version(versionNumber) {\n        if (isNaN(versionNumber) || versionNumber < 0.1)\n            throw new exceptions.Type(`Given version is not a positive number`);\n        versionNumber = Math.round(versionNumber * 10) / 10;\n        if (this.idbdb || this._state.isBeingOpened)\n            throw new exceptions.Schema(\"Cannot add version when database is open\");\n        this.verno = Math.max(this.verno, versionNumber);\n        const versions = this._versions;\n        var versionInstance = versions.filter(v => v._cfg.version === versionNumber)[0];\n        if (versionInstance)\n            return versionInstance;\n        versionInstance = new this.Version(versionNumber);\n        versions.push(versionInstance);\n        versions.sort(lowerVersionFirst);\n        versionInstance.stores({});\n        this._state.autoSchema = false;\n        return versionInstance;\n    }\n    _whenReady(fn) {\n        return (this.idbdb && (this._state.openComplete || PSD.letThrough || this._vip)) ? fn() : new DexiePromise((resolve, reject) => {\n            if (this._state.openComplete) {\n                return reject(new exceptions.DatabaseClosed(this._state.dbOpenError));\n            }\n            if (!this._state.isBeingOpened) {\n                if (!this._options.autoOpen) {\n                    reject(new exceptions.DatabaseClosed());\n                    return;\n                }\n                this.open().catch(nop);\n            }\n            this._state.dbReadyPromise.then(resolve, reject);\n        }).then(fn);\n    }\n    use({ stack, create, level, name }) {\n        if (name)\n            this.unuse({ stack, name });\n        const middlewares = this._middlewares[stack] || (this._middlewares[stack] = []);\n        middlewares.push({ stack, create, level: level == null ? 10 : level, name });\n        middlewares.sort((a, b) => a.level - b.level);\n        return this;\n    }\n    unuse({ stack, name, create }) {\n        if (stack && this._middlewares[stack]) {\n            this._middlewares[stack] = this._middlewares[stack].filter(mw => create ? mw.create !== create :\n                name ? mw.name !== name :\n                    false);\n        }\n        return this;\n    }\n    open() {\n        return dexieOpen(this);\n    }\n    _close() {\n        const state = this._state;\n        const idx = connections.indexOf(this);\n        if (idx >= 0)\n            connections.splice(idx, 1);\n        if (this.idbdb) {\n            try {\n                this.idbdb.close();\n            }\n            catch (e) { }\n            this._novip.idbdb = null;\n        }\n        state.dbReadyPromise = new DexiePromise(resolve => {\n            state.dbReadyResolve = resolve;\n        });\n        state.openCanceller = new DexiePromise((_, reject) => {\n            state.cancelOpen = reject;\n        });\n    }\n    close() {\n        this._close();\n        const state = this._state;\n        this._options.autoOpen = false;\n        state.dbOpenError = new exceptions.DatabaseClosed();\n        if (state.isBeingOpened)\n            state.cancelOpen(state.dbOpenError);\n    }\n    delete() {\n        const hasArguments = arguments.length > 0;\n        const state = this._state;\n        return new DexiePromise((resolve, reject) => {\n            const doDelete = () => {\n                this.close();\n                var req = this._deps.indexedDB.deleteDatabase(this.name);\n                req.onsuccess = wrap(() => {\n                    _onDatabaseDeleted(this._deps, this.name);\n                    resolve();\n                });\n                req.onerror = eventRejectHandler(reject);\n                req.onblocked = this._fireOnBlocked;\n            };\n            if (hasArguments)\n                throw new exceptions.InvalidArgument(\"Arguments not allowed in db.delete()\");\n            if (state.isBeingOpened) {\n                state.dbReadyPromise.then(doDelete);\n            }\n            else {\n                doDelete();\n            }\n        });\n    }\n    backendDB() {\n        return this.idbdb;\n    }\n    isOpen() {\n        return this.idbdb !== null;\n    }\n    hasBeenClosed() {\n        const dbOpenError = this._state.dbOpenError;\n        return dbOpenError && (dbOpenError.name === 'DatabaseClosed');\n    }\n    hasFailed() {\n        return this._state.dbOpenError !== null;\n    }\n    dynamicallyOpened() {\n        return this._state.autoSchema;\n    }\n    get tables() {\n        return keys(this._allTables).map(name => this._allTables[name]);\n    }\n    transaction() {\n        const args = extractTransactionArgs.apply(this, arguments);\n        return this._transaction.apply(this, args);\n    }\n    _transaction(mode, tables, scopeFunc) {\n        let parentTransaction = PSD.trans;\n        if (!parentTransaction || parentTransaction.db !== this || mode.indexOf('!') !== -1)\n            parentTransaction = null;\n        const onlyIfCompatible = mode.indexOf('?') !== -1;\n        mode = mode.replace('!', '').replace('?', '');\n        let idbMode, storeNames;\n        try {\n            storeNames = tables.map(table => {\n                var storeName = table instanceof this.Table ? table.name : table;\n                if (typeof storeName !== 'string')\n                    throw new TypeError(\"Invalid table argument to Dexie.transaction(). Only Table or String are allowed\");\n                return storeName;\n            });\n            if (mode == \"r\" || mode === READONLY)\n                idbMode = READONLY;\n            else if (mode == \"rw\" || mode == READWRITE)\n                idbMode = READWRITE;\n            else\n                throw new exceptions.InvalidArgument(\"Invalid transaction mode: \" + mode);\n            if (parentTransaction) {\n                if (parentTransaction.mode === READONLY && idbMode === READWRITE) {\n                    if (onlyIfCompatible) {\n                        parentTransaction = null;\n                    }\n                    else\n                        throw new exceptions.SubTransaction(\"Cannot enter a sub-transaction with READWRITE mode when parent transaction is READONLY\");\n                }\n                if (parentTransaction) {\n                    storeNames.forEach(storeName => {\n                        if (parentTransaction && parentTransaction.storeNames.indexOf(storeName) === -1) {\n                            if (onlyIfCompatible) {\n                                parentTransaction = null;\n                            }\n                            else\n                                throw new exceptions.SubTransaction(\"Table \" + storeName +\n                                    \" not included in parent transaction.\");\n                        }\n                    });\n                }\n                if (onlyIfCompatible && parentTransaction && !parentTransaction.active) {\n                    parentTransaction = null;\n                }\n            }\n        }\n        catch (e) {\n            return parentTransaction ?\n                parentTransaction._promise(null, (_, reject) => { reject(e); }) :\n                rejection(e);\n        }\n        const enterTransaction = enterTransactionScope.bind(null, this, idbMode, storeNames, parentTransaction, scopeFunc);\n        return (parentTransaction ?\n            parentTransaction._promise(idbMode, enterTransaction, \"lock\") :\n            PSD.trans ?\n                usePSD(PSD.transless, () => this._whenReady(enterTransaction)) :\n                this._whenReady(enterTransaction));\n    }\n    table(tableName) {\n        if (!hasOwn(this._allTables, tableName)) {\n            throw new exceptions.InvalidTable(`Table ${tableName} does not exist`);\n        }\n        return this._allTables[tableName];\n    }\n}\n\nconst symbolObservable = typeof Symbol !== \"undefined\" && \"observable\" in Symbol\n    ? Symbol.observable\n    : \"@@observable\";\nclass Observable {\n    constructor(subscribe) {\n        this._subscribe = subscribe;\n    }\n    subscribe(x, error, complete) {\n        return this._subscribe(!x || typeof x === \"function\" ? { next: x, error, complete } : x);\n    }\n    [symbolObservable]() {\n        return this;\n    }\n}\n\nfunction extendObservabilitySet(target, newSet) {\n    keys(newSet).forEach(part => {\n        const rangeSet = target[part] || (target[part] = new RangeSet());\n        mergeRanges(rangeSet, newSet[part]);\n    });\n    return target;\n}\n\nfunction liveQuery(querier) {\n    let hasValue = false;\n    let currentValue = undefined;\n    const observable = new Observable((observer) => {\n        const scopeFuncIsAsync = isAsyncFunction(querier);\n        function execute(subscr) {\n            if (scopeFuncIsAsync) {\n                incrementExpectedAwaits();\n            }\n            const exec = () => newScope(querier, { subscr, trans: null });\n            const rv = PSD.trans\n                ?\n                    usePSD(PSD.transless, exec)\n                : exec();\n            if (scopeFuncIsAsync) {\n                rv.then(decrementExpectedAwaits, decrementExpectedAwaits);\n            }\n            return rv;\n        }\n        let closed = false;\n        let accumMuts = {};\n        let currentObs = {};\n        const subscription = {\n            get closed() {\n                return closed;\n            },\n            unsubscribe: () => {\n                closed = true;\n                globalEvents.storagemutated.unsubscribe(mutationListener);\n            },\n        };\n        observer.start && observer.start(subscription);\n        let querying = false, startedListening = false;\n        function shouldNotify() {\n            return keys(currentObs).some((key) => accumMuts[key] && rangesOverlap(accumMuts[key], currentObs[key]));\n        }\n        const mutationListener = (parts) => {\n            extendObservabilitySet(accumMuts, parts);\n            if (shouldNotify()) {\n                doQuery();\n            }\n        };\n        const doQuery = () => {\n            if (querying || closed)\n                return;\n            accumMuts = {};\n            const subscr = {};\n            const ret = execute(subscr);\n            if (!startedListening) {\n                globalEvents(DEXIE_STORAGE_MUTATED_EVENT_NAME, mutationListener);\n                startedListening = true;\n            }\n            querying = true;\n            Promise.resolve(ret).then((result) => {\n                hasValue = true;\n                currentValue = result;\n                querying = false;\n                if (closed)\n                    return;\n                if (shouldNotify()) {\n                    doQuery();\n                }\n                else {\n                    accumMuts = {};\n                    currentObs = subscr;\n                    observer.next && observer.next(result);\n                }\n            }, (err) => {\n                querying = false;\n                hasValue = false;\n                observer.error && observer.error(err);\n                subscription.unsubscribe();\n            });\n        };\n        doQuery();\n        return subscription;\n    });\n    observable.hasValue = () => hasValue;\n    observable.getValue = () => currentValue;\n    return observable;\n}\n\nlet domDeps;\ntry {\n    domDeps = {\n        indexedDB: _global.indexedDB || _global.mozIndexedDB || _global.webkitIndexedDB || _global.msIndexedDB,\n        IDBKeyRange: _global.IDBKeyRange || _global.webkitIDBKeyRange\n    };\n}\ncatch (e) {\n    domDeps = { indexedDB: null, IDBKeyRange: null };\n}\n\nconst Dexie = Dexie$1;\nprops(Dexie, {\n    ...fullNameExceptions,\n    delete(databaseName) {\n        const db = new Dexie(databaseName, { addons: [] });\n        return db.delete();\n    },\n    exists(name) {\n        return new Dexie(name, { addons: [] }).open().then(db => {\n            db.close();\n            return true;\n        }).catch('NoSuchDatabaseError', () => false);\n    },\n    getDatabaseNames(cb) {\n        try {\n            return getDatabaseNames(Dexie.dependencies).then(cb);\n        }\n        catch (_a) {\n            return rejection(new exceptions.MissingAPI());\n        }\n    },\n    defineClass() {\n        function Class(content) {\n            extend(this, content);\n        }\n        return Class;\n    },\n    ignoreTransaction(scopeFunc) {\n        return PSD.trans ?\n            usePSD(PSD.transless, scopeFunc) :\n            scopeFunc();\n    },\n    vip,\n    async: function (generatorFn) {\n        return function () {\n            try {\n                var rv = awaitIterator(generatorFn.apply(this, arguments));\n                if (!rv || typeof rv.then !== 'function')\n                    return DexiePromise.resolve(rv);\n                return rv;\n            }\n            catch (e) {\n                return rejection(e);\n            }\n        };\n    },\n    spawn: function (generatorFn, args, thiz) {\n        try {\n            var rv = awaitIterator(generatorFn.apply(thiz, args || []));\n            if (!rv || typeof rv.then !== 'function')\n                return DexiePromise.resolve(rv);\n            return rv;\n        }\n        catch (e) {\n            return rejection(e);\n        }\n    },\n    currentTransaction: {\n        get: () => PSD.trans || null\n    },\n    waitFor: function (promiseOrFunction, optionalTimeout) {\n        const promise = DexiePromise.resolve(typeof promiseOrFunction === 'function' ?\n            Dexie.ignoreTransaction(promiseOrFunction) :\n            promiseOrFunction)\n            .timeout(optionalTimeout || 60000);\n        return PSD.trans ?\n            PSD.trans.waitFor(promise) :\n            promise;\n    },\n    Promise: DexiePromise,\n    debug: {\n        get: () => debug,\n        set: value => {\n            setDebug(value, value === 'dexie' ? () => true : dexieStackFrameFilter);\n        }\n    },\n    derive: derive,\n    extend: extend,\n    props: props,\n    override: override,\n    Events: Events,\n    on: globalEvents,\n    liveQuery,\n    extendObservabilitySet,\n    getByKeyPath: getByKeyPath,\n    setByKeyPath: setByKeyPath,\n    delByKeyPath: delByKeyPath,\n    shallowClone: shallowClone,\n    deepClone: deepClone,\n    getObjectDiff: getObjectDiff,\n    cmp,\n    asap: asap$1,\n    minKey: minKey,\n    addons: [],\n    connections: connections,\n    errnames: errnames,\n    dependencies: domDeps,\n    semVer: DEXIE_VERSION,\n    version: DEXIE_VERSION.split('.')\n        .map(n => parseInt(n))\n        .reduce((p, c, i) => p + (c / Math.pow(10, i * 2))),\n});\nDexie.maxKey = getMaxKey(Dexie.dependencies.IDBKeyRange);\n\nif (typeof dispatchEvent !== 'undefined' && typeof addEventListener !== 'undefined') {\n    globalEvents(DEXIE_STORAGE_MUTATED_EVENT_NAME, updatedParts => {\n        if (!propagatingLocally) {\n            let event;\n            if (isIEOrEdge) {\n                event = document.createEvent('CustomEvent');\n                event.initCustomEvent(STORAGE_MUTATED_DOM_EVENT_NAME, true, true, updatedParts);\n            }\n            else {\n                event = new CustomEvent(STORAGE_MUTATED_DOM_EVENT_NAME, {\n                    detail: updatedParts\n                });\n            }\n            propagatingLocally = true;\n            dispatchEvent(event);\n            propagatingLocally = false;\n        }\n    });\n    addEventListener(STORAGE_MUTATED_DOM_EVENT_NAME, ({ detail }) => {\n        if (!propagatingLocally) {\n            propagateLocally(detail);\n        }\n    });\n}\nfunction propagateLocally(updateParts) {\n    let wasMe = propagatingLocally;\n    try {\n        propagatingLocally = true;\n        globalEvents.storagemutated.fire(updateParts);\n    }\n    finally {\n        propagatingLocally = wasMe;\n    }\n}\nlet propagatingLocally = false;\n\nif (typeof BroadcastChannel !== 'undefined') {\n    const bc = new BroadcastChannel(STORAGE_MUTATED_DOM_EVENT_NAME);\n    if (typeof bc.unref === 'function') {\n        bc.unref();\n    }\n    globalEvents(DEXIE_STORAGE_MUTATED_EVENT_NAME, (changedParts) => {\n        if (!propagatingLocally) {\n            bc.postMessage(changedParts);\n        }\n    });\n    bc.onmessage = (ev) => {\n        if (ev.data)\n            propagateLocally(ev.data);\n    };\n}\nelse if (typeof self !== 'undefined' && typeof navigator !== 'undefined') {\n    globalEvents(DEXIE_STORAGE_MUTATED_EVENT_NAME, (changedParts) => {\n        try {\n            if (!propagatingLocally) {\n                if (typeof localStorage !== 'undefined') {\n                    localStorage.setItem(STORAGE_MUTATED_DOM_EVENT_NAME, JSON.stringify({\n                        trig: Math.random(),\n                        changedParts,\n                    }));\n                }\n                if (typeof self['clients'] === 'object') {\n                    [...self['clients'].matchAll({ includeUncontrolled: true })].forEach((client) => client.postMessage({\n                        type: STORAGE_MUTATED_DOM_EVENT_NAME,\n                        changedParts,\n                    }));\n                }\n            }\n        }\n        catch (_a) { }\n    });\n    if (typeof addEventListener !== 'undefined') {\n        addEventListener('storage', (ev) => {\n            if (ev.key === STORAGE_MUTATED_DOM_EVENT_NAME) {\n                const data = JSON.parse(ev.newValue);\n                if (data)\n                    propagateLocally(data.changedParts);\n            }\n        });\n    }\n    const swContainer = self.document && navigator.serviceWorker;\n    if (swContainer) {\n        swContainer.addEventListener('message', propagateMessageLocally);\n    }\n}\nfunction propagateMessageLocally({ data }) {\n    if (data && data.type === STORAGE_MUTATED_DOM_EVENT_NAME) {\n        propagateLocally(data.changedParts);\n    }\n}\n\nDexiePromise.rejectionMapper = mapError;\nsetDebug(debug, dexieStackFrameFilter);\n\nexport { Dexie$1 as Dexie, RangeSet, Dexie$1 as default, liveQuery, mergeRanges, rangesOverlap };\n//# sourceMappingURL=dexie.mjs.map\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}