{"ast":null,"code":"// src/link.ts\nimport { Mark, markPasteRule, mergeAttributes } from \"@tiptap/core\";\nimport { find as find2, registerCustomProtocol, reset } from \"linkifyjs\";\n\n// src/helpers/autolink.ts\nimport { combineTransactionSteps, findChildrenInRange, getChangedRanges, getMarksBetween } from \"@tiptap/core\";\nimport { Plugin, PluginKey } from \"@tiptap/pm/state\";\nimport { tokenize } from \"linkifyjs\";\n\n// src/helpers/whitespace.ts\nvar UNICODE_WHITESPACE_PATTERN = \"[\\0- \\xA0\\u1680\\u180E\\u2000-\\u2029\\u205F\\u3000]\";\nvar UNICODE_WHITESPACE_REGEX = new RegExp(UNICODE_WHITESPACE_PATTERN);\nvar UNICODE_WHITESPACE_REGEX_END = new RegExp(`${UNICODE_WHITESPACE_PATTERN}$`);\nvar UNICODE_WHITESPACE_REGEX_GLOBAL = new RegExp(UNICODE_WHITESPACE_PATTERN, \"g\");\n\n// src/helpers/autolink.ts\nfunction isValidLinkStructure(tokens) {\n  if (tokens.length === 1) {\n    return tokens[0].isLink;\n  }\n  if (tokens.length === 3 && tokens[1].isLink) {\n    return [\"()\", \"[]\"].includes(tokens[0].value + tokens[2].value);\n  }\n  return false;\n}\nfunction autolink(options) {\n  return new Plugin({\n    key: new PluginKey(\"autolink\"),\n    appendTransaction: (transactions, oldState, newState) => {\n      const docChanges = transactions.some(transaction => transaction.docChanged) && !oldState.doc.eq(newState.doc);\n      const preventAutolink = transactions.some(transaction => transaction.getMeta(\"preventAutolink\"));\n      if (!docChanges || preventAutolink) {\n        return;\n      }\n      const {\n        tr\n      } = newState;\n      const transform = combineTransactionSteps(oldState.doc, [...transactions]);\n      const changes = getChangedRanges(transform);\n      changes.forEach(({\n        newRange\n      }) => {\n        const nodesInChangedRanges = findChildrenInRange(newState.doc, newRange, node => node.isTextblock);\n        let textBlock;\n        let textBeforeWhitespace;\n        if (nodesInChangedRanges.length > 1) {\n          textBlock = nodesInChangedRanges[0];\n          textBeforeWhitespace = newState.doc.textBetween(textBlock.pos, textBlock.pos + textBlock.node.nodeSize, void 0, \" \");\n        } else if (nodesInChangedRanges.length) {\n          const endText = newState.doc.textBetween(newRange.from, newRange.to, \" \", \" \");\n          if (!UNICODE_WHITESPACE_REGEX_END.test(endText)) {\n            return;\n          }\n          textBlock = nodesInChangedRanges[0];\n          textBeforeWhitespace = newState.doc.textBetween(textBlock.pos, newRange.to, void 0, \" \");\n        }\n        if (textBlock && textBeforeWhitespace) {\n          const wordsBeforeWhitespace = textBeforeWhitespace.split(UNICODE_WHITESPACE_REGEX).filter(Boolean);\n          if (wordsBeforeWhitespace.length <= 0) {\n            return false;\n          }\n          const lastWordBeforeSpace = wordsBeforeWhitespace[wordsBeforeWhitespace.length - 1];\n          const lastWordAndBlockOffset = textBlock.pos + textBeforeWhitespace.lastIndexOf(lastWordBeforeSpace);\n          if (!lastWordBeforeSpace) {\n            return false;\n          }\n          const linksBeforeSpace = tokenize(lastWordBeforeSpace).map(t => t.toObject(options.defaultProtocol));\n          if (!isValidLinkStructure(linksBeforeSpace)) {\n            return false;\n          }\n          linksBeforeSpace.filter(link => link.isLink).map(link => ({\n            ...link,\n            from: lastWordAndBlockOffset + link.start + 1,\n            to: lastWordAndBlockOffset + link.end + 1\n          })).filter(link => {\n            if (!newState.schema.marks.code) {\n              return true;\n            }\n            return !newState.doc.rangeHasMark(link.from, link.to, newState.schema.marks.code);\n          }).filter(link => options.validate(link.value)).filter(link => options.shouldAutoLink(link.value)).forEach(link => {\n            if (getMarksBetween(link.from, link.to, newState.doc).some(item => item.mark.type === options.type)) {\n              return;\n            }\n            tr.addMark(link.from, link.to, options.type.create({\n              href: link.href\n            }));\n          });\n        }\n      });\n      if (!tr.steps.length) {\n        return;\n      }\n      return tr;\n    }\n  });\n}\n\n// src/helpers/clickHandler.ts\nimport { getAttributes } from \"@tiptap/core\";\nimport { Plugin as Plugin2, PluginKey as PluginKey2 } from \"@tiptap/pm/state\";\nfunction clickHandler(options) {\n  return new Plugin2({\n    key: new PluginKey2(\"handleClickLink\"),\n    props: {\n      handleClick: (view, pos, event) => {\n        var _a, _b;\n        if (event.button !== 0) {\n          return false;\n        }\n        if (!view.editable) {\n          return false;\n        }\n        let link = null;\n        if (event.target instanceof HTMLAnchorElement) {\n          link = event.target;\n        } else {\n          let a = event.target;\n          const els = [];\n          while (a.nodeName !== \"DIV\") {\n            els.push(a);\n            a = a.parentNode;\n          }\n          link = els.find(value => value.nodeName === \"A\");\n        }\n        if (!link) {\n          return false;\n        }\n        const attrs = getAttributes(view.state, options.type.name);\n        const href = (_a = link == null ? void 0 : link.href) != null ? _a : attrs.href;\n        const target = (_b = link == null ? void 0 : link.target) != null ? _b : attrs.target;\n        if (options.enableClickSelection) {\n          options.editor.commands.extendMarkRange(options.type.name);\n        }\n        if (link && href) {\n          window.open(href, target);\n          return true;\n        }\n        return false;\n      }\n    }\n  });\n}\n\n// src/helpers/pasteHandler.ts\nimport { Plugin as Plugin3, PluginKey as PluginKey3 } from \"@tiptap/pm/state\";\nimport { find } from \"linkifyjs\";\nfunction pasteHandler(options) {\n  return new Plugin3({\n    key: new PluginKey3(\"handlePasteLink\"),\n    props: {\n      handlePaste: (view, event, slice) => {\n        const {\n          state\n        } = view;\n        const {\n          selection\n        } = state;\n        const {\n          empty\n        } = selection;\n        if (empty) {\n          return false;\n        }\n        let textContent = \"\";\n        slice.content.forEach(node => {\n          textContent += node.textContent;\n        });\n        const link = find(textContent, {\n          defaultProtocol: options.defaultProtocol\n        }).find(item => item.isLink && item.value === textContent);\n        if (!textContent || !link) {\n          return false;\n        }\n        return options.editor.commands.setMark(options.type, {\n          href: link.href\n        });\n      }\n    }\n  });\n}\n\n// src/link.ts\nvar pasteRegex = /https?:\\/\\/(?:www\\.)?[-a-zA-Z0-9@:%._+~#=]{1,256}\\.[a-zA-Z]{2,}\\b(?:[-a-zA-Z0-9@:%._+~#=?!&/]*)(?:[-a-zA-Z0-9@:%._+~#=?!&/]*)/gi;\nfunction isAllowedUri(uri, protocols) {\n  const allowedProtocols = [\"http\", \"https\", \"ftp\", \"ftps\", \"mailto\", \"tel\", \"callto\", \"sms\", \"cid\", \"xmpp\"];\n  if (protocols) {\n    protocols.forEach(protocol => {\n      const nextProtocol = typeof protocol === \"string\" ? protocol : protocol.scheme;\n      if (nextProtocol) {\n        allowedProtocols.push(nextProtocol);\n      }\n    });\n  }\n  return !uri || uri.replace(UNICODE_WHITESPACE_REGEX_GLOBAL, \"\").match(new RegExp(\n  // eslint-disable-next-line no-useless-escape\n  `^(?:(?:${allowedProtocols.join(\"|\")}):|[^a-z]|[a-z0-9+.-]+(?:[^a-z+.-:]|$))`, \"i\"));\n}\nvar Link = Mark.create({\n  name: \"link\",\n  priority: 1e3,\n  keepOnSplit: false,\n  exitable: true,\n  onCreate() {\n    if (this.options.validate && !this.options.shouldAutoLink) {\n      this.options.shouldAutoLink = this.options.validate;\n      console.warn(\"The `validate` option is deprecated. Rename to the `shouldAutoLink` option instead.\");\n    }\n    this.options.protocols.forEach(protocol => {\n      if (typeof protocol === \"string\") {\n        registerCustomProtocol(protocol);\n        return;\n      }\n      registerCustomProtocol(protocol.scheme, protocol.optionalSlashes);\n    });\n  },\n  onDestroy() {\n    reset();\n  },\n  inclusive() {\n    return this.options.autolink;\n  },\n  addOptions() {\n    return {\n      openOnClick: true,\n      enableClickSelection: false,\n      linkOnPaste: true,\n      autolink: true,\n      protocols: [],\n      defaultProtocol: \"http\",\n      HTMLAttributes: {\n        target: \"_blank\",\n        rel: \"noopener noreferrer nofollow\",\n        class: null\n      },\n      isAllowedUri: (url, ctx) => !!isAllowedUri(url, ctx.protocols),\n      validate: url => !!url,\n      shouldAutoLink: url => !!url\n    };\n  },\n  addAttributes() {\n    return {\n      href: {\n        default: null,\n        parseHTML(element) {\n          return element.getAttribute(\"href\");\n        }\n      },\n      target: {\n        default: this.options.HTMLAttributes.target\n      },\n      rel: {\n        default: this.options.HTMLAttributes.rel\n      },\n      class: {\n        default: this.options.HTMLAttributes.class\n      }\n    };\n  },\n  parseHTML() {\n    return [{\n      tag: \"a[href]\",\n      getAttrs: dom => {\n        const href = dom.getAttribute(\"href\");\n        if (!href || !this.options.isAllowedUri(href, {\n          defaultValidate: url => !!isAllowedUri(url, this.options.protocols),\n          protocols: this.options.protocols,\n          defaultProtocol: this.options.defaultProtocol\n        })) {\n          return false;\n        }\n        return null;\n      }\n    }];\n  },\n  renderHTML({\n    HTMLAttributes\n  }) {\n    if (!this.options.isAllowedUri(HTMLAttributes.href, {\n      defaultValidate: href => !!isAllowedUri(href, this.options.protocols),\n      protocols: this.options.protocols,\n      defaultProtocol: this.options.defaultProtocol\n    })) {\n      return [\"a\", mergeAttributes(this.options.HTMLAttributes, {\n        ...HTMLAttributes,\n        href: \"\"\n      }), 0];\n    }\n    return [\"a\", mergeAttributes(this.options.HTMLAttributes, HTMLAttributes), 0];\n  },\n  addCommands() {\n    return {\n      setLink: attributes => ({\n        chain\n      }) => {\n        const {\n          href\n        } = attributes;\n        if (!this.options.isAllowedUri(href, {\n          defaultValidate: url => !!isAllowedUri(url, this.options.protocols),\n          protocols: this.options.protocols,\n          defaultProtocol: this.options.defaultProtocol\n        })) {\n          return false;\n        }\n        return chain().setMark(this.name, attributes).setMeta(\"preventAutolink\", true).run();\n      },\n      toggleLink: attributes => ({\n        chain\n      }) => {\n        const {\n          href\n        } = attributes || {};\n        if (href && !this.options.isAllowedUri(href, {\n          defaultValidate: url => !!isAllowedUri(url, this.options.protocols),\n          protocols: this.options.protocols,\n          defaultProtocol: this.options.defaultProtocol\n        })) {\n          return false;\n        }\n        return chain().toggleMark(this.name, attributes, {\n          extendEmptyMarkRange: true\n        }).setMeta(\"preventAutolink\", true).run();\n      },\n      unsetLink: () => ({\n        chain\n      }) => {\n        return chain().unsetMark(this.name, {\n          extendEmptyMarkRange: true\n        }).setMeta(\"preventAutolink\", true).run();\n      }\n    };\n  },\n  addPasteRules() {\n    return [markPasteRule({\n      find: text => {\n        const foundLinks = [];\n        if (text) {\n          const {\n            protocols,\n            defaultProtocol\n          } = this.options;\n          const links = find2(text).filter(item => item.isLink && this.options.isAllowedUri(item.value, {\n            defaultValidate: href => !!isAllowedUri(href, protocols),\n            protocols,\n            defaultProtocol\n          }));\n          if (links.length) {\n            links.forEach(link => foundLinks.push({\n              text: link.value,\n              data: {\n                href: link.href\n              },\n              index: link.start\n            }));\n          }\n        }\n        return foundLinks;\n      },\n      type: this.type,\n      getAttributes: match => {\n        var _a;\n        return {\n          href: (_a = match.data) == null ? void 0 : _a.href\n        };\n      }\n    })];\n  },\n  addProseMirrorPlugins() {\n    const plugins = [];\n    const {\n      protocols,\n      defaultProtocol\n    } = this.options;\n    if (this.options.autolink) {\n      plugins.push(autolink({\n        type: this.type,\n        defaultProtocol: this.options.defaultProtocol,\n        validate: url => this.options.isAllowedUri(url, {\n          defaultValidate: href => !!isAllowedUri(href, protocols),\n          protocols,\n          defaultProtocol\n        }),\n        shouldAutoLink: this.options.shouldAutoLink\n      }));\n    }\n    if (this.options.openOnClick === true) {\n      plugins.push(clickHandler({\n        type: this.type,\n        editor: this.editor,\n        enableClickSelection: this.options.enableClickSelection\n      }));\n    }\n    if (this.options.linkOnPaste) {\n      plugins.push(pasteHandler({\n        editor: this.editor,\n        defaultProtocol: this.options.defaultProtocol,\n        type: this.type\n      }));\n    }\n    return plugins;\n  }\n});\n\n// src/index.ts\nvar index_default = Link;\nexport { Link, index_default as default, isAllowedUri, pasteRegex };","map":{"version":3,"names":["Mark","markPasteRule","mergeAttributes","find","find2","registerCustomProtocol","reset","combineTransactionSteps","findChildrenInRange","getChangedRanges","getMarksBetween","Plugin","PluginKey","tokenize","UNICODE_WHITESPACE_PATTERN","UNICODE_WHITESPACE_REGEX","RegExp","UNICODE_WHITESPACE_REGEX_END","UNICODE_WHITESPACE_REGEX_GLOBAL","isValidLinkStructure","tokens","length","isLink","includes","value","autolink","options","key","appendTransaction","transactions","oldState","newState","docChanges","some","transaction","docChanged","doc","eq","preventAutolink","getMeta","tr","transform","changes","forEach","newRange","nodesInChangedRanges","node","isTextblock","textBlock","textBeforeWhitespace","textBetween","pos","nodeSize","endText","from","to","test","wordsBeforeWhitespace","split","filter","Boolean","lastWordBeforeSpace","lastWordAndBlockOffset","lastIndexOf","linksBeforeSpace","map","t","toObject","defaultProtocol","link","start","end","schema","marks","code","rangeHasMark","validate","shouldAutoLink","item","mark","type","addMark","create","href","steps","getAttributes","Plugin2","PluginKey2","clickHandler","props","handleClick","view","event","_a","_b","button","editable","target","HTMLAnchorElement","a","els","nodeName","push","parentNode","attrs","state","name","enableClickSelection","editor","commands","extendMarkRange","window","open","Plugin3","PluginKey3","pasteHandler","handlePaste","slice","selection","empty","textContent","content","setMark","pasteRegex","isAllowedUri","uri","protocols","allowedProtocols","protocol","nextProtocol","scheme","replace","match","join","Link","priority","keepOnSplit","exitable","onCreate","console","warn","optionalSlashes","onDestroy","inclusive","addOptions","openOnClick","linkOnPaste","HTMLAttributes","rel","class","url","ctx","addAttributes","default","parseHTML","element","getAttribute","tag","getAttrs","dom","defaultValidate","renderHTML","addCommands","setLink","attributes","chain","setMeta","run","toggleLink","toggleMark","extendEmptyMarkRange","unsetLink","unsetMark","addPasteRules","text","foundLinks","links","data","index","addProseMirrorPlugins","plugins","index_default"],"sources":["D:\\diarry me\\node_modules\\@tiptap\\extension-link\\src\\link.ts","D:\\diarry me\\node_modules\\@tiptap\\extension-link\\src\\helpers\\autolink.ts","D:\\diarry me\\node_modules\\@tiptap\\extension-link\\src\\helpers\\whitespace.ts","D:\\diarry me\\node_modules\\@tiptap\\extension-link\\src\\helpers\\clickHandler.ts","D:\\diarry me\\node_modules\\@tiptap\\extension-link\\src\\helpers\\pasteHandler.ts","D:\\diarry me\\node_modules\\@tiptap\\extension-link\\src\\index.ts"],"sourcesContent":["import type { PasteRuleMatch } from '@tiptap/core'\nimport { Mark, markPasteRule, mergeAttributes } from '@tiptap/core'\nimport type { Plugin } from '@tiptap/pm/state'\nimport { find, registerCustomProtocol, reset } from 'linkifyjs'\n\nimport { autolink } from './helpers/autolink.js'\nimport { clickHandler } from './helpers/clickHandler.js'\nimport { pasteHandler } from './helpers/pasteHandler.js'\nimport { UNICODE_WHITESPACE_REGEX_GLOBAL } from './helpers/whitespace.js'\n\nexport interface LinkProtocolOptions {\n  /**\n   * The protocol scheme to be registered.\n   * @default '''\n   * @example 'ftp'\n   * @example 'git'\n   */\n  scheme: string\n\n  /**\n   * If enabled, it allows optional slashes after the protocol.\n   * @default false\n   * @example true\n   */\n  optionalSlashes?: boolean\n}\n\nexport const pasteRegex =\n  /https?:\\/\\/(?:www\\.)?[-a-zA-Z0-9@:%._+~#=]{1,256}\\.[a-zA-Z]{2,}\\b(?:[-a-zA-Z0-9@:%._+~#=?!&/]*)(?:[-a-zA-Z0-9@:%._+~#=?!&/]*)/gi\n\n/**\n * @deprecated The default behavior is now to open links when the editor is not editable.\n */\ntype DeprecatedOpenWhenNotEditable = 'whenNotEditable'\n\nexport interface LinkOptions {\n  /**\n   * If enabled, the extension will automatically add links as you type.\n   * @default true\n   * @example false\n   */\n  autolink: boolean\n\n  /**\n   * An array of custom protocols to be registered with linkifyjs.\n   * @default []\n   * @example ['ftp', 'git']\n   */\n  protocols: Array<LinkProtocolOptions | string>\n\n  /**\n   * Default protocol to use when no protocol is specified.\n   * @default 'http'\n   */\n  defaultProtocol: string\n  /**\n   * If enabled, links will be opened on click.\n   * @default true\n   * @example false\n   */\n  openOnClick: boolean | DeprecatedOpenWhenNotEditable\n  /**\n   * If enabled, the link will be selected when clicked.\n   * @default false\n   * @example true\n   */\n  enableClickSelection: boolean\n  /**\n   * Adds a link to the current selection if the pasted content only contains an url.\n   * @default true\n   * @example false\n   */\n  linkOnPaste: boolean\n\n  /**\n   * HTML attributes to add to the link element.\n   * @default {}\n   * @example { class: 'foo' }\n   */\n  HTMLAttributes: Record<string, any>\n\n  /**\n   * @deprecated Use the `shouldAutoLink` option instead.\n   * A validation function that modifies link verification for the auto linker.\n   * @param url - The url to be validated.\n   * @returns - True if the url is valid, false otherwise.\n   */\n  validate: (url: string) => boolean\n\n  /**\n   * A validation function which is used for configuring link verification for preventing XSS attacks.\n   * Only modify this if you know what you're doing.\n   *\n   * @returns {boolean} `true` if the URL is valid, `false` otherwise.\n   *\n   * @example\n   * isAllowedUri: (url, { defaultValidate, protocols, defaultProtocol }) => {\n   * return url.startsWith('./') || defaultValidate(url)\n   * }\n   */\n  isAllowedUri: (\n    /**\n     * The URL to be validated.\n     */\n    url: string,\n    ctx: {\n      /**\n       * The default validation function.\n       */\n      defaultValidate: (url: string) => boolean\n      /**\n       * An array of allowed protocols for the URL (e.g., \"http\", \"https\"). As defined in the `protocols` option.\n       */\n      protocols: Array<LinkProtocolOptions | string>\n      /**\n       * A string that represents the default protocol (e.g., 'http'). As defined in the `defaultProtocol` option.\n       */\n      defaultProtocol: string\n    },\n  ) => boolean\n\n  /**\n   * Determines whether a valid link should be automatically linked in the content.\n   *\n   * @param {string} url - The URL that has already been validated.\n   * @returns {boolean} - True if the link should be auto-linked; false if it should not be auto-linked.\n   */\n  shouldAutoLink: (url: string) => boolean\n}\n\ndeclare module '@tiptap/core' {\n  interface Commands<ReturnType> {\n    link: {\n      /**\n       * Set a link mark\n       * @param attributes The link attributes\n       * @example editor.commands.setLink({ href: 'https://tiptap.dev' })\n       */\n      setLink: (attributes: {\n        href: string\n        target?: string | null\n        rel?: string | null\n        class?: string | null\n      }) => ReturnType\n      /**\n       * Toggle a link mark\n       * @param attributes The link attributes\n       * @example editor.commands.toggleLink({ href: 'https://tiptap.dev' })\n       */\n      toggleLink: (attributes?: {\n        href: string\n        target?: string | null\n        rel?: string | null\n        class?: string | null\n      }) => ReturnType\n      /**\n       * Unset a link mark\n       * @example editor.commands.unsetLink()\n       */\n      unsetLink: () => ReturnType\n    }\n  }\n}\n\nexport function isAllowedUri(uri: string | undefined, protocols?: LinkOptions['protocols']) {\n  const allowedProtocols: string[] = ['http', 'https', 'ftp', 'ftps', 'mailto', 'tel', 'callto', 'sms', 'cid', 'xmpp']\n\n  if (protocols) {\n    protocols.forEach(protocol => {\n      const nextProtocol = typeof protocol === 'string' ? protocol : protocol.scheme\n\n      if (nextProtocol) {\n        allowedProtocols.push(nextProtocol)\n      }\n    })\n  }\n\n  return (\n    !uri ||\n    uri.replace(UNICODE_WHITESPACE_REGEX_GLOBAL, '').match(\n      new RegExp(\n        // eslint-disable-next-line no-useless-escape\n        `^(?:(?:${allowedProtocols.join('|')}):|[^a-z]|[a-z0-9+.\\-]+(?:[^a-z+.\\-:]|$))`,\n        'i',\n      ),\n    )\n  )\n}\n\n/**\n * This extension allows you to create links.\n * @see https://www.tiptap.dev/api/marks/link\n */\nexport const Link = Mark.create<LinkOptions>({\n  name: 'link',\n\n  priority: 1000,\n\n  keepOnSplit: false,\n\n  exitable: true,\n\n  onCreate() {\n    if (this.options.validate && !this.options.shouldAutoLink) {\n      // Copy the validate function to the shouldAutoLink option\n      this.options.shouldAutoLink = this.options.validate\n      console.warn('The `validate` option is deprecated. Rename to the `shouldAutoLink` option instead.')\n    }\n    this.options.protocols.forEach(protocol => {\n      if (typeof protocol === 'string') {\n        registerCustomProtocol(protocol)\n        return\n      }\n      registerCustomProtocol(protocol.scheme, protocol.optionalSlashes)\n    })\n  },\n\n  onDestroy() {\n    reset()\n  },\n\n  inclusive() {\n    return this.options.autolink\n  },\n\n  addOptions() {\n    return {\n      openOnClick: true,\n      enableClickSelection: false,\n      linkOnPaste: true,\n      autolink: true,\n      protocols: [],\n      defaultProtocol: 'http',\n      HTMLAttributes: {\n        target: '_blank',\n        rel: 'noopener noreferrer nofollow',\n        class: null,\n      },\n      isAllowedUri: (url, ctx) => !!isAllowedUri(url, ctx.protocols),\n      validate: url => !!url,\n      shouldAutoLink: url => !!url,\n    }\n  },\n\n  addAttributes() {\n    return {\n      href: {\n        default: null,\n        parseHTML(element) {\n          return element.getAttribute('href')\n        },\n      },\n      target: {\n        default: this.options.HTMLAttributes.target,\n      },\n      rel: {\n        default: this.options.HTMLAttributes.rel,\n      },\n      class: {\n        default: this.options.HTMLAttributes.class,\n      },\n    }\n  },\n\n  parseHTML() {\n    return [\n      {\n        tag: 'a[href]',\n        getAttrs: dom => {\n          const href = (dom as HTMLElement).getAttribute('href')\n\n          // prevent XSS attacks\n          if (\n            !href ||\n            !this.options.isAllowedUri(href, {\n              defaultValidate: url => !!isAllowedUri(url, this.options.protocols),\n              protocols: this.options.protocols,\n              defaultProtocol: this.options.defaultProtocol,\n            })\n          ) {\n            return false\n          }\n          return null\n        },\n      },\n    ]\n  },\n\n  renderHTML({ HTMLAttributes }) {\n    // prevent XSS attacks\n    if (\n      !this.options.isAllowedUri(HTMLAttributes.href, {\n        defaultValidate: href => !!isAllowedUri(href, this.options.protocols),\n        protocols: this.options.protocols,\n        defaultProtocol: this.options.defaultProtocol,\n      })\n    ) {\n      // strip out the href\n      return ['a', mergeAttributes(this.options.HTMLAttributes, { ...HTMLAttributes, href: '' }), 0]\n    }\n\n    return ['a', mergeAttributes(this.options.HTMLAttributes, HTMLAttributes), 0]\n  },\n\n  addCommands() {\n    return {\n      setLink:\n        attributes =>\n        ({ chain }) => {\n          const { href } = attributes\n\n          if (\n            !this.options.isAllowedUri(href, {\n              defaultValidate: url => !!isAllowedUri(url, this.options.protocols),\n              protocols: this.options.protocols,\n              defaultProtocol: this.options.defaultProtocol,\n            })\n          ) {\n            return false\n          }\n\n          return chain().setMark(this.name, attributes).setMeta('preventAutolink', true).run()\n        },\n\n      toggleLink:\n        attributes =>\n        ({ chain }) => {\n          const { href } = attributes || {}\n\n          if (\n            href &&\n            !this.options.isAllowedUri(href, {\n              defaultValidate: url => !!isAllowedUri(url, this.options.protocols),\n              protocols: this.options.protocols,\n              defaultProtocol: this.options.defaultProtocol,\n            })\n          ) {\n            return false\n          }\n\n          return chain()\n            .toggleMark(this.name, attributes, { extendEmptyMarkRange: true })\n            .setMeta('preventAutolink', true)\n            .run()\n        },\n\n      unsetLink:\n        () =>\n        ({ chain }) => {\n          return chain().unsetMark(this.name, { extendEmptyMarkRange: true }).setMeta('preventAutolink', true).run()\n        },\n    }\n  },\n\n  addPasteRules() {\n    return [\n      markPasteRule({\n        find: text => {\n          const foundLinks: PasteRuleMatch[] = []\n\n          if (text) {\n            const { protocols, defaultProtocol } = this.options\n            const links = find(text).filter(\n              item =>\n                item.isLink &&\n                this.options.isAllowedUri(item.value, {\n                  defaultValidate: href => !!isAllowedUri(href, protocols),\n                  protocols,\n                  defaultProtocol,\n                }),\n            )\n\n            if (links.length) {\n              links.forEach(link =>\n                foundLinks.push({\n                  text: link.value,\n                  data: {\n                    href: link.href,\n                  },\n                  index: link.start,\n                }),\n              )\n            }\n          }\n\n          return foundLinks\n        },\n        type: this.type,\n        getAttributes: match => {\n          return {\n            href: match.data?.href,\n          }\n        },\n      }),\n    ]\n  },\n\n  addProseMirrorPlugins() {\n    const plugins: Plugin[] = []\n    const { protocols, defaultProtocol } = this.options\n\n    if (this.options.autolink) {\n      plugins.push(\n        autolink({\n          type: this.type,\n          defaultProtocol: this.options.defaultProtocol,\n          validate: url =>\n            this.options.isAllowedUri(url, {\n              defaultValidate: href => !!isAllowedUri(href, protocols),\n              protocols,\n              defaultProtocol,\n            }),\n          shouldAutoLink: this.options.shouldAutoLink,\n        }),\n      )\n    }\n\n    if (this.options.openOnClick === true) {\n      plugins.push(\n        clickHandler({\n          type: this.type,\n          editor: this.editor,\n          enableClickSelection: this.options.enableClickSelection,\n        }),\n      )\n    }\n\n    if (this.options.linkOnPaste) {\n      plugins.push(\n        pasteHandler({\n          editor: this.editor,\n          defaultProtocol: this.options.defaultProtocol,\n          type: this.type,\n        }),\n      )\n    }\n\n    return plugins\n  },\n})\n","import type { NodeWithPos } from '@tiptap/core'\nimport { combineTransactionSteps, findChildrenInRange, getChangedRanges, getMarksBetween } from '@tiptap/core'\nimport type { MarkType } from '@tiptap/pm/model'\nimport { Plugin, PluginKey } from '@tiptap/pm/state'\nimport type { MultiToken } from 'linkifyjs'\nimport { tokenize } from 'linkifyjs'\n\nimport { UNICODE_WHITESPACE_REGEX, UNICODE_WHITESPACE_REGEX_END } from './whitespace.js'\n\n/**\n * Check if the provided tokens form a valid link structure, which can either be a single link token\n * or a link token surrounded by parentheses or square brackets.\n *\n * This ensures that only complete and valid text is hyperlinked, preventing cases where a valid\n * top-level domain (TLD) is immediately followed by an invalid character, like a number. For\n * example, with the `find` method from Linkify, entering `example.com1` would result in\n * `example.com` being linked and the trailing `1` left as plain text. By using the `tokenize`\n * method, we can perform more comprehensive validation on the input text.\n */\nfunction isValidLinkStructure(tokens: Array<ReturnType<MultiToken['toObject']>>) {\n  if (tokens.length === 1) {\n    return tokens[0].isLink\n  }\n\n  if (tokens.length === 3 && tokens[1].isLink) {\n    return ['()', '[]'].includes(tokens[0].value + tokens[2].value)\n  }\n\n  return false\n}\n\ntype AutolinkOptions = {\n  type: MarkType\n  defaultProtocol: string\n  validate: (url: string) => boolean\n  shouldAutoLink: (url: string) => boolean\n}\n\n/**\n * This plugin allows you to automatically add links to your editor.\n * @param options The plugin options\n * @returns The plugin instance\n */\nexport function autolink(options: AutolinkOptions): Plugin {\n  return new Plugin({\n    key: new PluginKey('autolink'),\n    appendTransaction: (transactions, oldState, newState) => {\n      /**\n       * Does the transaction change the document?\n       */\n      const docChanges = transactions.some(transaction => transaction.docChanged) && !oldState.doc.eq(newState.doc)\n\n      /**\n       * Prevent autolink if the transaction is not a document change or if the transaction has the meta `preventAutolink`.\n       */\n      const preventAutolink = transactions.some(transaction => transaction.getMeta('preventAutolink'))\n\n      /**\n       * Prevent autolink if the transaction is not a document change\n       * or if the transaction has the meta `preventAutolink`.\n       */\n      if (!docChanges || preventAutolink) {\n        return\n      }\n\n      const { tr } = newState\n      const transform = combineTransactionSteps(oldState.doc, [...transactions])\n      const changes = getChangedRanges(transform)\n\n      changes.forEach(({ newRange }) => {\n        // Now letâ€™s see if we can add new links.\n        const nodesInChangedRanges = findChildrenInRange(newState.doc, newRange, node => node.isTextblock)\n\n        let textBlock: NodeWithPos | undefined\n        let textBeforeWhitespace: string | undefined\n\n        if (nodesInChangedRanges.length > 1) {\n          // Grab the first node within the changed ranges (ex. the first of two paragraphs when hitting enter).\n          textBlock = nodesInChangedRanges[0]\n          textBeforeWhitespace = newState.doc.textBetween(\n            textBlock.pos,\n            textBlock.pos + textBlock.node.nodeSize,\n            undefined,\n            ' ',\n          )\n        } else if (nodesInChangedRanges.length) {\n          const endText = newState.doc.textBetween(newRange.from, newRange.to, ' ', ' ')\n          if (!UNICODE_WHITESPACE_REGEX_END.test(endText)) {\n            return\n          }\n          textBlock = nodesInChangedRanges[0]\n          textBeforeWhitespace = newState.doc.textBetween(textBlock.pos, newRange.to, undefined, ' ')\n        }\n\n        if (textBlock && textBeforeWhitespace) {\n          const wordsBeforeWhitespace = textBeforeWhitespace.split(UNICODE_WHITESPACE_REGEX).filter(Boolean)\n\n          if (wordsBeforeWhitespace.length <= 0) {\n            return false\n          }\n\n          const lastWordBeforeSpace = wordsBeforeWhitespace[wordsBeforeWhitespace.length - 1]\n          const lastWordAndBlockOffset = textBlock.pos + textBeforeWhitespace.lastIndexOf(lastWordBeforeSpace)\n\n          if (!lastWordBeforeSpace) {\n            return false\n          }\n\n          const linksBeforeSpace = tokenize(lastWordBeforeSpace).map(t => t.toObject(options.defaultProtocol))\n\n          if (!isValidLinkStructure(linksBeforeSpace)) {\n            return false\n          }\n\n          linksBeforeSpace\n            .filter(link => link.isLink)\n            // Calculate link position.\n            .map(link => ({\n              ...link,\n              from: lastWordAndBlockOffset + link.start + 1,\n              to: lastWordAndBlockOffset + link.end + 1,\n            }))\n            // ignore link inside code mark\n            .filter(link => {\n              if (!newState.schema.marks.code) {\n                return true\n              }\n\n              return !newState.doc.rangeHasMark(link.from, link.to, newState.schema.marks.code)\n            })\n            // validate link\n            .filter(link => options.validate(link.value))\n            // check whether should autolink\n            .filter(link => options.shouldAutoLink(link.value))\n            // Add link mark.\n            .forEach(link => {\n              if (getMarksBetween(link.from, link.to, newState.doc).some(item => item.mark.type === options.type)) {\n                return\n              }\n\n              tr.addMark(\n                link.from,\n                link.to,\n                options.type.create({\n                  href: link.href,\n                }),\n              )\n            })\n        }\n      })\n\n      if (!tr.steps.length) {\n        return\n      }\n\n      return tr\n    },\n  })\n}\n","// From DOMPurify\n// https://github.com/cure53/DOMPurify/blob/main/src/regexp.ts\nexport const UNICODE_WHITESPACE_PATTERN = '[\\u0000-\\u0020\\u00A0\\u1680\\u180E\\u2000-\\u2029\\u205F\\u3000]'\n\nexport const UNICODE_WHITESPACE_REGEX = new RegExp(UNICODE_WHITESPACE_PATTERN)\nexport const UNICODE_WHITESPACE_REGEX_END = new RegExp(`${UNICODE_WHITESPACE_PATTERN}$`)\nexport const UNICODE_WHITESPACE_REGEX_GLOBAL = new RegExp(UNICODE_WHITESPACE_PATTERN, 'g')\n","import type { Editor } from '@tiptap/core'\nimport { getAttributes } from '@tiptap/core'\nimport type { MarkType } from '@tiptap/pm/model'\nimport { Plugin, PluginKey } from '@tiptap/pm/state'\n\ntype ClickHandlerOptions = {\n  type: MarkType\n  editor: Editor\n  enableClickSelection?: boolean\n}\n\nexport function clickHandler(options: ClickHandlerOptions): Plugin {\n  return new Plugin({\n    key: new PluginKey('handleClickLink'),\n    props: {\n      handleClick: (view, pos, event) => {\n        if (event.button !== 0) {\n          return false\n        }\n\n        if (!view.editable) {\n          return false\n        }\n\n        let link: HTMLAnchorElement | null = null\n\n        if (event.target instanceof HTMLAnchorElement) {\n          link = event.target\n        } else {\n          let a = event.target as HTMLElement\n          const els = []\n\n          while (a.nodeName !== 'DIV') {\n            els.push(a)\n            a = a.parentNode as HTMLElement\n          }\n          link = els.find(value => value.nodeName === 'A') as HTMLAnchorElement\n        }\n\n        if (!link) {\n          return false\n        }\n\n        const attrs = getAttributes(view.state, options.type.name)\n        const href = link?.href ?? attrs.href\n        const target = link?.target ?? attrs.target\n\n        if (options.enableClickSelection) {\n          options.editor.commands.extendMarkRange(options.type.name)\n        }\n\n        if (link && href) {\n          window.open(href, target)\n\n          return true\n        }\n\n        return false\n      },\n    },\n  })\n}\n","import type { Editor } from '@tiptap/core'\nimport type { MarkType } from '@tiptap/pm/model'\nimport { Plugin, PluginKey } from '@tiptap/pm/state'\nimport { find } from 'linkifyjs'\n\ntype PasteHandlerOptions = {\n  editor: Editor\n  defaultProtocol: string\n  type: MarkType\n}\n\nexport function pasteHandler(options: PasteHandlerOptions): Plugin {\n  return new Plugin({\n    key: new PluginKey('handlePasteLink'),\n    props: {\n      handlePaste: (view, event, slice) => {\n        const { state } = view\n        const { selection } = state\n        const { empty } = selection\n\n        if (empty) {\n          return false\n        }\n\n        let textContent = ''\n\n        slice.content.forEach(node => {\n          textContent += node.textContent\n        })\n\n        const link = find(textContent, { defaultProtocol: options.defaultProtocol }).find(\n          item => item.isLink && item.value === textContent,\n        )\n\n        if (!textContent || !link) {\n          return false\n        }\n\n        return options.editor.commands.setMark(options.type, {\n          href: link.href,\n        })\n      },\n    },\n  })\n}\n","import { Link } from './link.js'\n\nexport * from './link.js'\n\nexport default Link\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}