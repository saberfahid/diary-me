{"ast":null,"code":"// THIS FILE IS AUTOMATICALLY GENERATED DO NOT EDIT DIRECTLY\n// See update-tlds.js for encoding/decoding format\n// https://data.iana.org/TLD/tlds-alpha-by-domain.txt\nconst encodedTlds = 'aaa1rp3bb0ott3vie4c1le2ogado5udhabi7c0ademy5centure6ountant0s9o1tor4d0s1ult4e0g1ro2tna4f0l1rica5g0akhan5ency5i0g1rbus3force5tel5kdn3l0ibaba4pay4lfinanz6state5y2sace3tom5m0azon4ericanexpress7family11x2fam3ica3sterdam8nalytics7droid5quan4z2o0l2partments8p0le4q0uarelle8r0ab1mco4chi3my2pa2t0e3s0da2ia2sociates9t0hleta5torney7u0ction5di0ble3o3spost5thor3o0s4w0s2x0a2z0ure5ba0by2idu3namex4d1k2r0celona5laycard4s5efoot5gains6seball5ketball8uhaus5yern5b0c1t1va3cg1n2d1e0ats2uty4er2rlin4st0buy5t2f1g1h0arti5i0ble3d1ke2ng0o3o1z2j1lack0friday9ockbuster8g1omberg7ue3m0s1w2n0pparibas9o0ats3ehringer8fa2m1nd2o0k0ing5sch2tik2on4t1utique6x2r0adesco6idgestone9oadway5ker3ther5ussels7s1t1uild0ers6siness6y1zz3v1w1y1z0h3ca0b1fe2l0l1vinklein9m0era3p2non3petown5ital0one8r0avan4ds2e0er0s4s2sa1e1h1ino4t0ering5holic7ba1n1re3c1d1enter4o1rn3f0a1d2g1h0anel2nel4rity4se2t2eap3intai5ristmas6ome4urch5i0priani6rcle4sco3tadel4i0c2y3k1l0aims4eaning6ick2nic1que6othing5ud3ub0med6m1n1o0ach3des3ffee4llege4ogne5m0mbank4unity6pany2re3uter5sec4ndos3struction8ulting7tact3ractors9oking4l1p2rsica5untry4pon0s4rses6pa2r0edit0card4union9icket5own3s1uise0s6u0isinella9v1w1x1y0mru3ou3z2dad1nce3ta1e1ing3sun4y2clk3ds2e0al0er2s3gree4livery5l1oitte5ta3mocrat6ntal2ist5si0gn4v2hl2iamonds6et2gital5rect0ory7scount3ver5h2y2j1k1m1np2o0cs1tor4g1mains5t1wnload7rive4tv2ubai3nlop4pont4rban5vag2r2z2earth3t2c0o2deka3u0cation8e1g1mail3erck5nergy4gineer0ing9terprises10pson4quipment8r0icsson6ni3s0q1tate5t1u0rovision8s2vents5xchange6pert3osed4ress5traspace10fage2il1rwinds6th3mily4n0s2rm0ers5shion4t3edex3edback6rrari3ero6i0delity5o2lm2nal1nce1ial7re0stone6mdale6sh0ing5t0ness6j1k1lickr3ghts4r2orist4wers5y2m1o0o0d1tball6rd1ex2sale4um3undation8x2r0ee1senius7l1ogans4ntier7tr2ujitsu5n0d2rniture7tbol5yi3ga0l0lery3o1up4me0s3p1rden4y2b0iz3d0n2e0a1nt0ing5orge5f1g0ee3h1i0ft0s3ves2ing5l0ass3e1obal2o4m0ail3bh2o1x2n1odaddy5ld0point6f2o0dyear5g0le4p1t1v2p1q1r0ainger5phics5tis4een3ipe3ocery4up4s1t1u0cci3ge2ide2tars5ru3w1y2hair2mburg5ngout5us3bo2dfc0bank7ealth0care8lp1sinki6re1mes5iphop4samitsu7tachi5v2k0t2m1n1ockey4ldings5iday5medepot5goods5s0ense7nda3rse3spital5t0ing5t0els3mail5use3w2r1sbc3t1u0ghes5yatt3undai7ibm2cbc2e1u2d1e0ee3fm2kano4l1m0amat4db2mo0bilien9n0c1dustries8finiti5o2g1k1stitute6urance4e4t0ernational10uit4vestments10o1piranga7q1r0ish4s0maili5t0anbul7t0au2v3jaguar4va3cb2e0ep2tzt3welry6io2ll2m0p2nj2o0bs1urg4t1y2p0morgan6rs3uegos4niper7kaufen5ddi3e0rryhotels6properties14fh2g1h1i0a1ds2m1ndle4tchen5wi3m1n1oeln3matsu5sher5p0mg2n2r0d1ed3uokgroup8w1y0oto4z2la0caixa5mborghini8er3nd0rover6xess5salle5t0ino3robe5w0yer5b1c1ds2ease3clerc5frak4gal2o2xus4gbt3i0dl2fe0insurance9style7ghting6ke2lly3mited4o2ncoln4k2ve1ing5k1lc1p2oan0s3cker3us3l1ndon4tte1o3ve3pl0financial11r1s1t0d0a3u0ndbeck6xe1ury5v1y2ma0drid4if1son4keup4n0agement7go3p1rket0ing3s4riott5shalls7ttel5ba2c0kinsey7d1e0d0ia3et2lbourne7me1orial6n0u2rckmsd7g1h1iami3crosoft7l1ni1t2t0subishi9k1l0b1s2m0a2n1o0bi0le4da2e1i1m1nash3ey2ster5rmon3tgage6scow4to0rcycles9v0ie4p1q1r1s0d2t0n1r2u0seum3ic4v1w1x1y1z2na0b1goya4me2vy3ba2c1e0c1t0bank4flix4work5ustar5w0s2xt0direct7us4f0l2g0o2hk2i0co2ke1on3nja3ssan1y5l1o0kia3rton4w0ruz3tv4p1r0a1w2tt2u1yc2z2obi1server7ffice5kinawa6layan0group9lo3m0ega4ne1g1l0ine5oo2pen3racle3nge4g0anic5igins6saka4tsuka4t2vh3pa0ge2nasonic7ris2s1tners4s1y3y2ccw3e0t2f0izer5g1h0armacy6d1ilips5one2to0graphy6s4ysio5ics1tet2ures6d1n0g1k2oneer5zza4k1l0ace2y0station9umbing5s3m1n0c2ohl2ker3litie5rn2st3r0axi3ess3ime3o0d0uctions8f1gressive8mo2perties3y5tection8u0dential9s1t1ub2w0c2y2qa1pon3uebec3st5racing4dio4e0ad1lestate6tor2y4cipes5d0stone5umbrella9hab3ise0n3t2liance6n0t0als5pair3ort3ublican8st0aurant8view0s5xroth6ich0ardli6oh3l1o1p2o0cks3deo3gers4om3s0vp3u0gby3hr2n2w0e2yukyu6sa0arland6fe0ty4kura4le1on3msclub4ung5ndvik0coromant12ofi4p1rl2s1ve2xo3b0i1s2c0b1haeffler7midt4olarships8ol3ule3warz5ience5ot3d1e0arch3t2cure1ity6ek2lect4ner3rvices6ven3w1x0y3fr2g1h0angrila6rp3ell3ia1ksha5oes2p0ping5uji3w3i0lk2na1gles5te3j1k0i0n2y0pe4l0ing4m0art3ile4n0cf3o0ccer3ial4ftbank4ware6hu2lar2utions7ng1y2y2pa0ce3ort2t3r0l2s1t0ada2ples4r1tebank4farm7c0group6ockholm6rage3e3ream4udio2y3yle4u0cks3pplies3y2ort5rf1gery5zuki5v1watch4iss4x1y0dney4stems6z2tab1ipei4lk2obao4rget4tamotors6r2too4x0i3c0i2d0k2eam2ch0nology8l1masek5nnis4va3f1g1h0d1eater2re6iaa2ckets5enda4ps2res2ol4j0maxx4x2k0maxx5l1m0all4n1o0day3kyo3ols3p1ray3shiba5tal3urs3wn2yota3s3r0ade1ing4ining5vel0ers0insurance16ust3v2t1ube2i1nes3shu4v0s2w1z2ua1bank3s2g1k1nicom3versity8o2ol2ps2s1y1z2va0cations7na1guard7c1e0gas3ntures6risign5mögensberater2ung14sicherung10t2g1i0ajes4deo3g1king4llas4n1p1rgin4sa1ion4va1o3laanderen9n1odka3lvo3te1ing3o2yage5u2wales2mart4ter4ng0gou5tch0es6eather0channel12bcam3er2site5d0ding5ibo2r3f1hoswho6ien2ki2lliamhill9n0dows4e1ners6me2olterskluwer11odside6rk0s2ld3w2s1tc1f3xbox3erox4ihuan4n2xx2yz3yachts4hoo3maxun5ndex5e1odobashi7ga2kohama6u0tube6t1un3za0ppos4ra3ero3ip2m1one3uerich6w2';\n// Internationalized domain names containing non-ASCII\nconst encodedUtlds = 'ελ1υ2бг1ел3дети4ею2католик6ом3мкд2он1сква6онлайн5рг3рус2ф2сайт3рб3укр3қаз3հայ3ישראל5קום3ابوظبي5رامكو5لاردن4بحرين5جزائر5سعودية6عليان5مغرب5مارات5یران5بارت2زار4يتك3ھارت5تونس4سودان3رية5شبكة4عراق2ب2مان4فلسطين6قطر3كاثوليك6وم3مصر2ليسيا5وريتانيا7قع4همراه5پاکستان7ڀارت4कॉम3नेट3भारत0म्3ोत5संगठन5বাংলা5ভারত2ৰত4ਭਾਰਤ4ભારત4ଭାରତ4இந்தியா6லங்கை6சிங்கப்பூர்11భారత్5ಭಾರತ4ഭാരതം5ලංකා4คอม3ไทย3ລາວ3გე2みんな3アマゾン4クラウド4グーグル4コム2ストア3セール3ファッション6ポイント4世界2中信1国1國1文网3亚马逊3企业2佛山2信息2健康2八卦2公司1益2台湾1灣2商城1店1标2嘉里0大酒店5在线2大拿2天主教3娱乐2家電2广东2微博2慈善2我爱你3手机2招聘2政务1府2新加坡2闻2时尚2書籍2机构2淡马锡3游戏2澳門2点看2移动2组织机构4网址1店1站1络2联通2谷歌2购物2通販2集团2電訊盈科4飞利浦3食品2餐厅2香格里拉3港2닷넷1컴2삼성2한국2';\n\n/**\n * Finite State Machine generation utilities\n */\n\n/**\n * @template T\n * @typedef {{ [group: string]: T[] }} Collections\n */\n\n/**\n * @typedef {{ [group: string]: true }} Flags\n */\n\n// Keys in scanner Collections instances\nconst numeric = 'numeric';\nconst ascii = 'ascii';\nconst alpha = 'alpha';\nconst asciinumeric = 'asciinumeric';\nconst alphanumeric = 'alphanumeric';\nconst domain = 'domain';\nconst emoji = 'emoji';\nconst scheme = 'scheme';\nconst slashscheme = 'slashscheme';\nconst whitespace = 'whitespace';\n\n/**\n * @template T\n * @param {string} name\n * @param {Collections<T>} groups to register in\n * @returns {T[]} Current list of tokens in the given collection\n */\nfunction registerGroup(name, groups) {\n  if (!(name in groups)) {\n    groups[name] = [];\n  }\n  return groups[name];\n}\n\n/**\n * @template T\n * @param {T} t token to add\n * @param {Collections<T>} groups\n * @param {Flags} flags\n */\nfunction addToGroups(t, flags, groups) {\n  if (flags[numeric]) {\n    flags[asciinumeric] = true;\n    flags[alphanumeric] = true;\n  }\n  if (flags[ascii]) {\n    flags[asciinumeric] = true;\n    flags[alpha] = true;\n  }\n  if (flags[asciinumeric]) {\n    flags[alphanumeric] = true;\n  }\n  if (flags[alpha]) {\n    flags[alphanumeric] = true;\n  }\n  if (flags[alphanumeric]) {\n    flags[domain] = true;\n  }\n  if (flags[emoji]) {\n    flags[domain] = true;\n  }\n  for (const k in flags) {\n    const group = registerGroup(k, groups);\n    if (group.indexOf(t) < 0) {\n      group.push(t);\n    }\n  }\n}\n\n/**\n * @template T\n * @param {T} t token to check\n * @param {Collections<T>} groups\n * @returns {Flags} group flags that contain this token\n */\nfunction flagsForToken(t, groups) {\n  const result = {};\n  for (const c in groups) {\n    if (groups[c].indexOf(t) >= 0) {\n      result[c] = true;\n    }\n  }\n  return result;\n}\n\n/**\n * @template T\n * @typedef {null | T } Transition\n */\n\n/**\n * Define a basic state machine state. j is the list of character transitions,\n * jr is the list of regex-match transitions, jd is the default state to\n * transition to t is the accepting token type, if any. If this is the terminal\n * state, then it does not emit a token.\n *\n * The template type T represents the type of the token this state accepts. This\n * should be a string (such as of the token exports in `text.js`) or a\n * MultiToken subclass (from `multi.js`)\n *\n * @template T\n * @param {T} [token] Token that this state emits\n */\nfunction State(token = null) {\n  // this.n = null; // DEBUG: State name\n  /** @type {{ [input: string]: State<T> }} j */\n  this.j = {}; // IMPLEMENTATION 1\n  // this.j = []; // IMPLEMENTATION 2\n  /** @type {[RegExp, State<T>][]} jr */\n  this.jr = [];\n  /** @type {?State<T>} jd */\n  this.jd = null;\n  /** @type {?T} t */\n  this.t = token;\n}\n\n/**\n * Scanner token groups\n * @type Collections<string>\n */\nState.groups = {};\nState.prototype = {\n  accepts() {\n    return !!this.t;\n  },\n  /**\n   * Follow an existing transition from the given input to the next state.\n   * Does not mutate.\n   * @param {string} input character or token type to transition on\n   * @returns {?State<T>} the next state, if any\n   */\n  go(input) {\n    const state = this;\n    const nextState = state.j[input];\n    if (nextState) {\n      return nextState;\n    }\n    for (let i = 0; i < state.jr.length; i++) {\n      const regex = state.jr[i][0];\n      const nextState = state.jr[i][1]; // note: might be empty to prevent default jump\n      if (nextState && regex.test(input)) {\n        return nextState;\n      }\n    }\n    // Nowhere left to jump! Return default, if any\n    return state.jd;\n  },\n  /**\n   * Whether the state has a transition for the given input. Set the second\n   * argument to true to only look for an exact match (and not a default or\n   * regular-expression-based transition)\n   * @param {string} input\n   * @param {boolean} exactOnly\n   */\n  has(input, exactOnly = false) {\n    return exactOnly ? input in this.j : !!this.go(input);\n  },\n  /**\n   * Short for \"transition all\"; create a transition from the array of items\n   * in the given list to the same final resulting state.\n   * @param {string | string[]} inputs Group of inputs to transition on\n   * @param {Transition<T> | State<T>} [next] Transition options\n   * @param {Flags} [flags] Collections flags to add token to\n   * @param {Collections<T>} [groups] Master list of token groups\n   */\n  ta(inputs, next, flags, groups) {\n    for (let i = 0; i < inputs.length; i++) {\n      this.tt(inputs[i], next, flags, groups);\n    }\n  },\n  /**\n   * Short for \"take regexp transition\"; defines a transition for this state\n   * when it encounters a token which matches the given regular expression\n   * @param {RegExp} regexp Regular expression transition (populate first)\n   * @param {T | State<T>} [next] Transition options\n   * @param {Flags} [flags] Collections flags to add token to\n   * @param {Collections<T>} [groups] Master list of token groups\n   * @returns {State<T>} taken after the given input\n   */\n  tr(regexp, next, flags, groups) {\n    groups = groups || State.groups;\n    let nextState;\n    if (next && next.j) {\n      nextState = next;\n    } else {\n      // Token with maybe token groups\n      nextState = new State(next);\n      if (flags && groups) {\n        addToGroups(next, flags, groups);\n      }\n    }\n    this.jr.push([regexp, nextState]);\n    return nextState;\n  },\n  /**\n   * Short for \"take transitions\", will take as many sequential transitions as\n   * the length of the given input and returns the\n   * resulting final state.\n   * @param {string | string[]} input\n   * @param {T | State<T>} [next] Transition options\n   * @param {Flags} [flags] Collections flags to add token to\n   * @param {Collections<T>} [groups] Master list of token groups\n   * @returns {State<T>} taken after the given input\n   */\n  ts(input, next, flags, groups) {\n    let state = this;\n    const len = input.length;\n    if (!len) {\n      return state;\n    }\n    for (let i = 0; i < len - 1; i++) {\n      state = state.tt(input[i]);\n    }\n    return state.tt(input[len - 1], next, flags, groups);\n  },\n  /**\n   * Short for \"take transition\", this is a method for building/working with\n   * state machines.\n   *\n   * If a state already exists for the given input, returns it.\n   *\n   * If a token is specified, that state will emit that token when reached by\n   * the linkify engine.\n   *\n   * If no state exists, it will be initialized with some default transitions\n   * that resemble existing default transitions.\n   *\n   * If a state is given for the second argument, that state will be\n   * transitioned to on the given input regardless of what that input\n   * previously did.\n   *\n   * Specify a token group flags to define groups that this token belongs to.\n   * The token will be added to corresponding entires in the given groups\n   * object.\n   *\n   * @param {string} input character, token type to transition on\n   * @param {T | State<T>} [next] Transition options\n   * @param {Flags} [flags] Collections flags to add token to\n   * @param {Collections<T>} [groups] Master list of groups\n   * @returns {State<T>} taken after the given input\n   */\n  tt(input, next, flags, groups) {\n    groups = groups || State.groups;\n    const state = this;\n\n    // Check if existing state given, just a basic transition\n    if (next && next.j) {\n      state.j[input] = next;\n      return next;\n    }\n    const t = next;\n\n    // Take the transition with the usual default mechanisms and use that as\n    // a template for creating the next state\n    let nextState,\n      templateState = state.go(input);\n    if (templateState) {\n      nextState = new State();\n      Object.assign(nextState.j, templateState.j);\n      nextState.jr.push.apply(nextState.jr, templateState.jr);\n      nextState.jd = templateState.jd;\n      nextState.t = templateState.t;\n    } else {\n      nextState = new State();\n    }\n    if (t) {\n      // Ensure newly token is in the same groups as the old token\n      if (groups) {\n        if (nextState.t && typeof nextState.t === 'string') {\n          const allFlags = Object.assign(flagsForToken(nextState.t, groups), flags);\n          addToGroups(t, allFlags, groups);\n        } else if (flags) {\n          addToGroups(t, flags, groups);\n        }\n      }\n      nextState.t = t; // overwrite anything that was previously there\n    }\n    state.j[input] = nextState;\n    return nextState;\n  }\n};\n\n// Helper functions to improve minification (not exported outside linkifyjs module)\n\n/**\n * @template T\n * @param {State<T>} state\n * @param {string | string[]} input\n * @param {Flags} [flags]\n * @param {Collections<T>} [groups]\n */\nconst ta = (state, input, next, flags, groups) => state.ta(input, next, flags, groups);\n\n/**\n * @template T\n * @param {State<T>} state\n * @param {RegExp} regexp\n * @param {T | State<T>} [next]\n * @param {Flags} [flags]\n * @param {Collections<T>} [groups]\n */\nconst tr = (state, regexp, next, flags, groups) => state.tr(regexp, next, flags, groups);\n\n/**\n * @template T\n * @param {State<T>} state\n * @param {string | string[]} input\n * @param {T | State<T>} [next]\n * @param {Flags} [flags]\n * @param {Collections<T>} [groups]\n */\nconst ts = (state, input, next, flags, groups) => state.ts(input, next, flags, groups);\n\n/**\n * @template T\n * @param {State<T>} state\n * @param {string} input\n * @param {T | State<T>} [next]\n * @param {Collections<T>} [groups]\n * @param {Flags} [flags]\n */\nconst tt = (state, input, next, flags, groups) => state.tt(input, next, flags, groups);\n\n/******************************************************************************\nText Tokens\nIdentifiers for token outputs from the regexp scanner\n******************************************************************************/\n\n// A valid web domain token\nconst WORD = 'WORD'; // only contains a-z\nconst UWORD = 'UWORD'; // contains letters other than a-z, used for IDN\nconst ASCIINUMERICAL = 'ASCIINUMERICAL'; // contains a-z, 0-9\nconst ALPHANUMERICAL = 'ALPHANUMERICAL'; // contains numbers and letters other than a-z, used for IDN\n\n// Special case of word\nconst LOCALHOST = 'LOCALHOST';\n\n// Valid top-level domain, special case of WORD (see tlds.js)\nconst TLD = 'TLD';\n\n// Valid IDN TLD, special case of UWORD (see tlds.js)\nconst UTLD = 'UTLD';\n\n// The scheme portion of a web URI protocol. Supported types include: `mailto`,\n// `file`, and user-defined custom protocols. Limited to schemes that contain\n// only letters\nconst SCHEME = 'SCHEME';\n\n// Similar to SCHEME, except makes distinction for schemes that must always be\n// followed by `://`, not just `:`. Supported types include `http`, `https`,\n// `ftp`, `ftps`\nconst SLASH_SCHEME = 'SLASH_SCHEME';\n\n// Any sequence of digits 0-9\nconst NUM = 'NUM';\n\n// Any number of consecutive whitespace characters that are not newline\nconst WS = 'WS';\n\n// New line (unix style)\nconst NL = 'NL'; // \\n\n\n// Opening/closing bracket classes\n// TODO: Rename OPEN -> LEFT and CLOSE -> RIGHT in v5 to fit with Unicode names\n// Also rename angle brackes to LESSTHAN and GREATER THAN\nconst OPENBRACE = 'OPENBRACE'; // {\nconst CLOSEBRACE = 'CLOSEBRACE'; // }\nconst OPENBRACKET = 'OPENBRACKET'; // [\nconst CLOSEBRACKET = 'CLOSEBRACKET'; // ]\nconst OPENPAREN = 'OPENPAREN'; // (\nconst CLOSEPAREN = 'CLOSEPAREN'; // )\nconst OPENANGLEBRACKET = 'OPENANGLEBRACKET'; // <\nconst CLOSEANGLEBRACKET = 'CLOSEANGLEBRACKET'; // >\nconst FULLWIDTHLEFTPAREN = 'FULLWIDTHLEFTPAREN'; // （\nconst FULLWIDTHRIGHTPAREN = 'FULLWIDTHRIGHTPAREN'; // ）\nconst LEFTCORNERBRACKET = 'LEFTCORNERBRACKET'; // 「\nconst RIGHTCORNERBRACKET = 'RIGHTCORNERBRACKET'; // 」\nconst LEFTWHITECORNERBRACKET = 'LEFTWHITECORNERBRACKET'; // 『\nconst RIGHTWHITECORNERBRACKET = 'RIGHTWHITECORNERBRACKET'; // 』\nconst FULLWIDTHLESSTHAN = 'FULLWIDTHLESSTHAN'; // ＜\nconst FULLWIDTHGREATERTHAN = 'FULLWIDTHGREATERTHAN'; // ＞\n\n// Various symbols\nconst AMPERSAND = 'AMPERSAND'; // &\nconst APOSTROPHE = 'APOSTROPHE'; // '\nconst ASTERISK = 'ASTERISK'; // *\nconst AT = 'AT'; // @\nconst BACKSLASH = 'BACKSLASH'; // \\\nconst BACKTICK = 'BACKTICK'; // `\nconst CARET = 'CARET'; // ^\nconst COLON = 'COLON'; // :\nconst COMMA = 'COMMA'; // ,\nconst DOLLAR = 'DOLLAR'; // $\nconst DOT = 'DOT'; // .\nconst EQUALS = 'EQUALS'; // =\nconst EXCLAMATION = 'EXCLAMATION'; // !\nconst HYPHEN = 'HYPHEN'; // -\nconst PERCENT = 'PERCENT'; // %\nconst PIPE = 'PIPE'; // |\nconst PLUS = 'PLUS'; // +\nconst POUND = 'POUND'; // #\nconst QUERY = 'QUERY'; // ?\nconst QUOTE = 'QUOTE'; // \"\nconst FULLWIDTHMIDDLEDOT = 'FULLWIDTHMIDDLEDOT'; // ・\n\nconst SEMI = 'SEMI'; // ;\nconst SLASH = 'SLASH'; // /\nconst TILDE = 'TILDE'; // ~\nconst UNDERSCORE = 'UNDERSCORE'; // _\n\n// Emoji symbol\nconst EMOJI$1 = 'EMOJI';\n\n// Default token - anything that is not one of the above\nconst SYM = 'SYM';\nvar tk = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  ALPHANUMERICAL: ALPHANUMERICAL,\n  AMPERSAND: AMPERSAND,\n  APOSTROPHE: APOSTROPHE,\n  ASCIINUMERICAL: ASCIINUMERICAL,\n  ASTERISK: ASTERISK,\n  AT: AT,\n  BACKSLASH: BACKSLASH,\n  BACKTICK: BACKTICK,\n  CARET: CARET,\n  CLOSEANGLEBRACKET: CLOSEANGLEBRACKET,\n  CLOSEBRACE: CLOSEBRACE,\n  CLOSEBRACKET: CLOSEBRACKET,\n  CLOSEPAREN: CLOSEPAREN,\n  COLON: COLON,\n  COMMA: COMMA,\n  DOLLAR: DOLLAR,\n  DOT: DOT,\n  EMOJI: EMOJI$1,\n  EQUALS: EQUALS,\n  EXCLAMATION: EXCLAMATION,\n  FULLWIDTHGREATERTHAN: FULLWIDTHGREATERTHAN,\n  FULLWIDTHLEFTPAREN: FULLWIDTHLEFTPAREN,\n  FULLWIDTHLESSTHAN: FULLWIDTHLESSTHAN,\n  FULLWIDTHMIDDLEDOT: FULLWIDTHMIDDLEDOT,\n  FULLWIDTHRIGHTPAREN: FULLWIDTHRIGHTPAREN,\n  HYPHEN: HYPHEN,\n  LEFTCORNERBRACKET: LEFTCORNERBRACKET,\n  LEFTWHITECORNERBRACKET: LEFTWHITECORNERBRACKET,\n  LOCALHOST: LOCALHOST,\n  NL: NL,\n  NUM: NUM,\n  OPENANGLEBRACKET: OPENANGLEBRACKET,\n  OPENBRACE: OPENBRACE,\n  OPENBRACKET: OPENBRACKET,\n  OPENPAREN: OPENPAREN,\n  PERCENT: PERCENT,\n  PIPE: PIPE,\n  PLUS: PLUS,\n  POUND: POUND,\n  QUERY: QUERY,\n  QUOTE: QUOTE,\n  RIGHTCORNERBRACKET: RIGHTCORNERBRACKET,\n  RIGHTWHITECORNERBRACKET: RIGHTWHITECORNERBRACKET,\n  SCHEME: SCHEME,\n  SEMI: SEMI,\n  SLASH: SLASH,\n  SLASH_SCHEME: SLASH_SCHEME,\n  SYM: SYM,\n  TILDE: TILDE,\n  TLD: TLD,\n  UNDERSCORE: UNDERSCORE,\n  UTLD: UTLD,\n  UWORD: UWORD,\n  WORD: WORD,\n  WS: WS\n});\n\n// Note that these two Unicode ones expand into a really big one with Babel\nconst ASCII_LETTER = /[a-z]/;\nconst LETTER = /\\p{L}/u; // Any Unicode character with letter data type\nconst EMOJI = /\\p{Emoji}/u; // Any Unicode emoji character\nconst EMOJI_VARIATION$1 = /\\ufe0f/;\nconst DIGIT = /\\d/;\nconst SPACE = /\\s/;\nvar regexp = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  ASCII_LETTER: ASCII_LETTER,\n  DIGIT: DIGIT,\n  EMOJI: EMOJI,\n  EMOJI_VARIATION: EMOJI_VARIATION$1,\n  LETTER: LETTER,\n  SPACE: SPACE\n});\n\n/**\n\tThe scanner provides an interface that takes a string of text as input, and\n\toutputs an array of tokens instances that can be used for easy URL parsing.\n*/\n\nconst CR = '\\r'; // carriage-return character\nconst LF = '\\n'; // line-feed character\nconst EMOJI_VARIATION = '\\ufe0f'; // Variation selector, follows heart and others\nconst EMOJI_JOINER = '\\u200d'; // zero-width joiner\nconst OBJECT_REPLACEMENT = '\\ufffc'; // whitespace placeholder that sometimes appears in rich text editors\n\nlet tlds = null,\n  utlds = null; // don't change so only have to be computed once\n\n/**\n * Scanner output token:\n * - `t` is the token name (e.g., 'NUM', 'EMOJI', 'TLD')\n * - `v` is the value of the token (e.g., '123', '❤️', 'com')\n * - `s` is the start index of the token in the original string\n * - `e` is the end index of the token in the original string\n * @typedef {{t: string, v: string, s: number, e: number}} Token\n */\n\n/**\n * @template T\n * @typedef {{ [collection: string]: T[] }} Collections\n */\n\n/**\n * Initialize the scanner character-based state machine for the given start\n * state\n * @param {[string, boolean][]} customSchemes List of custom schemes, where each\n * item is a length-2 tuple with the first element set to the string scheme, and\n * the second element set to `true` if the `://` after the scheme is optional\n */\nfunction init$2(customSchemes = []) {\n  // Frequently used states (name argument removed during minification)\n  /** @type Collections<string> */\n  const groups = {}; // of tokens\n  State.groups = groups;\n  /** @type State<string> */\n  const Start = new State();\n  if (tlds == null) {\n    tlds = decodeTlds(encodedTlds);\n  }\n  if (utlds == null) {\n    utlds = decodeTlds(encodedUtlds);\n  }\n\n  // States for special URL symbols that accept immediately after start\n  tt(Start, \"'\", APOSTROPHE);\n  tt(Start, '{', OPENBRACE);\n  tt(Start, '}', CLOSEBRACE);\n  tt(Start, '[', OPENBRACKET);\n  tt(Start, ']', CLOSEBRACKET);\n  tt(Start, '(', OPENPAREN);\n  tt(Start, ')', CLOSEPAREN);\n  tt(Start, '<', OPENANGLEBRACKET);\n  tt(Start, '>', CLOSEANGLEBRACKET);\n  tt(Start, '（', FULLWIDTHLEFTPAREN);\n  tt(Start, '）', FULLWIDTHRIGHTPAREN);\n  tt(Start, '「', LEFTCORNERBRACKET);\n  tt(Start, '」', RIGHTCORNERBRACKET);\n  tt(Start, '『', LEFTWHITECORNERBRACKET);\n  tt(Start, '』', RIGHTWHITECORNERBRACKET);\n  tt(Start, '＜', FULLWIDTHLESSTHAN);\n  tt(Start, '＞', FULLWIDTHGREATERTHAN);\n  tt(Start, '&', AMPERSAND);\n  tt(Start, '*', ASTERISK);\n  tt(Start, '@', AT);\n  tt(Start, '`', BACKTICK);\n  tt(Start, '^', CARET);\n  tt(Start, ':', COLON);\n  tt(Start, ',', COMMA);\n  tt(Start, '$', DOLLAR);\n  tt(Start, '.', DOT);\n  tt(Start, '=', EQUALS);\n  tt(Start, '!', EXCLAMATION);\n  tt(Start, '-', HYPHEN);\n  tt(Start, '%', PERCENT);\n  tt(Start, '|', PIPE);\n  tt(Start, '+', PLUS);\n  tt(Start, '#', POUND);\n  tt(Start, '?', QUERY);\n  tt(Start, '\"', QUOTE);\n  tt(Start, '/', SLASH);\n  tt(Start, ';', SEMI);\n  tt(Start, '~', TILDE);\n  tt(Start, '_', UNDERSCORE);\n  tt(Start, '\\\\', BACKSLASH);\n  tt(Start, '・', FULLWIDTHMIDDLEDOT);\n  const Num = tr(Start, DIGIT, NUM, {\n    [numeric]: true\n  });\n  tr(Num, DIGIT, Num);\n  const Asciinumeric = tr(Num, ASCII_LETTER, ASCIINUMERICAL, {\n    [asciinumeric]: true\n  });\n  const Alphanumeric = tr(Num, LETTER, ALPHANUMERICAL, {\n    [alphanumeric]: true\n  });\n\n  // State which emits a word token\n  const Word = tr(Start, ASCII_LETTER, WORD, {\n    [ascii]: true\n  });\n  tr(Word, DIGIT, Asciinumeric);\n  tr(Word, ASCII_LETTER, Word);\n  tr(Asciinumeric, DIGIT, Asciinumeric);\n  tr(Asciinumeric, ASCII_LETTER, Asciinumeric);\n\n  // Same as previous, but specific to non-fsm.ascii alphabet words\n  const UWord = tr(Start, LETTER, UWORD, {\n    [alpha]: true\n  });\n  tr(UWord, ASCII_LETTER); // Non-accepting\n  tr(UWord, DIGIT, Alphanumeric);\n  tr(UWord, LETTER, UWord);\n  tr(Alphanumeric, DIGIT, Alphanumeric);\n  tr(Alphanumeric, ASCII_LETTER); // Non-accepting\n  tr(Alphanumeric, LETTER, Alphanumeric); // Non-accepting\n\n  // Whitespace jumps\n  // Tokens of only non-newline whitespace are arbitrarily long\n  // If any whitespace except newline, more whitespace!\n  const Nl = tt(Start, LF, NL, {\n    [whitespace]: true\n  });\n  const Cr = tt(Start, CR, WS, {\n    [whitespace]: true\n  });\n  const Ws = tr(Start, SPACE, WS, {\n    [whitespace]: true\n  });\n  tt(Start, OBJECT_REPLACEMENT, Ws);\n  tt(Cr, LF, Nl); // \\r\\n\n  tt(Cr, OBJECT_REPLACEMENT, Ws);\n  tr(Cr, SPACE, Ws);\n  tt(Ws, CR); // non-accepting state to avoid mixing whitespaces\n  tt(Ws, LF); // non-accepting state to avoid mixing whitespaces\n  tr(Ws, SPACE, Ws);\n  tt(Ws, OBJECT_REPLACEMENT, Ws);\n\n  // Emoji tokens. They are not grouped by the scanner except in cases where a\n  // zero-width joiner is present\n  const Emoji = tr(Start, EMOJI, EMOJI$1, {\n    [emoji]: true\n  });\n  tt(Emoji, '#'); // no transition, emoji regex seems to match #\n  tr(Emoji, EMOJI, Emoji);\n  tt(Emoji, EMOJI_VARIATION, Emoji);\n  // tt(Start, EMOJI_VARIATION, Emoji); // This one is sketchy\n\n  const EmojiJoiner = tt(Emoji, EMOJI_JOINER);\n  tt(EmojiJoiner, '#');\n  tr(EmojiJoiner, EMOJI, Emoji);\n  // tt(EmojiJoiner, EMOJI_VARIATION, Emoji); // also sketchy\n\n  // Generates states for top-level domains\n  // Note that this is most accurate when tlds are in alphabetical order\n  const wordjr = [[ASCII_LETTER, Word], [DIGIT, Asciinumeric]];\n  const uwordjr = [[ASCII_LETTER, null], [LETTER, UWord], [DIGIT, Alphanumeric]];\n  for (let i = 0; i < tlds.length; i++) {\n    fastts(Start, tlds[i], TLD, WORD, wordjr);\n  }\n  for (let i = 0; i < utlds.length; i++) {\n    fastts(Start, utlds[i], UTLD, UWORD, uwordjr);\n  }\n  addToGroups(TLD, {\n    tld: true,\n    ascii: true\n  }, groups);\n  addToGroups(UTLD, {\n    utld: true,\n    alpha: true\n  }, groups);\n\n  // Collect the states generated by different protocols. NOTE: If any new TLDs\n  // get added that are also protocols, set the token to be the same as the\n  // protocol to ensure parsing works as expected.\n  fastts(Start, 'file', SCHEME, WORD, wordjr);\n  fastts(Start, 'mailto', SCHEME, WORD, wordjr);\n  fastts(Start, 'http', SLASH_SCHEME, WORD, wordjr);\n  fastts(Start, 'https', SLASH_SCHEME, WORD, wordjr);\n  fastts(Start, 'ftp', SLASH_SCHEME, WORD, wordjr);\n  fastts(Start, 'ftps', SLASH_SCHEME, WORD, wordjr);\n  addToGroups(SCHEME, {\n    scheme: true,\n    ascii: true\n  }, groups);\n  addToGroups(SLASH_SCHEME, {\n    slashscheme: true,\n    ascii: true\n  }, groups);\n\n  // Register custom schemes. Assumes each scheme is asciinumeric with hyphens\n  customSchemes = customSchemes.sort((a, b) => a[0] > b[0] ? 1 : -1);\n  for (let i = 0; i < customSchemes.length; i++) {\n    const sch = customSchemes[i][0];\n    const optionalSlashSlash = customSchemes[i][1];\n    const flags = optionalSlashSlash ? {\n      [scheme]: true\n    } : {\n      [slashscheme]: true\n    };\n    if (sch.indexOf('-') >= 0) {\n      flags[domain] = true;\n    } else if (!ASCII_LETTER.test(sch)) {\n      flags[numeric] = true; // numbers only\n    } else if (DIGIT.test(sch)) {\n      flags[asciinumeric] = true;\n    } else {\n      flags[ascii] = true;\n    }\n    ts(Start, sch, sch, flags);\n  }\n\n  // Localhost token\n  ts(Start, 'localhost', LOCALHOST, {\n    ascii: true\n  });\n\n  // Set default transition for start state (some symbol)\n  Start.jd = new State(SYM);\n  return {\n    start: Start,\n    tokens: Object.assign({\n      groups\n    }, tk)\n  };\n}\n\n/**\n\tGiven a string, returns an array of TOKEN instances representing the\n\tcomposition of that string.\n\n\t@method run\n\t@param {State<string>} start scanner starting state\n\t@param {string} str input string to scan\n\t@return {Token[]} list of tokens, each with a type and value\n*/\nfunction run$1(start, str) {\n  // State machine is not case sensitive, so input is tokenized in lowercased\n  // form (still returns regular case). Uses selective `toLowerCase` because\n  // lowercasing the entire string causes the length and character position to\n  // vary in some non-English strings with V8-based runtimes.\n  const iterable = stringToArray(str.replace(/[A-Z]/g, c => c.toLowerCase()));\n  const charCount = iterable.length; // <= len if there are emojis, etc\n  const tokens = []; // return value\n\n  // cursor through the string itself, accounting for characters that have\n  // width with length 2 such as emojis\n  let cursor = 0;\n\n  // Cursor through the array-representation of the string\n  let charCursor = 0;\n\n  // Tokenize the string\n  while (charCursor < charCount) {\n    let state = start;\n    let nextState = null;\n    let tokenLength = 0;\n    let latestAccepting = null;\n    let sinceAccepts = -1;\n    let charsSinceAccepts = -1;\n    while (charCursor < charCount && (nextState = state.go(iterable[charCursor]))) {\n      state = nextState;\n\n      // Keep track of the latest accepting state\n      if (state.accepts()) {\n        sinceAccepts = 0;\n        charsSinceAccepts = 0;\n        latestAccepting = state;\n      } else if (sinceAccepts >= 0) {\n        sinceAccepts += iterable[charCursor].length;\n        charsSinceAccepts++;\n      }\n      tokenLength += iterable[charCursor].length;\n      cursor += iterable[charCursor].length;\n      charCursor++;\n    }\n\n    // Roll back to the latest accepting state\n    cursor -= sinceAccepts;\n    charCursor -= charsSinceAccepts;\n    tokenLength -= sinceAccepts;\n\n    // No more jumps, just make a new token from the last accepting one\n    tokens.push({\n      t: latestAccepting.t,\n      // token type/name\n      v: str.slice(cursor - tokenLength, cursor),\n      // string value\n      s: cursor - tokenLength,\n      // start index\n      e: cursor // end index (excluding)\n    });\n  }\n  return tokens;\n}\n\n/**\n * Convert a String to an Array of characters, taking into account that some\n * characters like emojis take up two string indexes.\n *\n * Adapted from core-js (MIT license)\n * https://github.com/zloirock/core-js/blob/2d69cf5f99ab3ea3463c395df81e5a15b68f49d9/packages/core-js/internals/string-multibyte.js\n *\n * @function stringToArray\n * @param {string} str\n * @returns {string[]}\n */\nfunction stringToArray(str) {\n  const result = [];\n  const len = str.length;\n  let index = 0;\n  while (index < len) {\n    let first = str.charCodeAt(index);\n    let second;\n    let char = first < 0xd800 || first > 0xdbff || index + 1 === len || (second = str.charCodeAt(index + 1)) < 0xdc00 || second > 0xdfff ? str[index] // single character\n    : str.slice(index, index + 2); // two-index characters\n    result.push(char);\n    index += char.length;\n  }\n  return result;\n}\n\n/**\n * Fast version of ts function for when transition defaults are well known\n * @param {State<string>} state\n * @param {string} input\n * @param {string} t\n * @param {string} defaultt\n * @param {[RegExp, State<string>][]} jr\n * @returns {State<string>}\n */\nfunction fastts(state, input, t, defaultt, jr) {\n  let next;\n  const len = input.length;\n  for (let i = 0; i < len - 1; i++) {\n    const char = input[i];\n    if (state.j[char]) {\n      next = state.j[char];\n    } else {\n      next = new State(defaultt);\n      next.jr = jr.slice();\n      state.j[char] = next;\n    }\n    state = next;\n  }\n  next = new State(t);\n  next.jr = jr.slice();\n  state.j[input[len - 1]] = next;\n  return next;\n}\n\n/**\n * Converts a string of Top-Level Domain names encoded in update-tlds.js back\n * into a list of strings.\n * @param {str} encoded encoded TLDs string\n * @returns {str[]} original TLDs list\n */\nfunction decodeTlds(encoded) {\n  const words = [];\n  const stack = [];\n  let i = 0;\n  let digits = '0123456789';\n  while (i < encoded.length) {\n    let popDigitCount = 0;\n    while (digits.indexOf(encoded[i + popDigitCount]) >= 0) {\n      popDigitCount++; // encountered some digits, have to pop to go one level up trie\n    }\n    if (popDigitCount > 0) {\n      words.push(stack.join('')); // whatever preceded the pop digits must be a word\n      for (let popCount = parseInt(encoded.substring(i, i + popDigitCount), 10); popCount > 0; popCount--) {\n        stack.pop();\n      }\n      i += popDigitCount;\n    } else {\n      stack.push(encoded[i]); // drop down a level into the trie\n      i++;\n    }\n  }\n  return words;\n}\n\n/**\n * An object where each key is a valid DOM Event Name such as `click` or `focus`\n * and each value is an event handler function.\n *\n * https://developer.mozilla.org/en-US/docs/Web/API/Element#events\n * @typedef {?{ [event: string]: Function }} EventListeners\n */\n\n/**\n * All formatted properties required to render a link, including `tagName`,\n * `attributes`, `content` and `eventListeners`.\n * @typedef {{ tagName: any, attributes: {[attr: string]: any}, content: string,\n * eventListeners: EventListeners }} IntermediateRepresentation\n */\n\n/**\n * Specify either an object described by the template type `O` or a function.\n *\n * The function takes a string value (usually the link's href attribute), the\n * link type (`'url'`, `'hashtag`', etc.) and an internal token representation\n * of the link. It should return an object of the template type `O`\n * @template O\n * @typedef {O | ((value: string, type: string, token: MultiToken) => O)} OptObj\n */\n\n/**\n * Specify either a function described by template type `F` or an object.\n *\n * Each key in the object should be a link type (`'url'`, `'hashtag`', etc.). Each\n * value should be a function with template type `F` that is called when the\n * corresponding link type is encountered.\n * @template F\n * @typedef {F | { [type: string]: F}} OptFn\n */\n\n/**\n * Specify either a value with template type `V`, a function that returns `V` or\n * an object where each value resolves to `V`.\n *\n * The function takes a string value (usually the link's href attribute), the\n * link type (`'url'`, `'hashtag`', etc.) and an internal token representation\n * of the link. It should return an object of the template type `V`\n *\n * For the object, each key should be a link type (`'url'`, `'hashtag`', etc.).\n * Each value should either have type `V` or a function that returns V. This\n * function similarly takes a string value and a token.\n *\n * Example valid types for `Opt<string>`:\n *\n * ```js\n * 'hello'\n * (value, type, token) => 'world'\n * { url: 'hello', email: (value, token) => 'world'}\n * ```\n * @template V\n * @typedef {V | ((value: string, type: string, token: MultiToken) => V) | { [type: string]: V | ((value: string, token: MultiToken) => V) }} Opt\n */\n\n/**\n * See available options: https://linkify.js.org/docs/options.html\n * @typedef {{\n * \tdefaultProtocol?: string,\n *  events?: OptObj<EventListeners>,\n * \tformat?: Opt<string>,\n * \tformatHref?: Opt<string>,\n * \tnl2br?: boolean,\n * \ttagName?: Opt<any>,\n * \ttarget?: Opt<string>,\n * \trel?: Opt<string>,\n * \tvalidate?: Opt<boolean>,\n * \ttruncate?: Opt<number>,\n * \tclassName?: Opt<string>,\n * \tattributes?: OptObj<({ [attr: string]: any })>,\n *  ignoreTags?: string[],\n * \trender?: OptFn<((ir: IntermediateRepresentation) => any)>\n * }} Opts\n */\n\n/**\n * @type Required<Opts>\n */\nconst defaults = {\n  defaultProtocol: 'http',\n  events: null,\n  format: noop,\n  formatHref: noop,\n  nl2br: false,\n  tagName: 'a',\n  target: null,\n  rel: null,\n  validate: true,\n  truncate: Infinity,\n  className: null,\n  attributes: null,\n  ignoreTags: [],\n  render: null\n};\n\n/**\n * Utility class for linkify interfaces to apply specified\n * {@link Opts formatting and rendering options}.\n *\n * @param {Opts | Options} [opts] Option value overrides.\n * @param {(ir: IntermediateRepresentation) => any} [defaultRender] (For\n *   internal use) default render function that determines how to generate an\n *   HTML element based on a link token's derived tagName, attributes and HTML.\n *   Similar to render option\n */\nfunction Options(opts, defaultRender = null) {\n  let o = Object.assign({}, defaults);\n  if (opts) {\n    o = Object.assign(o, opts instanceof Options ? opts.o : opts);\n  }\n\n  // Ensure all ignored tags are uppercase\n  const ignoredTags = o.ignoreTags;\n  const uppercaseIgnoredTags = [];\n  for (let i = 0; i < ignoredTags.length; i++) {\n    uppercaseIgnoredTags.push(ignoredTags[i].toUpperCase());\n  }\n  /** @protected */\n  this.o = o;\n  if (defaultRender) {\n    this.defaultRender = defaultRender;\n  }\n  this.ignoreTags = uppercaseIgnoredTags;\n}\nOptions.prototype = {\n  o: defaults,\n  /**\n   * @type string[]\n   */\n  ignoreTags: [],\n  /**\n   * @param {IntermediateRepresentation} ir\n   * @returns {any}\n   */\n  defaultRender(ir) {\n    return ir;\n  },\n  /**\n   * Returns true or false based on whether a token should be displayed as a\n   * link based on the user options.\n   * @param {MultiToken} token\n   * @returns {boolean}\n   */\n  check(token) {\n    return this.get('validate', token.toString(), token);\n  },\n  // Private methods\n\n  /**\n   * Resolve an option's value based on the value of the option and the given\n   * params. If operator and token are specified and the target option is\n   * callable, automatically calls the function with the given argument.\n   * @template {keyof Opts} K\n   * @param {K} key Name of option to use\n   * @param {string} [operator] will be passed to the target option if it's a\n   * function. If not specified, RAW function value gets returned\n   * @param {MultiToken} [token] The token from linkify.tokenize\n   * @returns {Opts[K] | any}\n   */\n  get(key, operator, token) {\n    const isCallable = operator != null;\n    let option = this.o[key];\n    if (!option) {\n      return option;\n    }\n    if (typeof option === 'object') {\n      option = token.t in option ? option[token.t] : defaults[key];\n      if (typeof option === 'function' && isCallable) {\n        option = option(operator, token);\n      }\n    } else if (typeof option === 'function' && isCallable) {\n      option = option(operator, token.t, token);\n    }\n    return option;\n  },\n  /**\n   * @template {keyof Opts} L\n   * @param {L} key Name of options object to use\n   * @param {string} [operator]\n   * @param {MultiToken} [token]\n   * @returns {Opts[L] | any}\n   */\n  getObj(key, operator, token) {\n    let obj = this.o[key];\n    if (typeof obj === 'function' && operator != null) {\n      obj = obj(operator, token.t, token);\n    }\n    return obj;\n  },\n  /**\n   * Convert the given token to a rendered element that may be added to the\n   * calling-interface's DOM\n   * @param {MultiToken} token Token to render to an HTML element\n   * @returns {any} Render result; e.g., HTML string, DOM element, React\n   *   Component, etc.\n   */\n  render(token) {\n    const ir = token.render(this); // intermediate representation\n    const renderFn = this.get('render', null, token) || this.defaultRender;\n    return renderFn(ir, token.t, token);\n  }\n};\nfunction noop(val) {\n  return val;\n}\nvar options = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  Options: Options,\n  defaults: defaults\n});\n\n/******************************************************************************\n\tMulti-Tokens\n\tTokens composed of arrays of TextTokens\n******************************************************************************/\n\n/**\n * @param {string} value\n * @param {Token[]} tokens\n */\nfunction MultiToken(value, tokens) {\n  this.t = 'token';\n  this.v = value;\n  this.tk = tokens;\n}\n\n/**\n * Abstract class used for manufacturing tokens of text tokens. That is rather\n * than the value for a token being a small string of text, it's value an array\n * of text tokens.\n *\n * Used for grouping together URLs, emails, hashtags, and other potential\n * creations.\n * @class MultiToken\n * @property {string} t\n * @property {string} v\n * @property {Token[]} tk\n * @abstract\n */\nMultiToken.prototype = {\n  isLink: false,\n  /**\n   * Return the string this token represents.\n   * @return {string}\n   */\n  toString() {\n    return this.v;\n  },\n  /**\n   * What should the value for this token be in the `href` HTML attribute?\n   * Returns the `.toString` value by default.\n   * @param {string} [scheme]\n   * @return {string}\n   */\n  toHref(scheme) {\n    return this.toString();\n  },\n  /**\n   * @param {Options} options Formatting options\n   * @returns {string}\n   */\n  toFormattedString(options) {\n    const val = this.toString();\n    const truncate = options.get('truncate', val, this);\n    const formatted = options.get('format', val, this);\n    return truncate && formatted.length > truncate ? formatted.substring(0, truncate) + '…' : formatted;\n  },\n  /**\n   *\n   * @param {Options} options\n   * @returns {string}\n   */\n  toFormattedHref(options) {\n    return options.get('formatHref', this.toHref(options.get('defaultProtocol')), this);\n  },\n  /**\n   * The start index of this token in the original input string\n   * @returns {number}\n   */\n  startIndex() {\n    return this.tk[0].s;\n  },\n  /**\n   * The end index of this token in the original input string (up to this\n   * index but not including it)\n   * @returns {number}\n   */\n  endIndex() {\n    return this.tk[this.tk.length - 1].e;\n  },\n  /**\n  \tReturns an object  of relevant values for this token, which includes keys\n  \t* type - Kind of token ('url', 'email', etc.)\n  \t* value - Original text\n  \t* href - The value that should be added to the anchor tag's href\n  \t\tattribute\n  \t\t@method toObject\n  \t@param {string} [protocol] `'http'` by default\n  */\n  toObject(protocol = defaults.defaultProtocol) {\n    return {\n      type: this.t,\n      value: this.toString(),\n      isLink: this.isLink,\n      href: this.toHref(protocol),\n      start: this.startIndex(),\n      end: this.endIndex()\n    };\n  },\n  /**\n   *\n   * @param {Options} options Formatting option\n   */\n  toFormattedObject(options) {\n    return {\n      type: this.t,\n      value: this.toFormattedString(options),\n      isLink: this.isLink,\n      href: this.toFormattedHref(options),\n      start: this.startIndex(),\n      end: this.endIndex()\n    };\n  },\n  /**\n   * Whether this token should be rendered as a link according to the given options\n   * @param {Options} options\n   * @returns {boolean}\n   */\n  validate(options) {\n    return options.get('validate', this.toString(), this);\n  },\n  /**\n   * Return an object that represents how this link should be rendered.\n   * @param {Options} options Formattinng options\n   */\n  render(options) {\n    const token = this;\n    const href = this.toHref(options.get('defaultProtocol'));\n    const formattedHref = options.get('formatHref', href, this);\n    const tagName = options.get('tagName', href, token);\n    const content = this.toFormattedString(options);\n    const attributes = {};\n    const className = options.get('className', href, token);\n    const target = options.get('target', href, token);\n    const rel = options.get('rel', href, token);\n    const attrs = options.getObj('attributes', href, token);\n    const eventListeners = options.getObj('events', href, token);\n    attributes.href = formattedHref;\n    if (className) {\n      attributes.class = className;\n    }\n    if (target) {\n      attributes.target = target;\n    }\n    if (rel) {\n      attributes.rel = rel;\n    }\n    if (attrs) {\n      Object.assign(attributes, attrs);\n    }\n    return {\n      tagName,\n      attributes,\n      content,\n      eventListeners\n    };\n  }\n};\n\n/**\n * Create a new token that can be emitted by the parser state machine\n * @param {string} type readable type of the token\n * @param {object} props properties to assign or override, including isLink = true or false\n * @returns {new (value: string, tokens: Token[]) => MultiToken} new token class\n */\nfunction createTokenClass(type, props) {\n  class Token extends MultiToken {\n    constructor(value, tokens) {\n      super(value, tokens);\n      this.t = type;\n    }\n  }\n  for (const p in props) {\n    Token.prototype[p] = props[p];\n  }\n  Token.t = type;\n  return Token;\n}\n\n/**\n\tRepresents a list of tokens making up a valid email address\n*/\nconst Email = createTokenClass('email', {\n  isLink: true,\n  toHref() {\n    return 'mailto:' + this.toString();\n  }\n});\n\n/**\n\tRepresents some plain text\n*/\nconst Text = createTokenClass('text');\n\n/**\n\tMulti-linebreak token - represents a line break\n\t@class Nl\n*/\nconst Nl = createTokenClass('nl');\n\n/**\n\tRepresents a list of text tokens making up a valid URL\n\t@class Url\n*/\nconst Url = createTokenClass('url', {\n  isLink: true,\n  /**\n  \tLowercases relevant parts of the domain and adds the protocol if\n  \trequired. Note that this will not escape unsafe HTML characters in the\n  \tURL.\n  \t\t@param {string} [scheme] default scheme (e.g., 'https')\n  \t@return {string} the full href\n  */\n  toHref(scheme = defaults.defaultProtocol) {\n    // Check if already has a prefix scheme\n    return this.hasProtocol() ? this.v : `${scheme}://${this.v}`;\n  },\n  /**\n   * Check whether this URL token has a protocol\n   * @return {boolean}\n   */\n  hasProtocol() {\n    const tokens = this.tk;\n    return tokens.length >= 2 && tokens[0].t !== LOCALHOST && tokens[1].t === COLON;\n  }\n});\nvar multi = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  Base: MultiToken,\n  Email: Email,\n  MultiToken: MultiToken,\n  Nl: Nl,\n  Text: Text,\n  Url: Url,\n  createTokenClass: createTokenClass\n});\n\n/**\n\tNot exactly parser, more like the second-stage scanner (although we can\n\ttheoretically hotswap the code here with a real parser in the future... but\n\tfor a little URL-finding utility abstract syntax trees may be a little\n\toverkill).\n\n\tURL format: http://en.wikipedia.org/wiki/URI_scheme\n\tEmail format: http://en.wikipedia.org/wiki/EmailAddress (links to RFC in\n\treference)\n\n\t@module linkify\n\t@submodule parser\n\t@main run\n*/\n\nconst makeState = arg => new State(arg);\n\n/**\n * Generate the parser multi token-based state machine\n * @param {{ groups: Collections<string> }} tokens\n */\nfunction init$1({\n  groups\n}) {\n  // Types of characters the URL can definitely end in\n  const qsAccepting = groups.domain.concat([AMPERSAND, ASTERISK, AT, BACKSLASH, BACKTICK, CARET, DOLLAR, EQUALS, HYPHEN, NUM, PERCENT, PIPE, PLUS, POUND, SLASH, SYM, TILDE, UNDERSCORE]);\n\n  // Types of tokens that can follow a URL and be part of the query string\n  // but cannot be the very last characters\n  // Characters that cannot appear in the URL at all should be excluded\n  const qsNonAccepting = [APOSTROPHE, COLON, COMMA, DOT, EXCLAMATION, PERCENT, QUERY, QUOTE, SEMI, OPENANGLEBRACKET, CLOSEANGLEBRACKET, OPENBRACE, CLOSEBRACE, CLOSEBRACKET, OPENBRACKET, OPENPAREN, CLOSEPAREN, FULLWIDTHLEFTPAREN, FULLWIDTHRIGHTPAREN, LEFTCORNERBRACKET, RIGHTCORNERBRACKET, LEFTWHITECORNERBRACKET, RIGHTWHITECORNERBRACKET, FULLWIDTHLESSTHAN, FULLWIDTHGREATERTHAN];\n\n  // For addresses without the mailto prefix\n  // Tokens allowed in the localpart of the email\n  const localpartAccepting = [AMPERSAND, APOSTROPHE, ASTERISK, BACKSLASH, BACKTICK, CARET, DOLLAR, EQUALS, HYPHEN, OPENBRACE, CLOSEBRACE, PERCENT, PIPE, PLUS, POUND, QUERY, SLASH, SYM, TILDE, UNDERSCORE];\n\n  // The universal starting state.\n  /**\n   * @type State<Token>\n   */\n  const Start = makeState();\n  const Localpart = tt(Start, TILDE); // Local part of the email address\n  ta(Localpart, localpartAccepting, Localpart);\n  ta(Localpart, groups.domain, Localpart);\n  const Domain = makeState(),\n    Scheme = makeState(),\n    SlashScheme = makeState();\n  ta(Start, groups.domain, Domain); // parsed string ends with a potential domain name (A)\n  ta(Start, groups.scheme, Scheme); // e.g., 'mailto'\n  ta(Start, groups.slashscheme, SlashScheme); // e.g., 'http'\n\n  ta(Domain, localpartAccepting, Localpart);\n  ta(Domain, groups.domain, Domain);\n  const LocalpartAt = tt(Domain, AT); // Local part of the email address plus @\n\n  tt(Localpart, AT, LocalpartAt); // close to an email address now\n\n  // Local part of an email address can be e.g. 'http' or 'mailto'\n  tt(Scheme, AT, LocalpartAt);\n  tt(SlashScheme, AT, LocalpartAt);\n  const LocalpartDot = tt(Localpart, DOT); // Local part of the email address plus '.' (localpart cannot end in .)\n  ta(LocalpartDot, localpartAccepting, Localpart);\n  ta(LocalpartDot, groups.domain, Localpart);\n  const EmailDomain = makeState();\n  ta(LocalpartAt, groups.domain, EmailDomain); // parsed string starts with local email info + @ with a potential domain name\n  ta(EmailDomain, groups.domain, EmailDomain);\n  const EmailDomainDot = tt(EmailDomain, DOT); // domain followed by DOT\n  ta(EmailDomainDot, groups.domain, EmailDomain);\n  const Email$1 = makeState(Email); // Possible email address (could have more tlds)\n  ta(EmailDomainDot, groups.tld, Email$1);\n  ta(EmailDomainDot, groups.utld, Email$1);\n  tt(LocalpartAt, LOCALHOST, Email$1);\n\n  // Hyphen can jump back to a domain name\n  const EmailDomainHyphen = tt(EmailDomain, HYPHEN); // parsed string starts with local email info + @ with a potential domain name\n  tt(EmailDomainHyphen, HYPHEN, EmailDomainHyphen);\n  ta(EmailDomainHyphen, groups.domain, EmailDomain);\n  ta(Email$1, groups.domain, EmailDomain);\n  tt(Email$1, DOT, EmailDomainDot);\n  tt(Email$1, HYPHEN, EmailDomainHyphen);\n\n  // Final possible email states\n  const EmailColon = tt(Email$1, COLON); // URL followed by colon (potential port number here)\n  /*const EmailColonPort = */\n  ta(EmailColon, groups.numeric, Email); // URL followed by colon and port number\n\n  // Account for dots and hyphens. Hyphens are usually parts of domain names\n  // (but not TLDs)\n  const DomainHyphen = tt(Domain, HYPHEN); // domain followed by hyphen\n  const DomainDot = tt(Domain, DOT); // domain followed by DOT\n  tt(DomainHyphen, HYPHEN, DomainHyphen);\n  ta(DomainHyphen, groups.domain, Domain);\n  ta(DomainDot, localpartAccepting, Localpart);\n  ta(DomainDot, groups.domain, Domain);\n  const DomainDotTld = makeState(Url); // Simplest possible URL with no query string\n  ta(DomainDot, groups.tld, DomainDotTld);\n  ta(DomainDot, groups.utld, DomainDotTld);\n  ta(DomainDotTld, groups.domain, Domain);\n  ta(DomainDotTld, localpartAccepting, Localpart);\n  tt(DomainDotTld, DOT, DomainDot);\n  tt(DomainDotTld, HYPHEN, DomainHyphen);\n  tt(DomainDotTld, AT, LocalpartAt);\n  const DomainDotTldColon = tt(DomainDotTld, COLON); // URL followed by colon (potential port number here)\n  const DomainDotTldColonPort = makeState(Url); // TLD followed by a port number\n  ta(DomainDotTldColon, groups.numeric, DomainDotTldColonPort);\n\n  // Long URL with optional port and maybe query string\n  const Url$1 = makeState(Url);\n\n  // URL with extra symbols at the end, followed by an opening bracket\n  const UrlNonaccept = makeState(); // URL followed by some symbols (will not be part of the final URL)\n\n  // Query strings\n  ta(Url$1, qsAccepting, Url$1);\n  ta(Url$1, qsNonAccepting, UrlNonaccept);\n  ta(UrlNonaccept, qsAccepting, Url$1);\n  ta(UrlNonaccept, qsNonAccepting, UrlNonaccept);\n\n  // Become real URLs after `SLASH` or `COLON NUM SLASH`\n  // Here works with or without scheme:// prefix\n  tt(DomainDotTld, SLASH, Url$1);\n  tt(DomainDotTldColonPort, SLASH, Url$1);\n\n  // Note that domains that begin with schemes are treated slighly differently\n  const SchemeColon = tt(Scheme, COLON); // e.g., 'mailto:'\n  const SlashSchemeColon = tt(SlashScheme, COLON); // e.g., 'http:'\n  const SlashSchemeColonSlash = tt(SlashSchemeColon, SLASH); // e.g., 'http:/'\n\n  const UriPrefix = tt(SlashSchemeColonSlash, SLASH); // e.g., 'http://'\n\n  // Scheme states can transition to domain states\n  ta(Scheme, groups.domain, Domain);\n  tt(Scheme, DOT, DomainDot);\n  tt(Scheme, HYPHEN, DomainHyphen);\n  ta(SlashScheme, groups.domain, Domain);\n  tt(SlashScheme, DOT, DomainDot);\n  tt(SlashScheme, HYPHEN, DomainHyphen);\n\n  // Force URL with scheme prefix followed by anything sane\n  ta(SchemeColon, groups.domain, Url$1);\n  tt(SchemeColon, SLASH, Url$1);\n  tt(SchemeColon, QUERY, Url$1);\n  ta(UriPrefix, groups.domain, Url$1);\n  ta(UriPrefix, qsAccepting, Url$1);\n  tt(UriPrefix, SLASH, Url$1);\n  const bracketPairs = [[OPENBRACE, CLOSEBRACE],\n  // {}\n  [OPENBRACKET, CLOSEBRACKET],\n  // []\n  [OPENPAREN, CLOSEPAREN],\n  // ()\n  [OPENANGLEBRACKET, CLOSEANGLEBRACKET],\n  // <>\n  [FULLWIDTHLEFTPAREN, FULLWIDTHRIGHTPAREN],\n  // （）\n  [LEFTCORNERBRACKET, RIGHTCORNERBRACKET],\n  // 「」\n  [LEFTWHITECORNERBRACKET, RIGHTWHITECORNERBRACKET],\n  // 『』\n  [FULLWIDTHLESSTHAN, FULLWIDTHGREATERTHAN] // ＜＞\n  ];\n  for (let i = 0; i < bracketPairs.length; i++) {\n    const [OPEN, CLOSE] = bracketPairs[i];\n    const UrlOpen = tt(Url$1, OPEN); // URL followed by open bracket\n\n    // Continue not accepting for open brackets\n    tt(UrlNonaccept, OPEN, UrlOpen);\n\n    // Closing bracket component. This character WILL be included in the URL\n    tt(UrlOpen, CLOSE, Url$1);\n\n    // URL that beings with an opening bracket, followed by a symbols.\n    // Note that the final state can still be `UrlOpen` (if the URL has a\n    // single opening bracket for some reason).\n    const UrlOpenQ = makeState(Url);\n    ta(UrlOpen, qsAccepting, UrlOpenQ);\n    const UrlOpenSyms = makeState(); // UrlOpen followed by some symbols it cannot end it\n    ta(UrlOpen, qsNonAccepting);\n\n    // URL that begins with an opening bracket, followed by some symbols\n    ta(UrlOpenQ, qsAccepting, UrlOpenQ);\n    ta(UrlOpenQ, qsNonAccepting, UrlOpenSyms);\n    ta(UrlOpenSyms, qsAccepting, UrlOpenQ);\n    ta(UrlOpenSyms, qsNonAccepting, UrlOpenSyms);\n\n    // Close brace/bracket to become regular URL\n    tt(UrlOpenQ, CLOSE, Url$1);\n    tt(UrlOpenSyms, CLOSE, Url$1);\n  }\n  tt(Start, LOCALHOST, DomainDotTld); // localhost is a valid URL state\n  tt(Start, NL, Nl); // single new line\n\n  return {\n    start: Start,\n    tokens: tk\n  };\n}\n\n/**\n * Run the parser state machine on a list of scanned string-based tokens to\n * create a list of multi tokens, each of which represents a URL, email address,\n * plain text, etc.\n *\n * @param {State<MultiToken>} start parser start state\n * @param {string} input the original input used to generate the given tokens\n * @param {Token[]} tokens list of scanned tokens\n * @returns {MultiToken[]}\n */\nfunction run(start, input, tokens) {\n  let len = tokens.length;\n  let cursor = 0;\n  let multis = [];\n  let textTokens = [];\n  while (cursor < len) {\n    let state = start;\n    let secondState = null;\n    let nextState = null;\n    let multiLength = 0;\n    let latestAccepting = null;\n    let sinceAccepts = -1;\n    while (cursor < len && !(secondState = state.go(tokens[cursor].t))) {\n      // Starting tokens with nowhere to jump to.\n      // Consider these to be just plain text\n      textTokens.push(tokens[cursor++]);\n    }\n    while (cursor < len && (nextState = secondState || state.go(tokens[cursor].t))) {\n      // Get the next state\n      secondState = null;\n      state = nextState;\n\n      // Keep track of the latest accepting state\n      if (state.accepts()) {\n        sinceAccepts = 0;\n        latestAccepting = state;\n      } else if (sinceAccepts >= 0) {\n        sinceAccepts++;\n      }\n      cursor++;\n      multiLength++;\n    }\n    if (sinceAccepts < 0) {\n      // No accepting state was found, part of a regular text token add\n      // the first text token to the text tokens array and try again from\n      // the next\n      cursor -= multiLength;\n      if (cursor < len) {\n        textTokens.push(tokens[cursor]);\n        cursor++;\n      }\n    } else {\n      // Accepting state!\n      // First close off the textTokens (if available)\n      if (textTokens.length > 0) {\n        multis.push(initMultiToken(Text, input, textTokens));\n        textTokens = [];\n      }\n\n      // Roll back to the latest accepting state\n      cursor -= sinceAccepts;\n      multiLength -= sinceAccepts;\n\n      // Create a new multitoken\n      const Multi = latestAccepting.t;\n      const subtokens = tokens.slice(cursor - multiLength, cursor);\n      multis.push(initMultiToken(Multi, input, subtokens));\n    }\n  }\n\n  // Finally close off the textTokens (if available)\n  if (textTokens.length > 0) {\n    multis.push(initMultiToken(Text, input, textTokens));\n  }\n  return multis;\n}\n\n/**\n * Utility function for instantiating a new multitoken with all the relevant\n * fields during parsing.\n * @param {new (value: string, tokens: Token[]) => MultiToken} Multi class to instantiate\n * @param {string} input original input string\n * @param {Token[]} tokens consecutive tokens scanned from input string\n * @returns {MultiToken}\n */\nfunction initMultiToken(Multi, input, tokens) {\n  const startIdx = tokens[0].s;\n  const endIdx = tokens[tokens.length - 1].e;\n  const value = input.slice(startIdx, endIdx);\n  return new Multi(value, tokens);\n}\nconst warn = typeof console !== 'undefined' && console && console.warn || (() => {});\nconst warnAdvice = 'until manual call of linkify.init(). Register all schemes and plugins before invoking linkify the first time.';\n\n// Side-effect initialization state\nconst INIT = {\n  scanner: null,\n  parser: null,\n  tokenQueue: [],\n  pluginQueue: [],\n  customSchemes: [],\n  initialized: false\n};\n\n/**\n * @typedef {{\n * \tstart: State<string>,\n * \ttokens: { groups: Collections<string> } & typeof tk\n * }} ScannerInit\n */\n\n/**\n * @typedef {{\n * \tstart: State<MultiToken>,\n * \ttokens: typeof multi\n * }} ParserInit\n */\n\n/**\n * @typedef {(arg: { scanner: ScannerInit }) => void} TokenPlugin\n */\n\n/**\n * @typedef {(arg: { scanner: ScannerInit, parser: ParserInit }) => void} Plugin\n */\n\n/**\n * De-register all plugins and reset the internal state-machine. Used for\n * testing; not required in practice.\n * @private\n */\nfunction reset() {\n  State.groups = {};\n  INIT.scanner = null;\n  INIT.parser = null;\n  INIT.tokenQueue = [];\n  INIT.pluginQueue = [];\n  INIT.customSchemes = [];\n  INIT.initialized = false;\n  return INIT;\n}\n\n/**\n * Register a token plugin to allow the scanner to recognize additional token\n * types before the parser state machine is constructed from the results.\n * @param {string} name of plugin to register\n * @param {TokenPlugin} plugin function that accepts the scanner state machine\n * and available scanner tokens and collections and extends the state machine to\n * recognize additional tokens or groups.\n */\nfunction registerTokenPlugin(name, plugin) {\n  if (typeof plugin !== 'function') {\n    throw new Error(`linkifyjs: Invalid token plugin ${plugin} (expects function)`);\n  }\n  for (let i = 0; i < INIT.tokenQueue.length; i++) {\n    if (name === INIT.tokenQueue[i][0]) {\n      warn(`linkifyjs: token plugin \"${name}\" already registered - will be overwritten`);\n      INIT.tokenQueue[i] = [name, plugin];\n      return;\n    }\n  }\n  INIT.tokenQueue.push([name, plugin]);\n  if (INIT.initialized) {\n    warn(`linkifyjs: already initialized - will not register token plugin \"${name}\" ${warnAdvice}`);\n  }\n}\n\n/**\n * Register a linkify plugin\n * @param {string} name of plugin to register\n * @param {Plugin} plugin function that accepts the parser state machine and\n * extends the parser to recognize additional link types\n */\nfunction registerPlugin(name, plugin) {\n  if (typeof plugin !== 'function') {\n    throw new Error(`linkifyjs: Invalid plugin ${plugin} (expects function)`);\n  }\n  for (let i = 0; i < INIT.pluginQueue.length; i++) {\n    if (name === INIT.pluginQueue[i][0]) {\n      warn(`linkifyjs: plugin \"${name}\" already registered - will be overwritten`);\n      INIT.pluginQueue[i] = [name, plugin];\n      return;\n    }\n  }\n  INIT.pluginQueue.push([name, plugin]);\n  if (INIT.initialized) {\n    warn(`linkifyjs: already initialized - will not register plugin \"${name}\" ${warnAdvice}`);\n  }\n}\n\n/**\n * Detect URLs with the following additional protocol. Anything with format\n * \"protocol://...\" will be considered a link. If `optionalSlashSlash` is set to\n * `true`, anything with format \"protocol:...\" will be considered a link.\n * @param {string} scheme\n * @param {boolean} [optionalSlashSlash]\n */\nfunction registerCustomProtocol(scheme, optionalSlashSlash = false) {\n  if (INIT.initialized) {\n    warn(`linkifyjs: already initialized - will not register custom scheme \"${scheme}\" ${warnAdvice}`);\n  }\n  if (!/^[0-9a-z]+(-[0-9a-z]+)*$/.test(scheme)) {\n    throw new Error(`linkifyjs: incorrect scheme format.\n1. Must only contain digits, lowercase ASCII letters or \"-\"\n2. Cannot start or end with \"-\"\n3. \"-\" cannot repeat`);\n  }\n  INIT.customSchemes.push([scheme, optionalSlashSlash]);\n}\n\n/**\n * Initialize the linkify state machine. Called automatically the first time\n * linkify is called on a string, but may be called manually as well.\n */\nfunction init() {\n  // Initialize scanner state machine and plugins\n  INIT.scanner = init$2(INIT.customSchemes);\n  for (let i = 0; i < INIT.tokenQueue.length; i++) {\n    INIT.tokenQueue[i][1]({\n      scanner: INIT.scanner\n    });\n  }\n\n  // Initialize parser state machine and plugins\n  INIT.parser = init$1(INIT.scanner.tokens);\n  for (let i = 0; i < INIT.pluginQueue.length; i++) {\n    INIT.pluginQueue[i][1]({\n      scanner: INIT.scanner,\n      parser: INIT.parser\n    });\n  }\n  INIT.initialized = true;\n  return INIT;\n}\n\n/**\n * Parse a string into tokens that represent linkable and non-linkable sub-components\n * @param {string} str\n * @return {MultiToken[]} tokens\n */\nfunction tokenize(str) {\n  if (!INIT.initialized) {\n    init();\n  }\n  return run(INIT.parser.start, str, run$1(INIT.scanner.start, str));\n}\ntokenize.scan = run$1; // for testing\n\n/**\n * Find a list of linkable items in the given string.\n * @param {string} str string to find links in\n * @param {string | Opts} [type] either formatting options or specific type of\n * links to find, e.g., 'url' or 'email'\n * @param {Opts} [opts] formatting options for final output. Cannot be specified\n * if opts already provided in `type` argument\n */\nfunction find(str, type = null, opts = null) {\n  if (type && typeof type === 'object') {\n    if (opts) {\n      throw Error(`linkifyjs: Invalid link type ${type}; must be a string`);\n    }\n    opts = type;\n    type = null;\n  }\n  const options = new Options(opts);\n  const tokens = tokenize(str);\n  const filtered = [];\n  for (let i = 0; i < tokens.length; i++) {\n    const token = tokens[i];\n    if (token.isLink && (!type || token.t === type) && options.check(token)) {\n      filtered.push(token.toFormattedObject(options));\n    }\n  }\n  return filtered;\n}\n\n/**\n * Is the given string valid linkable text of some sort. Note that this does not\n * trim the text for you.\n *\n * Optionally pass in a second `type` param, which is the type of link to test\n * for.\n *\n * For example,\n *\n *     linkify.test(str, 'email');\n *\n * Returns `true` if str is a valid email.\n * @param {string} str string to test for links\n * @param {string} [type] optional specific link type to look for\n * @returns boolean true/false\n */\nfunction test(str, type = null) {\n  const tokens = tokenize(str);\n  return tokens.length === 1 && tokens[0].isLink && (!type || tokens[0].t === type);\n}\nexport { MultiToken, Options, State, createTokenClass, find, init, multi, options, regexp, registerCustomProtocol, registerPlugin, registerTokenPlugin, reset, stringToArray, test, multi as text, tokenize };","map":{"version":3,"names":["encodedTlds","encodedUtlds","numeric","ascii","alpha","asciinumeric","alphanumeric","domain","emoji","scheme","slashscheme","whitespace","registerGroup","name","groups","addToGroups","t","flags","k","group","indexOf","push","flagsForToken","result","c","State","token","j","jr","jd","prototype","accepts","go","input","state","nextState","i","length","regex","test","has","exactOnly","ta","inputs","next","tt","tr","regexp","ts","len","templateState","Object","assign","apply","allFlags","WORD","UWORD","ASCIINUMERICAL","ALPHANUMERICAL","LOCALHOST","TLD","UTLD","SCHEME","SLASH_SCHEME","NUM","WS","NL","OPENBRACE","CLOSEBRACE","OPENBRACKET","CLOSEBRACKET","OPENPAREN","CLOSEPAREN","OPENANGLEBRACKET","CLOSEANGLEBRACKET","FULLWIDTHLEFTPAREN","FULLWIDTHRIGHTPAREN","LEFTCORNERBRACKET","RIGHTCORNERBRACKET","LEFTWHITECORNERBRACKET","RIGHTWHITECORNERBRACKET","FULLWIDTHLESSTHAN","FULLWIDTHGREATERTHAN","AMPERSAND","APOSTROPHE","ASTERISK","AT","BACKSLASH","BACKTICK","CARET","COLON","COMMA","DOLLAR","DOT","EQUALS","EXCLAMATION","HYPHEN","PERCENT","PIPE","PLUS","POUND","QUERY","QUOTE","FULLWIDTHMIDDLEDOT","SEMI","SLASH","TILDE","UNDERSCORE","EMOJI$1","SYM","tk","freeze","__proto__","EMOJI","ASCII_LETTER","LETTER","EMOJI_VARIATION$1","DIGIT","SPACE","EMOJI_VARIATION","CR","LF","EMOJI_JOINER","OBJECT_REPLACEMENT","tlds","utlds","init$2","customSchemes","Start","decodeTlds","Num","Asciinumeric","Alphanumeric","Word","UWord","Nl","Cr","Ws","Emoji","EmojiJoiner","wordjr","uwordjr","fastts","tld","utld","sort","a","b","sch","optionalSlashSlash","start","tokens","run$1","str","iterable","stringToArray","replace","toLowerCase","charCount","cursor","charCursor","tokenLength","latestAccepting","sinceAccepts","charsSinceAccepts","v","slice","s","e","index","first","charCodeAt","second","char","defaultt","encoded","words","stack","digits","popDigitCount","join","popCount","parseInt","substring","pop","defaults","defaultProtocol","events","format","noop","formatHref","nl2br","tagName","target","rel","validate","truncate","Infinity","className","attributes","ignoreTags","render","Options","opts","defaultRender","o","ignoredTags","uppercaseIgnoredTags","toUpperCase","ir","check","get","toString","key","operator","isCallable","option","getObj","obj","renderFn","val","options","MultiToken","value","isLink","toHref","toFormattedString","formatted","toFormattedHref","startIndex","endIndex","toObject","protocol","type","href","end","toFormattedObject","formattedHref","content","attrs","eventListeners","class","createTokenClass","props","Token","constructor","p","Email","Text","Url","hasProtocol","multi","Base","makeState","arg","init$1","qsAccepting","concat","qsNonAccepting","localpartAccepting","Localpart","Domain","Scheme","SlashScheme","LocalpartAt","LocalpartDot","EmailDomain","EmailDomainDot","Email$1","EmailDomainHyphen","EmailColon","DomainHyphen","DomainDot","DomainDotTld","DomainDotTldColon","DomainDotTldColonPort","Url$1","UrlNonaccept","SchemeColon","SlashSchemeColon","SlashSchemeColonSlash","UriPrefix","bracketPairs","OPEN","CLOSE","UrlOpen","UrlOpenQ","UrlOpenSyms","run","multis","textTokens","secondState","multiLength","initMultiToken","Multi","subtokens","startIdx","endIdx","warn","console","warnAdvice","INIT","scanner","parser","tokenQueue","pluginQueue","initialized","reset","registerTokenPlugin","plugin","Error","registerPlugin","registerCustomProtocol","init","tokenize","scan","find","filtered","text"],"sources":["D:/diarry me/node_modules/linkifyjs/dist/linkify.mjs"],"sourcesContent":["// THIS FILE IS AUTOMATICALLY GENERATED DO NOT EDIT DIRECTLY\n// See update-tlds.js for encoding/decoding format\n// https://data.iana.org/TLD/tlds-alpha-by-domain.txt\nconst encodedTlds = 'aaa1rp3bb0ott3vie4c1le2ogado5udhabi7c0ademy5centure6ountant0s9o1tor4d0s1ult4e0g1ro2tna4f0l1rica5g0akhan5ency5i0g1rbus3force5tel5kdn3l0ibaba4pay4lfinanz6state5y2sace3tom5m0azon4ericanexpress7family11x2fam3ica3sterdam8nalytics7droid5quan4z2o0l2partments8p0le4q0uarelle8r0ab1mco4chi3my2pa2t0e3s0da2ia2sociates9t0hleta5torney7u0ction5di0ble3o3spost5thor3o0s4w0s2x0a2z0ure5ba0by2idu3namex4d1k2r0celona5laycard4s5efoot5gains6seball5ketball8uhaus5yern5b0c1t1va3cg1n2d1e0ats2uty4er2rlin4st0buy5t2f1g1h0arti5i0ble3d1ke2ng0o3o1z2j1lack0friday9ockbuster8g1omberg7ue3m0s1w2n0pparibas9o0ats3ehringer8fa2m1nd2o0k0ing5sch2tik2on4t1utique6x2r0adesco6idgestone9oadway5ker3ther5ussels7s1t1uild0ers6siness6y1zz3v1w1y1z0h3ca0b1fe2l0l1vinklein9m0era3p2non3petown5ital0one8r0avan4ds2e0er0s4s2sa1e1h1ino4t0ering5holic7ba1n1re3c1d1enter4o1rn3f0a1d2g1h0anel2nel4rity4se2t2eap3intai5ristmas6ome4urch5i0priani6rcle4sco3tadel4i0c2y3k1l0aims4eaning6ick2nic1que6othing5ud3ub0med6m1n1o0ach3des3ffee4llege4ogne5m0mbank4unity6pany2re3uter5sec4ndos3struction8ulting7tact3ractors9oking4l1p2rsica5untry4pon0s4rses6pa2r0edit0card4union9icket5own3s1uise0s6u0isinella9v1w1x1y0mru3ou3z2dad1nce3ta1e1ing3sun4y2clk3ds2e0al0er2s3gree4livery5l1oitte5ta3mocrat6ntal2ist5si0gn4v2hl2iamonds6et2gital5rect0ory7scount3ver5h2y2j1k1m1np2o0cs1tor4g1mains5t1wnload7rive4tv2ubai3nlop4pont4rban5vag2r2z2earth3t2c0o2deka3u0cation8e1g1mail3erck5nergy4gineer0ing9terprises10pson4quipment8r0icsson6ni3s0q1tate5t1u0rovision8s2vents5xchange6pert3osed4ress5traspace10fage2il1rwinds6th3mily4n0s2rm0ers5shion4t3edex3edback6rrari3ero6i0delity5o2lm2nal1nce1ial7re0stone6mdale6sh0ing5t0ness6j1k1lickr3ghts4r2orist4wers5y2m1o0o0d1tball6rd1ex2sale4um3undation8x2r0ee1senius7l1ogans4ntier7tr2ujitsu5n0d2rniture7tbol5yi3ga0l0lery3o1up4me0s3p1rden4y2b0iz3d0n2e0a1nt0ing5orge5f1g0ee3h1i0ft0s3ves2ing5l0ass3e1obal2o4m0ail3bh2o1x2n1odaddy5ld0point6f2o0dyear5g0le4p1t1v2p1q1r0ainger5phics5tis4een3ipe3ocery4up4s1t1u0cci3ge2ide2tars5ru3w1y2hair2mburg5ngout5us3bo2dfc0bank7ealth0care8lp1sinki6re1mes5iphop4samitsu7tachi5v2k0t2m1n1ockey4ldings5iday5medepot5goods5s0ense7nda3rse3spital5t0ing5t0els3mail5use3w2r1sbc3t1u0ghes5yatt3undai7ibm2cbc2e1u2d1e0ee3fm2kano4l1m0amat4db2mo0bilien9n0c1dustries8finiti5o2g1k1stitute6urance4e4t0ernational10uit4vestments10o1piranga7q1r0ish4s0maili5t0anbul7t0au2v3jaguar4va3cb2e0ep2tzt3welry6io2ll2m0p2nj2o0bs1urg4t1y2p0morgan6rs3uegos4niper7kaufen5ddi3e0rryhotels6properties14fh2g1h1i0a1ds2m1ndle4tchen5wi3m1n1oeln3matsu5sher5p0mg2n2r0d1ed3uokgroup8w1y0oto4z2la0caixa5mborghini8er3nd0rover6xess5salle5t0ino3robe5w0yer5b1c1ds2ease3clerc5frak4gal2o2xus4gbt3i0dl2fe0insurance9style7ghting6ke2lly3mited4o2ncoln4k2ve1ing5k1lc1p2oan0s3cker3us3l1ndon4tte1o3ve3pl0financial11r1s1t0d0a3u0ndbeck6xe1ury5v1y2ma0drid4if1son4keup4n0agement7go3p1rket0ing3s4riott5shalls7ttel5ba2c0kinsey7d1e0d0ia3et2lbourne7me1orial6n0u2rckmsd7g1h1iami3crosoft7l1ni1t2t0subishi9k1l0b1s2m0a2n1o0bi0le4da2e1i1m1nash3ey2ster5rmon3tgage6scow4to0rcycles9v0ie4p1q1r1s0d2t0n1r2u0seum3ic4v1w1x1y1z2na0b1goya4me2vy3ba2c1e0c1t0bank4flix4work5ustar5w0s2xt0direct7us4f0l2g0o2hk2i0co2ke1on3nja3ssan1y5l1o0kia3rton4w0ruz3tv4p1r0a1w2tt2u1yc2z2obi1server7ffice5kinawa6layan0group9lo3m0ega4ne1g1l0ine5oo2pen3racle3nge4g0anic5igins6saka4tsuka4t2vh3pa0ge2nasonic7ris2s1tners4s1y3y2ccw3e0t2f0izer5g1h0armacy6d1ilips5one2to0graphy6s4ysio5ics1tet2ures6d1n0g1k2oneer5zza4k1l0ace2y0station9umbing5s3m1n0c2ohl2ker3litie5rn2st3r0axi3ess3ime3o0d0uctions8f1gressive8mo2perties3y5tection8u0dential9s1t1ub2w0c2y2qa1pon3uebec3st5racing4dio4e0ad1lestate6tor2y4cipes5d0stone5umbrella9hab3ise0n3t2liance6n0t0als5pair3ort3ublican8st0aurant8view0s5xroth6ich0ardli6oh3l1o1p2o0cks3deo3gers4om3s0vp3u0gby3hr2n2w0e2yukyu6sa0arland6fe0ty4kura4le1on3msclub4ung5ndvik0coromant12ofi4p1rl2s1ve2xo3b0i1s2c0b1haeffler7midt4olarships8ol3ule3warz5ience5ot3d1e0arch3t2cure1ity6ek2lect4ner3rvices6ven3w1x0y3fr2g1h0angrila6rp3ell3ia1ksha5oes2p0ping5uji3w3i0lk2na1gles5te3j1k0i0n2y0pe4l0ing4m0art3ile4n0cf3o0ccer3ial4ftbank4ware6hu2lar2utions7ng1y2y2pa0ce3ort2t3r0l2s1t0ada2ples4r1tebank4farm7c0group6ockholm6rage3e3ream4udio2y3yle4u0cks3pplies3y2ort5rf1gery5zuki5v1watch4iss4x1y0dney4stems6z2tab1ipei4lk2obao4rget4tamotors6r2too4x0i3c0i2d0k2eam2ch0nology8l1masek5nnis4va3f1g1h0d1eater2re6iaa2ckets5enda4ps2res2ol4j0maxx4x2k0maxx5l1m0all4n1o0day3kyo3ols3p1ray3shiba5tal3urs3wn2yota3s3r0ade1ing4ining5vel0ers0insurance16ust3v2t1ube2i1nes3shu4v0s2w1z2ua1bank3s2g1k1nicom3versity8o2ol2ps2s1y1z2va0cations7na1guard7c1e0gas3ntures6risign5mögensberater2ung14sicherung10t2g1i0ajes4deo3g1king4llas4n1p1rgin4sa1ion4va1o3laanderen9n1odka3lvo3te1ing3o2yage5u2wales2mart4ter4ng0gou5tch0es6eather0channel12bcam3er2site5d0ding5ibo2r3f1hoswho6ien2ki2lliamhill9n0dows4e1ners6me2olterskluwer11odside6rk0s2ld3w2s1tc1f3xbox3erox4ihuan4n2xx2yz3yachts4hoo3maxun5ndex5e1odobashi7ga2kohama6u0tube6t1un3za0ppos4ra3ero3ip2m1one3uerich6w2';\n// Internationalized domain names containing non-ASCII\nconst encodedUtlds = 'ελ1υ2бг1ел3дети4ею2католик6ом3мкд2он1сква6онлайн5рг3рус2ф2сайт3рб3укр3қаз3հայ3ישראל5קום3ابوظبي5رامكو5لاردن4بحرين5جزائر5سعودية6عليان5مغرب5مارات5یران5بارت2زار4يتك3ھارت5تونس4سودان3رية5شبكة4عراق2ب2مان4فلسطين6قطر3كاثوليك6وم3مصر2ليسيا5وريتانيا7قع4همراه5پاکستان7ڀارت4कॉम3नेट3भारत0म्3ोत5संगठन5বাংলা5ভারত2ৰত4ਭਾਰਤ4ભારત4ଭାରତ4இந்தியா6லங்கை6சிங்கப்பூர்11భారత్5ಭಾರತ4ഭാരതം5ලංකා4คอม3ไทย3ລາວ3გე2みんな3アマゾン4クラウド4グーグル4コム2ストア3セール3ファッション6ポイント4世界2中信1国1國1文网3亚马逊3企业2佛山2信息2健康2八卦2公司1益2台湾1灣2商城1店1标2嘉里0大酒店5在线2大拿2天主教3娱乐2家電2广东2微博2慈善2我爱你3手机2招聘2政务1府2新加坡2闻2时尚2書籍2机构2淡马锡3游戏2澳門2点看2移动2组织机构4网址1店1站1络2联通2谷歌2购物2通販2集团2電訊盈科4飞利浦3食品2餐厅2香格里拉3港2닷넷1컴2삼성2한국2';\n\n/**\n * Finite State Machine generation utilities\n */\n\n/**\n * @template T\n * @typedef {{ [group: string]: T[] }} Collections\n */\n\n/**\n * @typedef {{ [group: string]: true }} Flags\n */\n\n// Keys in scanner Collections instances\nconst numeric = 'numeric';\nconst ascii = 'ascii';\nconst alpha = 'alpha';\nconst asciinumeric = 'asciinumeric';\nconst alphanumeric = 'alphanumeric';\nconst domain = 'domain';\nconst emoji = 'emoji';\nconst scheme = 'scheme';\nconst slashscheme = 'slashscheme';\nconst whitespace = 'whitespace';\n\n/**\n * @template T\n * @param {string} name\n * @param {Collections<T>} groups to register in\n * @returns {T[]} Current list of tokens in the given collection\n */\nfunction registerGroup(name, groups) {\n  if (!(name in groups)) {\n    groups[name] = [];\n  }\n  return groups[name];\n}\n\n/**\n * @template T\n * @param {T} t token to add\n * @param {Collections<T>} groups\n * @param {Flags} flags\n */\nfunction addToGroups(t, flags, groups) {\n  if (flags[numeric]) {\n    flags[asciinumeric] = true;\n    flags[alphanumeric] = true;\n  }\n  if (flags[ascii]) {\n    flags[asciinumeric] = true;\n    flags[alpha] = true;\n  }\n  if (flags[asciinumeric]) {\n    flags[alphanumeric] = true;\n  }\n  if (flags[alpha]) {\n    flags[alphanumeric] = true;\n  }\n  if (flags[alphanumeric]) {\n    flags[domain] = true;\n  }\n  if (flags[emoji]) {\n    flags[domain] = true;\n  }\n  for (const k in flags) {\n    const group = registerGroup(k, groups);\n    if (group.indexOf(t) < 0) {\n      group.push(t);\n    }\n  }\n}\n\n/**\n * @template T\n * @param {T} t token to check\n * @param {Collections<T>} groups\n * @returns {Flags} group flags that contain this token\n */\nfunction flagsForToken(t, groups) {\n  const result = {};\n  for (const c in groups) {\n    if (groups[c].indexOf(t) >= 0) {\n      result[c] = true;\n    }\n  }\n  return result;\n}\n\n/**\n * @template T\n * @typedef {null | T } Transition\n */\n\n/**\n * Define a basic state machine state. j is the list of character transitions,\n * jr is the list of regex-match transitions, jd is the default state to\n * transition to t is the accepting token type, if any. If this is the terminal\n * state, then it does not emit a token.\n *\n * The template type T represents the type of the token this state accepts. This\n * should be a string (such as of the token exports in `text.js`) or a\n * MultiToken subclass (from `multi.js`)\n *\n * @template T\n * @param {T} [token] Token that this state emits\n */\nfunction State(token = null) {\n  // this.n = null; // DEBUG: State name\n  /** @type {{ [input: string]: State<T> }} j */\n  this.j = {}; // IMPLEMENTATION 1\n  // this.j = []; // IMPLEMENTATION 2\n  /** @type {[RegExp, State<T>][]} jr */\n  this.jr = [];\n  /** @type {?State<T>} jd */\n  this.jd = null;\n  /** @type {?T} t */\n  this.t = token;\n}\n\n/**\n * Scanner token groups\n * @type Collections<string>\n */\nState.groups = {};\nState.prototype = {\n  accepts() {\n    return !!this.t;\n  },\n  /**\n   * Follow an existing transition from the given input to the next state.\n   * Does not mutate.\n   * @param {string} input character or token type to transition on\n   * @returns {?State<T>} the next state, if any\n   */\n  go(input) {\n    const state = this;\n    const nextState = state.j[input];\n    if (nextState) {\n      return nextState;\n    }\n    for (let i = 0; i < state.jr.length; i++) {\n      const regex = state.jr[i][0];\n      const nextState = state.jr[i][1]; // note: might be empty to prevent default jump\n      if (nextState && regex.test(input)) {\n        return nextState;\n      }\n    }\n    // Nowhere left to jump! Return default, if any\n    return state.jd;\n  },\n  /**\n   * Whether the state has a transition for the given input. Set the second\n   * argument to true to only look for an exact match (and not a default or\n   * regular-expression-based transition)\n   * @param {string} input\n   * @param {boolean} exactOnly\n   */\n  has(input, exactOnly = false) {\n    return exactOnly ? input in this.j : !!this.go(input);\n  },\n  /**\n   * Short for \"transition all\"; create a transition from the array of items\n   * in the given list to the same final resulting state.\n   * @param {string | string[]} inputs Group of inputs to transition on\n   * @param {Transition<T> | State<T>} [next] Transition options\n   * @param {Flags} [flags] Collections flags to add token to\n   * @param {Collections<T>} [groups] Master list of token groups\n   */\n  ta(inputs, next, flags, groups) {\n    for (let i = 0; i < inputs.length; i++) {\n      this.tt(inputs[i], next, flags, groups);\n    }\n  },\n  /**\n   * Short for \"take regexp transition\"; defines a transition for this state\n   * when it encounters a token which matches the given regular expression\n   * @param {RegExp} regexp Regular expression transition (populate first)\n   * @param {T | State<T>} [next] Transition options\n   * @param {Flags} [flags] Collections flags to add token to\n   * @param {Collections<T>} [groups] Master list of token groups\n   * @returns {State<T>} taken after the given input\n   */\n  tr(regexp, next, flags, groups) {\n    groups = groups || State.groups;\n    let nextState;\n    if (next && next.j) {\n      nextState = next;\n    } else {\n      // Token with maybe token groups\n      nextState = new State(next);\n      if (flags && groups) {\n        addToGroups(next, flags, groups);\n      }\n    }\n    this.jr.push([regexp, nextState]);\n    return nextState;\n  },\n  /**\n   * Short for \"take transitions\", will take as many sequential transitions as\n   * the length of the given input and returns the\n   * resulting final state.\n   * @param {string | string[]} input\n   * @param {T | State<T>} [next] Transition options\n   * @param {Flags} [flags] Collections flags to add token to\n   * @param {Collections<T>} [groups] Master list of token groups\n   * @returns {State<T>} taken after the given input\n   */\n  ts(input, next, flags, groups) {\n    let state = this;\n    const len = input.length;\n    if (!len) {\n      return state;\n    }\n    for (let i = 0; i < len - 1; i++) {\n      state = state.tt(input[i]);\n    }\n    return state.tt(input[len - 1], next, flags, groups);\n  },\n  /**\n   * Short for \"take transition\", this is a method for building/working with\n   * state machines.\n   *\n   * If a state already exists for the given input, returns it.\n   *\n   * If a token is specified, that state will emit that token when reached by\n   * the linkify engine.\n   *\n   * If no state exists, it will be initialized with some default transitions\n   * that resemble existing default transitions.\n   *\n   * If a state is given for the second argument, that state will be\n   * transitioned to on the given input regardless of what that input\n   * previously did.\n   *\n   * Specify a token group flags to define groups that this token belongs to.\n   * The token will be added to corresponding entires in the given groups\n   * object.\n   *\n   * @param {string} input character, token type to transition on\n   * @param {T | State<T>} [next] Transition options\n   * @param {Flags} [flags] Collections flags to add token to\n   * @param {Collections<T>} [groups] Master list of groups\n   * @returns {State<T>} taken after the given input\n   */\n  tt(input, next, flags, groups) {\n    groups = groups || State.groups;\n    const state = this;\n\n    // Check if existing state given, just a basic transition\n    if (next && next.j) {\n      state.j[input] = next;\n      return next;\n    }\n    const t = next;\n\n    // Take the transition with the usual default mechanisms and use that as\n    // a template for creating the next state\n    let nextState,\n      templateState = state.go(input);\n    if (templateState) {\n      nextState = new State();\n      Object.assign(nextState.j, templateState.j);\n      nextState.jr.push.apply(nextState.jr, templateState.jr);\n      nextState.jd = templateState.jd;\n      nextState.t = templateState.t;\n    } else {\n      nextState = new State();\n    }\n    if (t) {\n      // Ensure newly token is in the same groups as the old token\n      if (groups) {\n        if (nextState.t && typeof nextState.t === 'string') {\n          const allFlags = Object.assign(flagsForToken(nextState.t, groups), flags);\n          addToGroups(t, allFlags, groups);\n        } else if (flags) {\n          addToGroups(t, flags, groups);\n        }\n      }\n      nextState.t = t; // overwrite anything that was previously there\n    }\n    state.j[input] = nextState;\n    return nextState;\n  }\n};\n\n// Helper functions to improve minification (not exported outside linkifyjs module)\n\n/**\n * @template T\n * @param {State<T>} state\n * @param {string | string[]} input\n * @param {Flags} [flags]\n * @param {Collections<T>} [groups]\n */\nconst ta = (state, input, next, flags, groups) => state.ta(input, next, flags, groups);\n\n/**\n * @template T\n * @param {State<T>} state\n * @param {RegExp} regexp\n * @param {T | State<T>} [next]\n * @param {Flags} [flags]\n * @param {Collections<T>} [groups]\n */\nconst tr = (state, regexp, next, flags, groups) => state.tr(regexp, next, flags, groups);\n\n/**\n * @template T\n * @param {State<T>} state\n * @param {string | string[]} input\n * @param {T | State<T>} [next]\n * @param {Flags} [flags]\n * @param {Collections<T>} [groups]\n */\nconst ts = (state, input, next, flags, groups) => state.ts(input, next, flags, groups);\n\n/**\n * @template T\n * @param {State<T>} state\n * @param {string} input\n * @param {T | State<T>} [next]\n * @param {Collections<T>} [groups]\n * @param {Flags} [flags]\n */\nconst tt = (state, input, next, flags, groups) => state.tt(input, next, flags, groups);\n\n/******************************************************************************\nText Tokens\nIdentifiers for token outputs from the regexp scanner\n******************************************************************************/\n\n// A valid web domain token\nconst WORD = 'WORD'; // only contains a-z\nconst UWORD = 'UWORD'; // contains letters other than a-z, used for IDN\nconst ASCIINUMERICAL = 'ASCIINUMERICAL'; // contains a-z, 0-9\nconst ALPHANUMERICAL = 'ALPHANUMERICAL'; // contains numbers and letters other than a-z, used for IDN\n\n// Special case of word\nconst LOCALHOST = 'LOCALHOST';\n\n// Valid top-level domain, special case of WORD (see tlds.js)\nconst TLD = 'TLD';\n\n// Valid IDN TLD, special case of UWORD (see tlds.js)\nconst UTLD = 'UTLD';\n\n// The scheme portion of a web URI protocol. Supported types include: `mailto`,\n// `file`, and user-defined custom protocols. Limited to schemes that contain\n// only letters\nconst SCHEME = 'SCHEME';\n\n// Similar to SCHEME, except makes distinction for schemes that must always be\n// followed by `://`, not just `:`. Supported types include `http`, `https`,\n// `ftp`, `ftps`\nconst SLASH_SCHEME = 'SLASH_SCHEME';\n\n// Any sequence of digits 0-9\nconst NUM = 'NUM';\n\n// Any number of consecutive whitespace characters that are not newline\nconst WS = 'WS';\n\n// New line (unix style)\nconst NL = 'NL'; // \\n\n\n// Opening/closing bracket classes\n// TODO: Rename OPEN -> LEFT and CLOSE -> RIGHT in v5 to fit with Unicode names\n// Also rename angle brackes to LESSTHAN and GREATER THAN\nconst OPENBRACE = 'OPENBRACE'; // {\nconst CLOSEBRACE = 'CLOSEBRACE'; // }\nconst OPENBRACKET = 'OPENBRACKET'; // [\nconst CLOSEBRACKET = 'CLOSEBRACKET'; // ]\nconst OPENPAREN = 'OPENPAREN'; // (\nconst CLOSEPAREN = 'CLOSEPAREN'; // )\nconst OPENANGLEBRACKET = 'OPENANGLEBRACKET'; // <\nconst CLOSEANGLEBRACKET = 'CLOSEANGLEBRACKET'; // >\nconst FULLWIDTHLEFTPAREN = 'FULLWIDTHLEFTPAREN'; // （\nconst FULLWIDTHRIGHTPAREN = 'FULLWIDTHRIGHTPAREN'; // ）\nconst LEFTCORNERBRACKET = 'LEFTCORNERBRACKET'; // 「\nconst RIGHTCORNERBRACKET = 'RIGHTCORNERBRACKET'; // 」\nconst LEFTWHITECORNERBRACKET = 'LEFTWHITECORNERBRACKET'; // 『\nconst RIGHTWHITECORNERBRACKET = 'RIGHTWHITECORNERBRACKET'; // 』\nconst FULLWIDTHLESSTHAN = 'FULLWIDTHLESSTHAN'; // ＜\nconst FULLWIDTHGREATERTHAN = 'FULLWIDTHGREATERTHAN'; // ＞\n\n// Various symbols\nconst AMPERSAND = 'AMPERSAND'; // &\nconst APOSTROPHE = 'APOSTROPHE'; // '\nconst ASTERISK = 'ASTERISK'; // *\nconst AT = 'AT'; // @\nconst BACKSLASH = 'BACKSLASH'; // \\\nconst BACKTICK = 'BACKTICK'; // `\nconst CARET = 'CARET'; // ^\nconst COLON = 'COLON'; // :\nconst COMMA = 'COMMA'; // ,\nconst DOLLAR = 'DOLLAR'; // $\nconst DOT = 'DOT'; // .\nconst EQUALS = 'EQUALS'; // =\nconst EXCLAMATION = 'EXCLAMATION'; // !\nconst HYPHEN = 'HYPHEN'; // -\nconst PERCENT = 'PERCENT'; // %\nconst PIPE = 'PIPE'; // |\nconst PLUS = 'PLUS'; // +\nconst POUND = 'POUND'; // #\nconst QUERY = 'QUERY'; // ?\nconst QUOTE = 'QUOTE'; // \"\nconst FULLWIDTHMIDDLEDOT = 'FULLWIDTHMIDDLEDOT'; // ・\n\nconst SEMI = 'SEMI'; // ;\nconst SLASH = 'SLASH'; // /\nconst TILDE = 'TILDE'; // ~\nconst UNDERSCORE = 'UNDERSCORE'; // _\n\n// Emoji symbol\nconst EMOJI$1 = 'EMOJI';\n\n// Default token - anything that is not one of the above\nconst SYM = 'SYM';\n\nvar tk = /*#__PURE__*/Object.freeze({\n\t__proto__: null,\n\tALPHANUMERICAL: ALPHANUMERICAL,\n\tAMPERSAND: AMPERSAND,\n\tAPOSTROPHE: APOSTROPHE,\n\tASCIINUMERICAL: ASCIINUMERICAL,\n\tASTERISK: ASTERISK,\n\tAT: AT,\n\tBACKSLASH: BACKSLASH,\n\tBACKTICK: BACKTICK,\n\tCARET: CARET,\n\tCLOSEANGLEBRACKET: CLOSEANGLEBRACKET,\n\tCLOSEBRACE: CLOSEBRACE,\n\tCLOSEBRACKET: CLOSEBRACKET,\n\tCLOSEPAREN: CLOSEPAREN,\n\tCOLON: COLON,\n\tCOMMA: COMMA,\n\tDOLLAR: DOLLAR,\n\tDOT: DOT,\n\tEMOJI: EMOJI$1,\n\tEQUALS: EQUALS,\n\tEXCLAMATION: EXCLAMATION,\n\tFULLWIDTHGREATERTHAN: FULLWIDTHGREATERTHAN,\n\tFULLWIDTHLEFTPAREN: FULLWIDTHLEFTPAREN,\n\tFULLWIDTHLESSTHAN: FULLWIDTHLESSTHAN,\n\tFULLWIDTHMIDDLEDOT: FULLWIDTHMIDDLEDOT,\n\tFULLWIDTHRIGHTPAREN: FULLWIDTHRIGHTPAREN,\n\tHYPHEN: HYPHEN,\n\tLEFTCORNERBRACKET: LEFTCORNERBRACKET,\n\tLEFTWHITECORNERBRACKET: LEFTWHITECORNERBRACKET,\n\tLOCALHOST: LOCALHOST,\n\tNL: NL,\n\tNUM: NUM,\n\tOPENANGLEBRACKET: OPENANGLEBRACKET,\n\tOPENBRACE: OPENBRACE,\n\tOPENBRACKET: OPENBRACKET,\n\tOPENPAREN: OPENPAREN,\n\tPERCENT: PERCENT,\n\tPIPE: PIPE,\n\tPLUS: PLUS,\n\tPOUND: POUND,\n\tQUERY: QUERY,\n\tQUOTE: QUOTE,\n\tRIGHTCORNERBRACKET: RIGHTCORNERBRACKET,\n\tRIGHTWHITECORNERBRACKET: RIGHTWHITECORNERBRACKET,\n\tSCHEME: SCHEME,\n\tSEMI: SEMI,\n\tSLASH: SLASH,\n\tSLASH_SCHEME: SLASH_SCHEME,\n\tSYM: SYM,\n\tTILDE: TILDE,\n\tTLD: TLD,\n\tUNDERSCORE: UNDERSCORE,\n\tUTLD: UTLD,\n\tUWORD: UWORD,\n\tWORD: WORD,\n\tWS: WS\n});\n\n// Note that these two Unicode ones expand into a really big one with Babel\nconst ASCII_LETTER = /[a-z]/;\nconst LETTER = /\\p{L}/u; // Any Unicode character with letter data type\nconst EMOJI = /\\p{Emoji}/u; // Any Unicode emoji character\nconst EMOJI_VARIATION$1 = /\\ufe0f/;\nconst DIGIT = /\\d/;\nconst SPACE = /\\s/;\n\nvar regexp = /*#__PURE__*/Object.freeze({\n\t__proto__: null,\n\tASCII_LETTER: ASCII_LETTER,\n\tDIGIT: DIGIT,\n\tEMOJI: EMOJI,\n\tEMOJI_VARIATION: EMOJI_VARIATION$1,\n\tLETTER: LETTER,\n\tSPACE: SPACE\n});\n\n/**\n\tThe scanner provides an interface that takes a string of text as input, and\n\toutputs an array of tokens instances that can be used for easy URL parsing.\n*/\n\nconst CR = '\\r'; // carriage-return character\nconst LF = '\\n'; // line-feed character\nconst EMOJI_VARIATION = '\\ufe0f'; // Variation selector, follows heart and others\nconst EMOJI_JOINER = '\\u200d'; // zero-width joiner\nconst OBJECT_REPLACEMENT = '\\ufffc'; // whitespace placeholder that sometimes appears in rich text editors\n\nlet tlds = null,\n  utlds = null; // don't change so only have to be computed once\n\n/**\n * Scanner output token:\n * - `t` is the token name (e.g., 'NUM', 'EMOJI', 'TLD')\n * - `v` is the value of the token (e.g., '123', '❤️', 'com')\n * - `s` is the start index of the token in the original string\n * - `e` is the end index of the token in the original string\n * @typedef {{t: string, v: string, s: number, e: number}} Token\n */\n\n/**\n * @template T\n * @typedef {{ [collection: string]: T[] }} Collections\n */\n\n/**\n * Initialize the scanner character-based state machine for the given start\n * state\n * @param {[string, boolean][]} customSchemes List of custom schemes, where each\n * item is a length-2 tuple with the first element set to the string scheme, and\n * the second element set to `true` if the `://` after the scheme is optional\n */\nfunction init$2(customSchemes = []) {\n  // Frequently used states (name argument removed during minification)\n  /** @type Collections<string> */\n  const groups = {}; // of tokens\n  State.groups = groups;\n  /** @type State<string> */\n  const Start = new State();\n  if (tlds == null) {\n    tlds = decodeTlds(encodedTlds);\n  }\n  if (utlds == null) {\n    utlds = decodeTlds(encodedUtlds);\n  }\n\n  // States for special URL symbols that accept immediately after start\n  tt(Start, \"'\", APOSTROPHE);\n  tt(Start, '{', OPENBRACE);\n  tt(Start, '}', CLOSEBRACE);\n  tt(Start, '[', OPENBRACKET);\n  tt(Start, ']', CLOSEBRACKET);\n  tt(Start, '(', OPENPAREN);\n  tt(Start, ')', CLOSEPAREN);\n  tt(Start, '<', OPENANGLEBRACKET);\n  tt(Start, '>', CLOSEANGLEBRACKET);\n  tt(Start, '（', FULLWIDTHLEFTPAREN);\n  tt(Start, '）', FULLWIDTHRIGHTPAREN);\n  tt(Start, '「', LEFTCORNERBRACKET);\n  tt(Start, '」', RIGHTCORNERBRACKET);\n  tt(Start, '『', LEFTWHITECORNERBRACKET);\n  tt(Start, '』', RIGHTWHITECORNERBRACKET);\n  tt(Start, '＜', FULLWIDTHLESSTHAN);\n  tt(Start, '＞', FULLWIDTHGREATERTHAN);\n  tt(Start, '&', AMPERSAND);\n  tt(Start, '*', ASTERISK);\n  tt(Start, '@', AT);\n  tt(Start, '`', BACKTICK);\n  tt(Start, '^', CARET);\n  tt(Start, ':', COLON);\n  tt(Start, ',', COMMA);\n  tt(Start, '$', DOLLAR);\n  tt(Start, '.', DOT);\n  tt(Start, '=', EQUALS);\n  tt(Start, '!', EXCLAMATION);\n  tt(Start, '-', HYPHEN);\n  tt(Start, '%', PERCENT);\n  tt(Start, '|', PIPE);\n  tt(Start, '+', PLUS);\n  tt(Start, '#', POUND);\n  tt(Start, '?', QUERY);\n  tt(Start, '\"', QUOTE);\n  tt(Start, '/', SLASH);\n  tt(Start, ';', SEMI);\n  tt(Start, '~', TILDE);\n  tt(Start, '_', UNDERSCORE);\n  tt(Start, '\\\\', BACKSLASH);\n  tt(Start, '・', FULLWIDTHMIDDLEDOT);\n  const Num = tr(Start, DIGIT, NUM, {\n    [numeric]: true\n  });\n  tr(Num, DIGIT, Num);\n  const Asciinumeric = tr(Num, ASCII_LETTER, ASCIINUMERICAL, {\n    [asciinumeric]: true\n  });\n  const Alphanumeric = tr(Num, LETTER, ALPHANUMERICAL, {\n    [alphanumeric]: true\n  });\n\n  // State which emits a word token\n  const Word = tr(Start, ASCII_LETTER, WORD, {\n    [ascii]: true\n  });\n  tr(Word, DIGIT, Asciinumeric);\n  tr(Word, ASCII_LETTER, Word);\n  tr(Asciinumeric, DIGIT, Asciinumeric);\n  tr(Asciinumeric, ASCII_LETTER, Asciinumeric);\n\n  // Same as previous, but specific to non-fsm.ascii alphabet words\n  const UWord = tr(Start, LETTER, UWORD, {\n    [alpha]: true\n  });\n  tr(UWord, ASCII_LETTER); // Non-accepting\n  tr(UWord, DIGIT, Alphanumeric);\n  tr(UWord, LETTER, UWord);\n  tr(Alphanumeric, DIGIT, Alphanumeric);\n  tr(Alphanumeric, ASCII_LETTER); // Non-accepting\n  tr(Alphanumeric, LETTER, Alphanumeric); // Non-accepting\n\n  // Whitespace jumps\n  // Tokens of only non-newline whitespace are arbitrarily long\n  // If any whitespace except newline, more whitespace!\n  const Nl = tt(Start, LF, NL, {\n    [whitespace]: true\n  });\n  const Cr = tt(Start, CR, WS, {\n    [whitespace]: true\n  });\n  const Ws = tr(Start, SPACE, WS, {\n    [whitespace]: true\n  });\n  tt(Start, OBJECT_REPLACEMENT, Ws);\n  tt(Cr, LF, Nl); // \\r\\n\n  tt(Cr, OBJECT_REPLACEMENT, Ws);\n  tr(Cr, SPACE, Ws);\n  tt(Ws, CR); // non-accepting state to avoid mixing whitespaces\n  tt(Ws, LF); // non-accepting state to avoid mixing whitespaces\n  tr(Ws, SPACE, Ws);\n  tt(Ws, OBJECT_REPLACEMENT, Ws);\n\n  // Emoji tokens. They are not grouped by the scanner except in cases where a\n  // zero-width joiner is present\n  const Emoji = tr(Start, EMOJI, EMOJI$1, {\n    [emoji]: true\n  });\n  tt(Emoji, '#'); // no transition, emoji regex seems to match #\n  tr(Emoji, EMOJI, Emoji);\n  tt(Emoji, EMOJI_VARIATION, Emoji);\n  // tt(Start, EMOJI_VARIATION, Emoji); // This one is sketchy\n\n  const EmojiJoiner = tt(Emoji, EMOJI_JOINER);\n  tt(EmojiJoiner, '#');\n  tr(EmojiJoiner, EMOJI, Emoji);\n  // tt(EmojiJoiner, EMOJI_VARIATION, Emoji); // also sketchy\n\n  // Generates states for top-level domains\n  // Note that this is most accurate when tlds are in alphabetical order\n  const wordjr = [[ASCII_LETTER, Word], [DIGIT, Asciinumeric]];\n  const uwordjr = [[ASCII_LETTER, null], [LETTER, UWord], [DIGIT, Alphanumeric]];\n  for (let i = 0; i < tlds.length; i++) {\n    fastts(Start, tlds[i], TLD, WORD, wordjr);\n  }\n  for (let i = 0; i < utlds.length; i++) {\n    fastts(Start, utlds[i], UTLD, UWORD, uwordjr);\n  }\n  addToGroups(TLD, {\n    tld: true,\n    ascii: true\n  }, groups);\n  addToGroups(UTLD, {\n    utld: true,\n    alpha: true\n  }, groups);\n\n  // Collect the states generated by different protocols. NOTE: If any new TLDs\n  // get added that are also protocols, set the token to be the same as the\n  // protocol to ensure parsing works as expected.\n  fastts(Start, 'file', SCHEME, WORD, wordjr);\n  fastts(Start, 'mailto', SCHEME, WORD, wordjr);\n  fastts(Start, 'http', SLASH_SCHEME, WORD, wordjr);\n  fastts(Start, 'https', SLASH_SCHEME, WORD, wordjr);\n  fastts(Start, 'ftp', SLASH_SCHEME, WORD, wordjr);\n  fastts(Start, 'ftps', SLASH_SCHEME, WORD, wordjr);\n  addToGroups(SCHEME, {\n    scheme: true,\n    ascii: true\n  }, groups);\n  addToGroups(SLASH_SCHEME, {\n    slashscheme: true,\n    ascii: true\n  }, groups);\n\n  // Register custom schemes. Assumes each scheme is asciinumeric with hyphens\n  customSchemes = customSchemes.sort((a, b) => a[0] > b[0] ? 1 : -1);\n  for (let i = 0; i < customSchemes.length; i++) {\n    const sch = customSchemes[i][0];\n    const optionalSlashSlash = customSchemes[i][1];\n    const flags = optionalSlashSlash ? {\n      [scheme]: true\n    } : {\n      [slashscheme]: true\n    };\n    if (sch.indexOf('-') >= 0) {\n      flags[domain] = true;\n    } else if (!ASCII_LETTER.test(sch)) {\n      flags[numeric] = true; // numbers only\n    } else if (DIGIT.test(sch)) {\n      flags[asciinumeric] = true;\n    } else {\n      flags[ascii] = true;\n    }\n    ts(Start, sch, sch, flags);\n  }\n\n  // Localhost token\n  ts(Start, 'localhost', LOCALHOST, {\n    ascii: true\n  });\n\n  // Set default transition for start state (some symbol)\n  Start.jd = new State(SYM);\n  return {\n    start: Start,\n    tokens: Object.assign({\n      groups\n    }, tk)\n  };\n}\n\n/**\n\tGiven a string, returns an array of TOKEN instances representing the\n\tcomposition of that string.\n\n\t@method run\n\t@param {State<string>} start scanner starting state\n\t@param {string} str input string to scan\n\t@return {Token[]} list of tokens, each with a type and value\n*/\nfunction run$1(start, str) {\n  // State machine is not case sensitive, so input is tokenized in lowercased\n  // form (still returns regular case). Uses selective `toLowerCase` because\n  // lowercasing the entire string causes the length and character position to\n  // vary in some non-English strings with V8-based runtimes.\n  const iterable = stringToArray(str.replace(/[A-Z]/g, c => c.toLowerCase()));\n  const charCount = iterable.length; // <= len if there are emojis, etc\n  const tokens = []; // return value\n\n  // cursor through the string itself, accounting for characters that have\n  // width with length 2 such as emojis\n  let cursor = 0;\n\n  // Cursor through the array-representation of the string\n  let charCursor = 0;\n\n  // Tokenize the string\n  while (charCursor < charCount) {\n    let state = start;\n    let nextState = null;\n    let tokenLength = 0;\n    let latestAccepting = null;\n    let sinceAccepts = -1;\n    let charsSinceAccepts = -1;\n    while (charCursor < charCount && (nextState = state.go(iterable[charCursor]))) {\n      state = nextState;\n\n      // Keep track of the latest accepting state\n      if (state.accepts()) {\n        sinceAccepts = 0;\n        charsSinceAccepts = 0;\n        latestAccepting = state;\n      } else if (sinceAccepts >= 0) {\n        sinceAccepts += iterable[charCursor].length;\n        charsSinceAccepts++;\n      }\n      tokenLength += iterable[charCursor].length;\n      cursor += iterable[charCursor].length;\n      charCursor++;\n    }\n\n    // Roll back to the latest accepting state\n    cursor -= sinceAccepts;\n    charCursor -= charsSinceAccepts;\n    tokenLength -= sinceAccepts;\n\n    // No more jumps, just make a new token from the last accepting one\n    tokens.push({\n      t: latestAccepting.t,\n      // token type/name\n      v: str.slice(cursor - tokenLength, cursor),\n      // string value\n      s: cursor - tokenLength,\n      // start index\n      e: cursor // end index (excluding)\n    });\n  }\n  return tokens;\n}\n\n/**\n * Convert a String to an Array of characters, taking into account that some\n * characters like emojis take up two string indexes.\n *\n * Adapted from core-js (MIT license)\n * https://github.com/zloirock/core-js/blob/2d69cf5f99ab3ea3463c395df81e5a15b68f49d9/packages/core-js/internals/string-multibyte.js\n *\n * @function stringToArray\n * @param {string} str\n * @returns {string[]}\n */\nfunction stringToArray(str) {\n  const result = [];\n  const len = str.length;\n  let index = 0;\n  while (index < len) {\n    let first = str.charCodeAt(index);\n    let second;\n    let char = first < 0xd800 || first > 0xdbff || index + 1 === len || (second = str.charCodeAt(index + 1)) < 0xdc00 || second > 0xdfff ? str[index] // single character\n    : str.slice(index, index + 2); // two-index characters\n    result.push(char);\n    index += char.length;\n  }\n  return result;\n}\n\n/**\n * Fast version of ts function for when transition defaults are well known\n * @param {State<string>} state\n * @param {string} input\n * @param {string} t\n * @param {string} defaultt\n * @param {[RegExp, State<string>][]} jr\n * @returns {State<string>}\n */\nfunction fastts(state, input, t, defaultt, jr) {\n  let next;\n  const len = input.length;\n  for (let i = 0; i < len - 1; i++) {\n    const char = input[i];\n    if (state.j[char]) {\n      next = state.j[char];\n    } else {\n      next = new State(defaultt);\n      next.jr = jr.slice();\n      state.j[char] = next;\n    }\n    state = next;\n  }\n  next = new State(t);\n  next.jr = jr.slice();\n  state.j[input[len - 1]] = next;\n  return next;\n}\n\n/**\n * Converts a string of Top-Level Domain names encoded in update-tlds.js back\n * into a list of strings.\n * @param {str} encoded encoded TLDs string\n * @returns {str[]} original TLDs list\n */\nfunction decodeTlds(encoded) {\n  const words = [];\n  const stack = [];\n  let i = 0;\n  let digits = '0123456789';\n  while (i < encoded.length) {\n    let popDigitCount = 0;\n    while (digits.indexOf(encoded[i + popDigitCount]) >= 0) {\n      popDigitCount++; // encountered some digits, have to pop to go one level up trie\n    }\n    if (popDigitCount > 0) {\n      words.push(stack.join('')); // whatever preceded the pop digits must be a word\n      for (let popCount = parseInt(encoded.substring(i, i + popDigitCount), 10); popCount > 0; popCount--) {\n        stack.pop();\n      }\n      i += popDigitCount;\n    } else {\n      stack.push(encoded[i]); // drop down a level into the trie\n      i++;\n    }\n  }\n  return words;\n}\n\n/**\n * An object where each key is a valid DOM Event Name such as `click` or `focus`\n * and each value is an event handler function.\n *\n * https://developer.mozilla.org/en-US/docs/Web/API/Element#events\n * @typedef {?{ [event: string]: Function }} EventListeners\n */\n\n/**\n * All formatted properties required to render a link, including `tagName`,\n * `attributes`, `content` and `eventListeners`.\n * @typedef {{ tagName: any, attributes: {[attr: string]: any}, content: string,\n * eventListeners: EventListeners }} IntermediateRepresentation\n */\n\n/**\n * Specify either an object described by the template type `O` or a function.\n *\n * The function takes a string value (usually the link's href attribute), the\n * link type (`'url'`, `'hashtag`', etc.) and an internal token representation\n * of the link. It should return an object of the template type `O`\n * @template O\n * @typedef {O | ((value: string, type: string, token: MultiToken) => O)} OptObj\n */\n\n/**\n * Specify either a function described by template type `F` or an object.\n *\n * Each key in the object should be a link type (`'url'`, `'hashtag`', etc.). Each\n * value should be a function with template type `F` that is called when the\n * corresponding link type is encountered.\n * @template F\n * @typedef {F | { [type: string]: F}} OptFn\n */\n\n/**\n * Specify either a value with template type `V`, a function that returns `V` or\n * an object where each value resolves to `V`.\n *\n * The function takes a string value (usually the link's href attribute), the\n * link type (`'url'`, `'hashtag`', etc.) and an internal token representation\n * of the link. It should return an object of the template type `V`\n *\n * For the object, each key should be a link type (`'url'`, `'hashtag`', etc.).\n * Each value should either have type `V` or a function that returns V. This\n * function similarly takes a string value and a token.\n *\n * Example valid types for `Opt<string>`:\n *\n * ```js\n * 'hello'\n * (value, type, token) => 'world'\n * { url: 'hello', email: (value, token) => 'world'}\n * ```\n * @template V\n * @typedef {V | ((value: string, type: string, token: MultiToken) => V) | { [type: string]: V | ((value: string, token: MultiToken) => V) }} Opt\n */\n\n/**\n * See available options: https://linkify.js.org/docs/options.html\n * @typedef {{\n * \tdefaultProtocol?: string,\n *  events?: OptObj<EventListeners>,\n * \tformat?: Opt<string>,\n * \tformatHref?: Opt<string>,\n * \tnl2br?: boolean,\n * \ttagName?: Opt<any>,\n * \ttarget?: Opt<string>,\n * \trel?: Opt<string>,\n * \tvalidate?: Opt<boolean>,\n * \ttruncate?: Opt<number>,\n * \tclassName?: Opt<string>,\n * \tattributes?: OptObj<({ [attr: string]: any })>,\n *  ignoreTags?: string[],\n * \trender?: OptFn<((ir: IntermediateRepresentation) => any)>\n * }} Opts\n */\n\n/**\n * @type Required<Opts>\n */\nconst defaults = {\n  defaultProtocol: 'http',\n  events: null,\n  format: noop,\n  formatHref: noop,\n  nl2br: false,\n  tagName: 'a',\n  target: null,\n  rel: null,\n  validate: true,\n  truncate: Infinity,\n  className: null,\n  attributes: null,\n  ignoreTags: [],\n  render: null\n};\n\n/**\n * Utility class for linkify interfaces to apply specified\n * {@link Opts formatting and rendering options}.\n *\n * @param {Opts | Options} [opts] Option value overrides.\n * @param {(ir: IntermediateRepresentation) => any} [defaultRender] (For\n *   internal use) default render function that determines how to generate an\n *   HTML element based on a link token's derived tagName, attributes and HTML.\n *   Similar to render option\n */\nfunction Options(opts, defaultRender = null) {\n  let o = Object.assign({}, defaults);\n  if (opts) {\n    o = Object.assign(o, opts instanceof Options ? opts.o : opts);\n  }\n\n  // Ensure all ignored tags are uppercase\n  const ignoredTags = o.ignoreTags;\n  const uppercaseIgnoredTags = [];\n  for (let i = 0; i < ignoredTags.length; i++) {\n    uppercaseIgnoredTags.push(ignoredTags[i].toUpperCase());\n  }\n  /** @protected */\n  this.o = o;\n  if (defaultRender) {\n    this.defaultRender = defaultRender;\n  }\n  this.ignoreTags = uppercaseIgnoredTags;\n}\nOptions.prototype = {\n  o: defaults,\n  /**\n   * @type string[]\n   */\n  ignoreTags: [],\n  /**\n   * @param {IntermediateRepresentation} ir\n   * @returns {any}\n   */\n  defaultRender(ir) {\n    return ir;\n  },\n  /**\n   * Returns true or false based on whether a token should be displayed as a\n   * link based on the user options.\n   * @param {MultiToken} token\n   * @returns {boolean}\n   */\n  check(token) {\n    return this.get('validate', token.toString(), token);\n  },\n  // Private methods\n\n  /**\n   * Resolve an option's value based on the value of the option and the given\n   * params. If operator and token are specified and the target option is\n   * callable, automatically calls the function with the given argument.\n   * @template {keyof Opts} K\n   * @param {K} key Name of option to use\n   * @param {string} [operator] will be passed to the target option if it's a\n   * function. If not specified, RAW function value gets returned\n   * @param {MultiToken} [token] The token from linkify.tokenize\n   * @returns {Opts[K] | any}\n   */\n  get(key, operator, token) {\n    const isCallable = operator != null;\n    let option = this.o[key];\n    if (!option) {\n      return option;\n    }\n    if (typeof option === 'object') {\n      option = token.t in option ? option[token.t] : defaults[key];\n      if (typeof option === 'function' && isCallable) {\n        option = option(operator, token);\n      }\n    } else if (typeof option === 'function' && isCallable) {\n      option = option(operator, token.t, token);\n    }\n    return option;\n  },\n  /**\n   * @template {keyof Opts} L\n   * @param {L} key Name of options object to use\n   * @param {string} [operator]\n   * @param {MultiToken} [token]\n   * @returns {Opts[L] | any}\n   */\n  getObj(key, operator, token) {\n    let obj = this.o[key];\n    if (typeof obj === 'function' && operator != null) {\n      obj = obj(operator, token.t, token);\n    }\n    return obj;\n  },\n  /**\n   * Convert the given token to a rendered element that may be added to the\n   * calling-interface's DOM\n   * @param {MultiToken} token Token to render to an HTML element\n   * @returns {any} Render result; e.g., HTML string, DOM element, React\n   *   Component, etc.\n   */\n  render(token) {\n    const ir = token.render(this); // intermediate representation\n    const renderFn = this.get('render', null, token) || this.defaultRender;\n    return renderFn(ir, token.t, token);\n  }\n};\nfunction noop(val) {\n  return val;\n}\n\nvar options = /*#__PURE__*/Object.freeze({\n\t__proto__: null,\n\tOptions: Options,\n\tdefaults: defaults\n});\n\n/******************************************************************************\n\tMulti-Tokens\n\tTokens composed of arrays of TextTokens\n******************************************************************************/\n\n/**\n * @param {string} value\n * @param {Token[]} tokens\n */\nfunction MultiToken(value, tokens) {\n  this.t = 'token';\n  this.v = value;\n  this.tk = tokens;\n}\n\n/**\n * Abstract class used for manufacturing tokens of text tokens. That is rather\n * than the value for a token being a small string of text, it's value an array\n * of text tokens.\n *\n * Used for grouping together URLs, emails, hashtags, and other potential\n * creations.\n * @class MultiToken\n * @property {string} t\n * @property {string} v\n * @property {Token[]} tk\n * @abstract\n */\nMultiToken.prototype = {\n  isLink: false,\n  /**\n   * Return the string this token represents.\n   * @return {string}\n   */\n  toString() {\n    return this.v;\n  },\n  /**\n   * What should the value for this token be in the `href` HTML attribute?\n   * Returns the `.toString` value by default.\n   * @param {string} [scheme]\n   * @return {string}\n   */\n  toHref(scheme) {\n    return this.toString();\n  },\n  /**\n   * @param {Options} options Formatting options\n   * @returns {string}\n   */\n  toFormattedString(options) {\n    const val = this.toString();\n    const truncate = options.get('truncate', val, this);\n    const formatted = options.get('format', val, this);\n    return truncate && formatted.length > truncate ? formatted.substring(0, truncate) + '…' : formatted;\n  },\n  /**\n   *\n   * @param {Options} options\n   * @returns {string}\n   */\n  toFormattedHref(options) {\n    return options.get('formatHref', this.toHref(options.get('defaultProtocol')), this);\n  },\n  /**\n   * The start index of this token in the original input string\n   * @returns {number}\n   */\n  startIndex() {\n    return this.tk[0].s;\n  },\n  /**\n   * The end index of this token in the original input string (up to this\n   * index but not including it)\n   * @returns {number}\n   */\n  endIndex() {\n    return this.tk[this.tk.length - 1].e;\n  },\n  /**\n  \tReturns an object  of relevant values for this token, which includes keys\n  \t* type - Kind of token ('url', 'email', etc.)\n  \t* value - Original text\n  \t* href - The value that should be added to the anchor tag's href\n  \t\tattribute\n  \t\t@method toObject\n  \t@param {string} [protocol] `'http'` by default\n  */\n  toObject(protocol = defaults.defaultProtocol) {\n    return {\n      type: this.t,\n      value: this.toString(),\n      isLink: this.isLink,\n      href: this.toHref(protocol),\n      start: this.startIndex(),\n      end: this.endIndex()\n    };\n  },\n  /**\n   *\n   * @param {Options} options Formatting option\n   */\n  toFormattedObject(options) {\n    return {\n      type: this.t,\n      value: this.toFormattedString(options),\n      isLink: this.isLink,\n      href: this.toFormattedHref(options),\n      start: this.startIndex(),\n      end: this.endIndex()\n    };\n  },\n  /**\n   * Whether this token should be rendered as a link according to the given options\n   * @param {Options} options\n   * @returns {boolean}\n   */\n  validate(options) {\n    return options.get('validate', this.toString(), this);\n  },\n  /**\n   * Return an object that represents how this link should be rendered.\n   * @param {Options} options Formattinng options\n   */\n  render(options) {\n    const token = this;\n    const href = this.toHref(options.get('defaultProtocol'));\n    const formattedHref = options.get('formatHref', href, this);\n    const tagName = options.get('tagName', href, token);\n    const content = this.toFormattedString(options);\n    const attributes = {};\n    const className = options.get('className', href, token);\n    const target = options.get('target', href, token);\n    const rel = options.get('rel', href, token);\n    const attrs = options.getObj('attributes', href, token);\n    const eventListeners = options.getObj('events', href, token);\n    attributes.href = formattedHref;\n    if (className) {\n      attributes.class = className;\n    }\n    if (target) {\n      attributes.target = target;\n    }\n    if (rel) {\n      attributes.rel = rel;\n    }\n    if (attrs) {\n      Object.assign(attributes, attrs);\n    }\n    return {\n      tagName,\n      attributes,\n      content,\n      eventListeners\n    };\n  }\n};\n\n/**\n * Create a new token that can be emitted by the parser state machine\n * @param {string} type readable type of the token\n * @param {object} props properties to assign or override, including isLink = true or false\n * @returns {new (value: string, tokens: Token[]) => MultiToken} new token class\n */\nfunction createTokenClass(type, props) {\n  class Token extends MultiToken {\n    constructor(value, tokens) {\n      super(value, tokens);\n      this.t = type;\n    }\n  }\n  for (const p in props) {\n    Token.prototype[p] = props[p];\n  }\n  Token.t = type;\n  return Token;\n}\n\n/**\n\tRepresents a list of tokens making up a valid email address\n*/\nconst Email = createTokenClass('email', {\n  isLink: true,\n  toHref() {\n    return 'mailto:' + this.toString();\n  }\n});\n\n/**\n\tRepresents some plain text\n*/\nconst Text = createTokenClass('text');\n\n/**\n\tMulti-linebreak token - represents a line break\n\t@class Nl\n*/\nconst Nl = createTokenClass('nl');\n\n/**\n\tRepresents a list of text tokens making up a valid URL\n\t@class Url\n*/\nconst Url = createTokenClass('url', {\n  isLink: true,\n  /**\n  \tLowercases relevant parts of the domain and adds the protocol if\n  \trequired. Note that this will not escape unsafe HTML characters in the\n  \tURL.\n  \t\t@param {string} [scheme] default scheme (e.g., 'https')\n  \t@return {string} the full href\n  */\n  toHref(scheme = defaults.defaultProtocol) {\n    // Check if already has a prefix scheme\n    return this.hasProtocol() ? this.v : `${scheme}://${this.v}`;\n  },\n  /**\n   * Check whether this URL token has a protocol\n   * @return {boolean}\n   */\n  hasProtocol() {\n    const tokens = this.tk;\n    return tokens.length >= 2 && tokens[0].t !== LOCALHOST && tokens[1].t === COLON;\n  }\n});\n\nvar multi = /*#__PURE__*/Object.freeze({\n\t__proto__: null,\n\tBase: MultiToken,\n\tEmail: Email,\n\tMultiToken: MultiToken,\n\tNl: Nl,\n\tText: Text,\n\tUrl: Url,\n\tcreateTokenClass: createTokenClass\n});\n\n/**\n\tNot exactly parser, more like the second-stage scanner (although we can\n\ttheoretically hotswap the code here with a real parser in the future... but\n\tfor a little URL-finding utility abstract syntax trees may be a little\n\toverkill).\n\n\tURL format: http://en.wikipedia.org/wiki/URI_scheme\n\tEmail format: http://en.wikipedia.org/wiki/EmailAddress (links to RFC in\n\treference)\n\n\t@module linkify\n\t@submodule parser\n\t@main run\n*/\n\nconst makeState = arg => new State(arg);\n\n/**\n * Generate the parser multi token-based state machine\n * @param {{ groups: Collections<string> }} tokens\n */\nfunction init$1({\n  groups\n}) {\n  // Types of characters the URL can definitely end in\n  const qsAccepting = groups.domain.concat([AMPERSAND, ASTERISK, AT, BACKSLASH, BACKTICK, CARET, DOLLAR, EQUALS, HYPHEN, NUM, PERCENT, PIPE, PLUS, POUND, SLASH, SYM, TILDE, UNDERSCORE]);\n\n  // Types of tokens that can follow a URL and be part of the query string\n  // but cannot be the very last characters\n  // Characters that cannot appear in the URL at all should be excluded\n  const qsNonAccepting = [APOSTROPHE, COLON, COMMA, DOT, EXCLAMATION, PERCENT, QUERY, QUOTE, SEMI, OPENANGLEBRACKET, CLOSEANGLEBRACKET, OPENBRACE, CLOSEBRACE, CLOSEBRACKET, OPENBRACKET, OPENPAREN, CLOSEPAREN, FULLWIDTHLEFTPAREN, FULLWIDTHRIGHTPAREN, LEFTCORNERBRACKET, RIGHTCORNERBRACKET, LEFTWHITECORNERBRACKET, RIGHTWHITECORNERBRACKET, FULLWIDTHLESSTHAN, FULLWIDTHGREATERTHAN];\n\n  // For addresses without the mailto prefix\n  // Tokens allowed in the localpart of the email\n  const localpartAccepting = [AMPERSAND, APOSTROPHE, ASTERISK, BACKSLASH, BACKTICK, CARET, DOLLAR, EQUALS, HYPHEN, OPENBRACE, CLOSEBRACE, PERCENT, PIPE, PLUS, POUND, QUERY, SLASH, SYM, TILDE, UNDERSCORE];\n\n  // The universal starting state.\n  /**\n   * @type State<Token>\n   */\n  const Start = makeState();\n  const Localpart = tt(Start, TILDE); // Local part of the email address\n  ta(Localpart, localpartAccepting, Localpart);\n  ta(Localpart, groups.domain, Localpart);\n  const Domain = makeState(),\n    Scheme = makeState(),\n    SlashScheme = makeState();\n  ta(Start, groups.domain, Domain); // parsed string ends with a potential domain name (A)\n  ta(Start, groups.scheme, Scheme); // e.g., 'mailto'\n  ta(Start, groups.slashscheme, SlashScheme); // e.g., 'http'\n\n  ta(Domain, localpartAccepting, Localpart);\n  ta(Domain, groups.domain, Domain);\n  const LocalpartAt = tt(Domain, AT); // Local part of the email address plus @\n\n  tt(Localpart, AT, LocalpartAt); // close to an email address now\n\n  // Local part of an email address can be e.g. 'http' or 'mailto'\n  tt(Scheme, AT, LocalpartAt);\n  tt(SlashScheme, AT, LocalpartAt);\n  const LocalpartDot = tt(Localpart, DOT); // Local part of the email address plus '.' (localpart cannot end in .)\n  ta(LocalpartDot, localpartAccepting, Localpart);\n  ta(LocalpartDot, groups.domain, Localpart);\n  const EmailDomain = makeState();\n  ta(LocalpartAt, groups.domain, EmailDomain); // parsed string starts with local email info + @ with a potential domain name\n  ta(EmailDomain, groups.domain, EmailDomain);\n  const EmailDomainDot = tt(EmailDomain, DOT); // domain followed by DOT\n  ta(EmailDomainDot, groups.domain, EmailDomain);\n  const Email$1 = makeState(Email); // Possible email address (could have more tlds)\n  ta(EmailDomainDot, groups.tld, Email$1);\n  ta(EmailDomainDot, groups.utld, Email$1);\n  tt(LocalpartAt, LOCALHOST, Email$1);\n\n  // Hyphen can jump back to a domain name\n  const EmailDomainHyphen = tt(EmailDomain, HYPHEN); // parsed string starts with local email info + @ with a potential domain name\n  tt(EmailDomainHyphen, HYPHEN, EmailDomainHyphen);\n  ta(EmailDomainHyphen, groups.domain, EmailDomain);\n  ta(Email$1, groups.domain, EmailDomain);\n  tt(Email$1, DOT, EmailDomainDot);\n  tt(Email$1, HYPHEN, EmailDomainHyphen);\n\n  // Final possible email states\n  const EmailColon = tt(Email$1, COLON); // URL followed by colon (potential port number here)\n  /*const EmailColonPort = */\n  ta(EmailColon, groups.numeric, Email); // URL followed by colon and port number\n\n  // Account for dots and hyphens. Hyphens are usually parts of domain names\n  // (but not TLDs)\n  const DomainHyphen = tt(Domain, HYPHEN); // domain followed by hyphen\n  const DomainDot = tt(Domain, DOT); // domain followed by DOT\n  tt(DomainHyphen, HYPHEN, DomainHyphen);\n  ta(DomainHyphen, groups.domain, Domain);\n  ta(DomainDot, localpartAccepting, Localpart);\n  ta(DomainDot, groups.domain, Domain);\n  const DomainDotTld = makeState(Url); // Simplest possible URL with no query string\n  ta(DomainDot, groups.tld, DomainDotTld);\n  ta(DomainDot, groups.utld, DomainDotTld);\n  ta(DomainDotTld, groups.domain, Domain);\n  ta(DomainDotTld, localpartAccepting, Localpart);\n  tt(DomainDotTld, DOT, DomainDot);\n  tt(DomainDotTld, HYPHEN, DomainHyphen);\n  tt(DomainDotTld, AT, LocalpartAt);\n  const DomainDotTldColon = tt(DomainDotTld, COLON); // URL followed by colon (potential port number here)\n  const DomainDotTldColonPort = makeState(Url); // TLD followed by a port number\n  ta(DomainDotTldColon, groups.numeric, DomainDotTldColonPort);\n\n  // Long URL with optional port and maybe query string\n  const Url$1 = makeState(Url);\n\n  // URL with extra symbols at the end, followed by an opening bracket\n  const UrlNonaccept = makeState(); // URL followed by some symbols (will not be part of the final URL)\n\n  // Query strings\n  ta(Url$1, qsAccepting, Url$1);\n  ta(Url$1, qsNonAccepting, UrlNonaccept);\n  ta(UrlNonaccept, qsAccepting, Url$1);\n  ta(UrlNonaccept, qsNonAccepting, UrlNonaccept);\n\n  // Become real URLs after `SLASH` or `COLON NUM SLASH`\n  // Here works with or without scheme:// prefix\n  tt(DomainDotTld, SLASH, Url$1);\n  tt(DomainDotTldColonPort, SLASH, Url$1);\n\n  // Note that domains that begin with schemes are treated slighly differently\n  const SchemeColon = tt(Scheme, COLON); // e.g., 'mailto:'\n  const SlashSchemeColon = tt(SlashScheme, COLON); // e.g., 'http:'\n  const SlashSchemeColonSlash = tt(SlashSchemeColon, SLASH); // e.g., 'http:/'\n\n  const UriPrefix = tt(SlashSchemeColonSlash, SLASH); // e.g., 'http://'\n\n  // Scheme states can transition to domain states\n  ta(Scheme, groups.domain, Domain);\n  tt(Scheme, DOT, DomainDot);\n  tt(Scheme, HYPHEN, DomainHyphen);\n  ta(SlashScheme, groups.domain, Domain);\n  tt(SlashScheme, DOT, DomainDot);\n  tt(SlashScheme, HYPHEN, DomainHyphen);\n\n  // Force URL with scheme prefix followed by anything sane\n  ta(SchemeColon, groups.domain, Url$1);\n  tt(SchemeColon, SLASH, Url$1);\n  tt(SchemeColon, QUERY, Url$1);\n  ta(UriPrefix, groups.domain, Url$1);\n  ta(UriPrefix, qsAccepting, Url$1);\n  tt(UriPrefix, SLASH, Url$1);\n  const bracketPairs = [[OPENBRACE, CLOSEBRACE],\n  // {}\n  [OPENBRACKET, CLOSEBRACKET],\n  // []\n  [OPENPAREN, CLOSEPAREN],\n  // ()\n  [OPENANGLEBRACKET, CLOSEANGLEBRACKET],\n  // <>\n  [FULLWIDTHLEFTPAREN, FULLWIDTHRIGHTPAREN],\n  // （）\n  [LEFTCORNERBRACKET, RIGHTCORNERBRACKET],\n  // 「」\n  [LEFTWHITECORNERBRACKET, RIGHTWHITECORNERBRACKET],\n  // 『』\n  [FULLWIDTHLESSTHAN, FULLWIDTHGREATERTHAN] // ＜＞\n  ];\n  for (let i = 0; i < bracketPairs.length; i++) {\n    const [OPEN, CLOSE] = bracketPairs[i];\n    const UrlOpen = tt(Url$1, OPEN); // URL followed by open bracket\n\n    // Continue not accepting for open brackets\n    tt(UrlNonaccept, OPEN, UrlOpen);\n\n    // Closing bracket component. This character WILL be included in the URL\n    tt(UrlOpen, CLOSE, Url$1);\n\n    // URL that beings with an opening bracket, followed by a symbols.\n    // Note that the final state can still be `UrlOpen` (if the URL has a\n    // single opening bracket for some reason).\n    const UrlOpenQ = makeState(Url);\n    ta(UrlOpen, qsAccepting, UrlOpenQ);\n    const UrlOpenSyms = makeState(); // UrlOpen followed by some symbols it cannot end it\n    ta(UrlOpen, qsNonAccepting);\n\n    // URL that begins with an opening bracket, followed by some symbols\n    ta(UrlOpenQ, qsAccepting, UrlOpenQ);\n    ta(UrlOpenQ, qsNonAccepting, UrlOpenSyms);\n    ta(UrlOpenSyms, qsAccepting, UrlOpenQ);\n    ta(UrlOpenSyms, qsNonAccepting, UrlOpenSyms);\n\n    // Close brace/bracket to become regular URL\n    tt(UrlOpenQ, CLOSE, Url$1);\n    tt(UrlOpenSyms, CLOSE, Url$1);\n  }\n  tt(Start, LOCALHOST, DomainDotTld); // localhost is a valid URL state\n  tt(Start, NL, Nl); // single new line\n\n  return {\n    start: Start,\n    tokens: tk\n  };\n}\n\n/**\n * Run the parser state machine on a list of scanned string-based tokens to\n * create a list of multi tokens, each of which represents a URL, email address,\n * plain text, etc.\n *\n * @param {State<MultiToken>} start parser start state\n * @param {string} input the original input used to generate the given tokens\n * @param {Token[]} tokens list of scanned tokens\n * @returns {MultiToken[]}\n */\nfunction run(start, input, tokens) {\n  let len = tokens.length;\n  let cursor = 0;\n  let multis = [];\n  let textTokens = [];\n  while (cursor < len) {\n    let state = start;\n    let secondState = null;\n    let nextState = null;\n    let multiLength = 0;\n    let latestAccepting = null;\n    let sinceAccepts = -1;\n    while (cursor < len && !(secondState = state.go(tokens[cursor].t))) {\n      // Starting tokens with nowhere to jump to.\n      // Consider these to be just plain text\n      textTokens.push(tokens[cursor++]);\n    }\n    while (cursor < len && (nextState = secondState || state.go(tokens[cursor].t))) {\n      // Get the next state\n      secondState = null;\n      state = nextState;\n\n      // Keep track of the latest accepting state\n      if (state.accepts()) {\n        sinceAccepts = 0;\n        latestAccepting = state;\n      } else if (sinceAccepts >= 0) {\n        sinceAccepts++;\n      }\n      cursor++;\n      multiLength++;\n    }\n    if (sinceAccepts < 0) {\n      // No accepting state was found, part of a regular text token add\n      // the first text token to the text tokens array and try again from\n      // the next\n      cursor -= multiLength;\n      if (cursor < len) {\n        textTokens.push(tokens[cursor]);\n        cursor++;\n      }\n    } else {\n      // Accepting state!\n      // First close off the textTokens (if available)\n      if (textTokens.length > 0) {\n        multis.push(initMultiToken(Text, input, textTokens));\n        textTokens = [];\n      }\n\n      // Roll back to the latest accepting state\n      cursor -= sinceAccepts;\n      multiLength -= sinceAccepts;\n\n      // Create a new multitoken\n      const Multi = latestAccepting.t;\n      const subtokens = tokens.slice(cursor - multiLength, cursor);\n      multis.push(initMultiToken(Multi, input, subtokens));\n    }\n  }\n\n  // Finally close off the textTokens (if available)\n  if (textTokens.length > 0) {\n    multis.push(initMultiToken(Text, input, textTokens));\n  }\n  return multis;\n}\n\n/**\n * Utility function for instantiating a new multitoken with all the relevant\n * fields during parsing.\n * @param {new (value: string, tokens: Token[]) => MultiToken} Multi class to instantiate\n * @param {string} input original input string\n * @param {Token[]} tokens consecutive tokens scanned from input string\n * @returns {MultiToken}\n */\nfunction initMultiToken(Multi, input, tokens) {\n  const startIdx = tokens[0].s;\n  const endIdx = tokens[tokens.length - 1].e;\n  const value = input.slice(startIdx, endIdx);\n  return new Multi(value, tokens);\n}\n\nconst warn = typeof console !== 'undefined' && console && console.warn || (() => {});\nconst warnAdvice = 'until manual call of linkify.init(). Register all schemes and plugins before invoking linkify the first time.';\n\n// Side-effect initialization state\nconst INIT = {\n  scanner: null,\n  parser: null,\n  tokenQueue: [],\n  pluginQueue: [],\n  customSchemes: [],\n  initialized: false\n};\n\n/**\n * @typedef {{\n * \tstart: State<string>,\n * \ttokens: { groups: Collections<string> } & typeof tk\n * }} ScannerInit\n */\n\n/**\n * @typedef {{\n * \tstart: State<MultiToken>,\n * \ttokens: typeof multi\n * }} ParserInit\n */\n\n/**\n * @typedef {(arg: { scanner: ScannerInit }) => void} TokenPlugin\n */\n\n/**\n * @typedef {(arg: { scanner: ScannerInit, parser: ParserInit }) => void} Plugin\n */\n\n/**\n * De-register all plugins and reset the internal state-machine. Used for\n * testing; not required in practice.\n * @private\n */\nfunction reset() {\n  State.groups = {};\n  INIT.scanner = null;\n  INIT.parser = null;\n  INIT.tokenQueue = [];\n  INIT.pluginQueue = [];\n  INIT.customSchemes = [];\n  INIT.initialized = false;\n  return INIT;\n}\n\n/**\n * Register a token plugin to allow the scanner to recognize additional token\n * types before the parser state machine is constructed from the results.\n * @param {string} name of plugin to register\n * @param {TokenPlugin} plugin function that accepts the scanner state machine\n * and available scanner tokens and collections and extends the state machine to\n * recognize additional tokens or groups.\n */\nfunction registerTokenPlugin(name, plugin) {\n  if (typeof plugin !== 'function') {\n    throw new Error(`linkifyjs: Invalid token plugin ${plugin} (expects function)`);\n  }\n  for (let i = 0; i < INIT.tokenQueue.length; i++) {\n    if (name === INIT.tokenQueue[i][0]) {\n      warn(`linkifyjs: token plugin \"${name}\" already registered - will be overwritten`);\n      INIT.tokenQueue[i] = [name, plugin];\n      return;\n    }\n  }\n  INIT.tokenQueue.push([name, plugin]);\n  if (INIT.initialized) {\n    warn(`linkifyjs: already initialized - will not register token plugin \"${name}\" ${warnAdvice}`);\n  }\n}\n\n/**\n * Register a linkify plugin\n * @param {string} name of plugin to register\n * @param {Plugin} plugin function that accepts the parser state machine and\n * extends the parser to recognize additional link types\n */\nfunction registerPlugin(name, plugin) {\n  if (typeof plugin !== 'function') {\n    throw new Error(`linkifyjs: Invalid plugin ${plugin} (expects function)`);\n  }\n  for (let i = 0; i < INIT.pluginQueue.length; i++) {\n    if (name === INIT.pluginQueue[i][0]) {\n      warn(`linkifyjs: plugin \"${name}\" already registered - will be overwritten`);\n      INIT.pluginQueue[i] = [name, plugin];\n      return;\n    }\n  }\n  INIT.pluginQueue.push([name, plugin]);\n  if (INIT.initialized) {\n    warn(`linkifyjs: already initialized - will not register plugin \"${name}\" ${warnAdvice}`);\n  }\n}\n\n/**\n * Detect URLs with the following additional protocol. Anything with format\n * \"protocol://...\" will be considered a link. If `optionalSlashSlash` is set to\n * `true`, anything with format \"protocol:...\" will be considered a link.\n * @param {string} scheme\n * @param {boolean} [optionalSlashSlash]\n */\nfunction registerCustomProtocol(scheme, optionalSlashSlash = false) {\n  if (INIT.initialized) {\n    warn(`linkifyjs: already initialized - will not register custom scheme \"${scheme}\" ${warnAdvice}`);\n  }\n  if (!/^[0-9a-z]+(-[0-9a-z]+)*$/.test(scheme)) {\n    throw new Error(`linkifyjs: incorrect scheme format.\n1. Must only contain digits, lowercase ASCII letters or \"-\"\n2. Cannot start or end with \"-\"\n3. \"-\" cannot repeat`);\n  }\n  INIT.customSchemes.push([scheme, optionalSlashSlash]);\n}\n\n/**\n * Initialize the linkify state machine. Called automatically the first time\n * linkify is called on a string, but may be called manually as well.\n */\nfunction init() {\n  // Initialize scanner state machine and plugins\n  INIT.scanner = init$2(INIT.customSchemes);\n  for (let i = 0; i < INIT.tokenQueue.length; i++) {\n    INIT.tokenQueue[i][1]({\n      scanner: INIT.scanner\n    });\n  }\n\n  // Initialize parser state machine and plugins\n  INIT.parser = init$1(INIT.scanner.tokens);\n  for (let i = 0; i < INIT.pluginQueue.length; i++) {\n    INIT.pluginQueue[i][1]({\n      scanner: INIT.scanner,\n      parser: INIT.parser\n    });\n  }\n  INIT.initialized = true;\n  return INIT;\n}\n\n/**\n * Parse a string into tokens that represent linkable and non-linkable sub-components\n * @param {string} str\n * @return {MultiToken[]} tokens\n */\nfunction tokenize(str) {\n  if (!INIT.initialized) {\n    init();\n  }\n  return run(INIT.parser.start, str, run$1(INIT.scanner.start, str));\n}\ntokenize.scan = run$1; // for testing\n\n/**\n * Find a list of linkable items in the given string.\n * @param {string} str string to find links in\n * @param {string | Opts} [type] either formatting options or specific type of\n * links to find, e.g., 'url' or 'email'\n * @param {Opts} [opts] formatting options for final output. Cannot be specified\n * if opts already provided in `type` argument\n */\nfunction find(str, type = null, opts = null) {\n  if (type && typeof type === 'object') {\n    if (opts) {\n      throw Error(`linkifyjs: Invalid link type ${type}; must be a string`);\n    }\n    opts = type;\n    type = null;\n  }\n  const options = new Options(opts);\n  const tokens = tokenize(str);\n  const filtered = [];\n  for (let i = 0; i < tokens.length; i++) {\n    const token = tokens[i];\n    if (token.isLink && (!type || token.t === type) && options.check(token)) {\n      filtered.push(token.toFormattedObject(options));\n    }\n  }\n  return filtered;\n}\n\n/**\n * Is the given string valid linkable text of some sort. Note that this does not\n * trim the text for you.\n *\n * Optionally pass in a second `type` param, which is the type of link to test\n * for.\n *\n * For example,\n *\n *     linkify.test(str, 'email');\n *\n * Returns `true` if str is a valid email.\n * @param {string} str string to test for links\n * @param {string} [type] optional specific link type to look for\n * @returns boolean true/false\n */\nfunction test(str, type = null) {\n  const tokens = tokenize(str);\n  return tokens.length === 1 && tokens[0].isLink && (!type || tokens[0].t === type);\n}\n\nexport { MultiToken, Options, State, createTokenClass, find, init, multi, options, regexp, registerCustomProtocol, registerPlugin, registerTokenPlugin, reset, stringToArray, test, multi as text, tokenize };\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}